
msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ü¶Ä\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-02-01 11:18+0100\n"
"Last-Translator: Martin Geisler <mgeisler@google.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: src/SUMMARY.md:3
#, fuzzy
msgid "Welcome to Comprehensive Rust ü¶Ä"
msgstr "Bienvenido a Comprehensive Rust ü¶Ä"

#: src/SUMMARY.md:4
#, fuzzy
msgid "Running the Course"
msgstr "Ejecuci√≥n del curso"

#: src/SUMMARY.md:5
#, fuzzy
msgid "Course Structure"
msgstr "Estructura del curso"

#: src/SUMMARY.md:6
#, fuzzy
msgid "Keyboard Shortcuts"
msgstr "Atajos de teclado"

#: src/SUMMARY.md:7
#, fuzzy
msgid "Using Cargo"
msgstr "Uso de carga"

#: src/SUMMARY.md:8
#, fuzzy
msgid "Rust Ecosystem"
msgstr "Ecosistema de √≥xido"

#: src/SUMMARY.md:9
#, fuzzy
msgid "Code Samples"
msgstr "Ejemplos de c√≥digo"

#: src/SUMMARY.md:10
#, fuzzy
msgid "Running Cargo Locally"
msgstr "Ejecuci√≥n de carga localmente"

#: src/SUMMARY.md:13
#, fuzzy
msgid "Day 1: Morning"
msgstr "D√≠a 1: Ma√±ana"

#: src/SUMMARY.md:17 src/SUMMARY.md:73 src/SUMMARY.md:126 src/SUMMARY.md:180
#, fuzzy
msgid "Welcome"
msgstr "Bienvenidos"

#: src/SUMMARY.md:18
#, fuzzy
msgid "What is Rust?"
msgstr "¬øQu√© es el √≥xido?"

#: src/SUMMARY.md:19
#, fuzzy
msgid "Hello World!"
msgstr "Hola Mundo!"

#: src/SUMMARY.md:20
#, fuzzy
msgid "Small Example"
msgstr "peque√±o ejemplo"

#: src/SUMMARY.md:21
#, fuzzy
msgid "Why Rust?"
msgstr "¬øPor qu√© √≥xido?"

#: src/SUMMARY.md:22
#, fuzzy
msgid "Compile Time Guarantees"
msgstr "Garant√≠as de tiempo de compilaci√≥n"

#: src/SUMMARY.md:23
#, fuzzy
msgid "Runtime Guarantees"
msgstr "Garant√≠as de tiempo de ejecuci√≥n"

#: src/SUMMARY.md:24
#, fuzzy
msgid "Modern Features"
msgstr "Caracter√≠sticas modernas"

#: src/SUMMARY.md:25
#, fuzzy
msgid "Basic Syntax"
msgstr "Sintaxis b√°sica"

#: src/SUMMARY.md:26
#, fuzzy
msgid "Scalar Types"
msgstr "Tipos escalares"

#: src/SUMMARY.md:27
#, fuzzy
msgid "Compound Types"
msgstr "Tipos de compuestos"

#: src/SUMMARY.md:28
#, fuzzy
msgid "References"
msgstr "Referencias"

#: src/SUMMARY.md:29
#, fuzzy
msgid "Dangling References"
msgstr "Referencias colgantes"

#: src/SUMMARY.md:30
#, fuzzy
msgid "Slices"
msgstr "rebanadas"

#: src/SUMMARY.md:31
#, fuzzy
msgid "String vs str"
msgstr "Cadena vs cadena"

#: src/SUMMARY.md:32
#, fuzzy
msgid "Functions"
msgstr "Funciones"

#: src/SUMMARY.md:33 src/SUMMARY.md:80
#, fuzzy
msgid "Methods"
msgstr "M√©todos"

#: src/SUMMARY.md:34
#, fuzzy
msgid "Overloading"
msgstr "Sobrecarga"

#: src/SUMMARY.md:35 src/SUMMARY.md:64 src/SUMMARY.md:88 src/SUMMARY.md:117
#: src/SUMMARY.md:145 src/SUMMARY.md:172 src/SUMMARY.md:195 src/SUMMARY.md:222
#, fuzzy
msgid "Exercises"
msgstr "Ejercicios"

#: src/SUMMARY.md:36
#, fuzzy
msgid "Implicit Conversions"
msgstr "Conversiones impl√≠citas"

#: src/SUMMARY.md:37
#, fuzzy
msgid "Arrays and for Loops"
msgstr "Matrices y bucles for"

#: src/SUMMARY.md:39
#, fuzzy
msgid "Day 1: Afternoon"
msgstr "D√≠a 1: Tarde"

#: src/SUMMARY.md:41
#, fuzzy
msgid "Variables"
msgstr "Variables"

#: src/SUMMARY.md:42
#, fuzzy
msgid "Type Inference"
msgstr "Inferencia de tipo"

#: src/SUMMARY.md:43
#, fuzzy
msgid "static & const"
msgstr "est√°tico y constante"

#: src/SUMMARY.md:44
#, fuzzy
msgid "Scopes and Shadowing"
msgstr "√Åmbitos y sombreado"

#: src/SUMMARY.md:45
#, fuzzy
msgid "Memory Management"
msgstr "Gesti√≥n de la memoria"

#: src/SUMMARY.md:46
#, fuzzy
msgid "Stack vs Heap"
msgstr "Pila vs Mont√≥n"

#: src/SUMMARY.md:47
#, fuzzy
msgid "Stack Memory"
msgstr "memoria de pila"

#: src/SUMMARY.md:48
#, fuzzy
msgid "Manual Memory Management"
msgstr "Gesti√≥n de memoria manual"

#: src/SUMMARY.md:49
#, fuzzy
msgid "Scope-Based Memory Management"
msgstr "Administraci√≥n de memoria basada en alcance"

#: src/SUMMARY.md:50
#, fuzzy
msgid "Garbage Collection"
msgstr "Recolecci√≥n de basura"

#: src/SUMMARY.md:51
#, fuzzy
msgid "Rust Memory Management"
msgstr "Gesti√≥n de memoria oxidada"

#: src/SUMMARY.md:52
#, fuzzy
msgid "Comparison"
msgstr "Comparaci√≥n"

#: src/SUMMARY.md:53
#, fuzzy
msgid "Ownership"
msgstr "Propiedad"

#: src/SUMMARY.md:54
#, fuzzy
msgid "Move Semantics"
msgstr "Mover sem√°ntica"

#: src/SUMMARY.md:55
#, fuzzy
msgid "Moved Strings in Rust"
msgstr "Cuerdas movidas en Rust"

#: src/SUMMARY.md:56
#, fuzzy
msgid "Double Frees in Modern C++"
msgstr "Liberaciones dobles en C++ moderno"

#: src/SUMMARY.md:57
#, fuzzy
msgid "Moves in Function Calls"
msgstr "Movimientos en llamadas a funciones"

#: src/SUMMARY.md:58
#, fuzzy
msgid "Copying and Cloning"
msgstr "Copia y Clonaci√≥n"

#: src/SUMMARY.md:59
#, fuzzy
msgid "Borrowing"
msgstr "Pr√©stamo"

#: src/SUMMARY.md:60
#, fuzzy
msgid "Shared and Unique Borrows"
msgstr "Pr√©stamos compartidos y √∫nicos"

#: src/SUMMARY.md:61
#, fuzzy
msgid "Lifetimes"
msgstr "vidas"

#: src/SUMMARY.md:62
#, fuzzy
msgid "Lifetimes in Function Calls"
msgstr "Duraci√≥n de las llamadas a funciones"

#: src/SUMMARY.md:63
#, fuzzy
msgid "Lifetimes in Data Structures"
msgstr "Tiempos de vida en estructuras de datos"

#: src/SUMMARY.md:65
#, fuzzy
msgid "Designing a Library"
msgstr "Dise√±ando una biblioteca"

#: src/SUMMARY.md:66
#, fuzzy
msgid "Iterators and Ownership"
msgstr "Iteradores y propiedad"

#: src/SUMMARY.md:69
#, fuzzy
msgid "Day 2: Morning"
msgstr "D√≠a 2: Ma√±ana"

#: src/SUMMARY.md:74
#, fuzzy
msgid "Structs"
msgstr "estructuras"

#: src/SUMMARY.md:75
#, fuzzy
msgid "Tuple Structs"
msgstr "Estructuras de tupla"

#: src/SUMMARY.md:76
#, fuzzy
msgid "Field Shorthand Syntax"
msgstr "Sintaxis abreviada de campo"

#: src/SUMMARY.md:77
#, fuzzy
msgid "Enums"
msgstr "Enumeraciones"

#: src/SUMMARY.md:78
#, fuzzy
msgid "Variant Payloads"
msgstr "Cargas √∫tiles variantes"

#: src/SUMMARY.md:79
#, fuzzy
msgid "Enum Sizes"
msgstr "Tama√±os de enumeraci√≥n"

#: src/SUMMARY.md:81
#, fuzzy
msgid "Method Receiver"
msgstr "Receptor de m√©todo"

#: src/SUMMARY.md:82 src/SUMMARY.md:190
#, fuzzy
msgid "Example"
msgstr "Ejemplo"

#: src/SUMMARY.md:83
#, fuzzy
msgid "Pattern Matching"
msgstr "La coincidencia de patrones"

#: src/SUMMARY.md:84
#, fuzzy
msgid "Destructuring Enums"
msgstr "Desestructuraci√≥n de enumeraciones"

#: src/SUMMARY.md:85
#, fuzzy
msgid "Destructuring Structs"
msgstr "Estructuras de desestructuraci√≥n"

#: src/SUMMARY.md:86
#, fuzzy
msgid "Destructuring Arrays"
msgstr "Destrucci√≥n de arreglos"

#: src/SUMMARY.md:87
#, fuzzy
msgid "Match Guards"
msgstr "Guardias de partido"

#: src/SUMMARY.md:89
#, fuzzy
msgid "Health Statistics"
msgstr "Estad√≠sticas de salud"

#: src/SUMMARY.md:90
#, fuzzy
msgid "Points and Polygons"
msgstr "Puntos y Pol√≠gonos"

#: src/SUMMARY.md:92
#, fuzzy
msgid "Day 2: Afternoon"
msgstr "D√≠a 2: Tarde"

#: src/SUMMARY.md:94
#, fuzzy
msgid "Control Flow"
msgstr "Flujo de control"

#: src/SUMMARY.md:95
#, fuzzy
msgid "Blocks"
msgstr "bloques"

#: src/SUMMARY.md:96
#, fuzzy
msgid "if expressions"
msgstr "si las expresiones"

#: src/SUMMARY.md:97
#, fuzzy
msgid "if let expressions"
msgstr "si dejar expresiones"

#: src/SUMMARY.md:98
#, fuzzy
msgid "while expressions"
msgstr "mientras expresiones"

#: src/SUMMARY.md:99
#, fuzzy
msgid "while let expressions"
msgstr "mientras deja expresiones"

#: src/SUMMARY.md:100
#, fuzzy
msgid "for expressions"
msgstr "para expresiones"

#: src/SUMMARY.md:101
#, fuzzy
msgid "loop expressions"
msgstr "expresiones de bucle"

#: src/SUMMARY.md:102
#, fuzzy
msgid "match expressions"
msgstr "expresiones de coincidencia"

#: src/SUMMARY.md:103
#, fuzzy
msgid "break & continue"
msgstr "romper y continuar"

#: src/SUMMARY.md:104
#, fuzzy
msgid "Standard Library"
msgstr "Biblioteca est√°ndar"

#: src/SUMMARY.md:105
#, fuzzy
msgid "Option and Result"
msgstr "Opci√≥n y resultado"

#: src/SUMMARY.md:106
#, fuzzy
msgid "String"
msgstr "Cuerda"

#: src/SUMMARY.md:107
#, fuzzy
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:108
#, fuzzy
msgid "HashMap"
msgstr "mapa hash"

#: src/SUMMARY.md:109
#, fuzzy
msgid "Box"
msgstr "Caja"

#: src/SUMMARY.md:110
#, fuzzy
msgid "Recursive Data Types"
msgstr "Tipos de datos recursivos"

#: src/SUMMARY.md:111
#, fuzzy
msgid "Niche Optimization"
msgstr "Optimizaci√≥n de nicho"

#: src/SUMMARY.md:112
#, fuzzy
msgid "Rc"
msgstr "RC"

#: src/SUMMARY.md:113
#, fuzzy
msgid "Modules"
msgstr "M√≥dulos"

#: src/SUMMARY.md:114
#, fuzzy
msgid "Visibility"
msgstr "Visibilidad"

#: src/SUMMARY.md:115
#, fuzzy
msgid "Paths"
msgstr "Caminos"

#: src/SUMMARY.md:116
#, fuzzy
msgid "Filesystem Hierarchy"
msgstr "Jerarqu√≠a del sistema de archivos"

#: src/SUMMARY.md:118
#, fuzzy
msgid "Luhn Algorithm"
msgstr "Algoritmo de Luhn"

#: src/SUMMARY.md:119
#, fuzzy
msgid "Strings and Iterators"
msgstr "Cadenas e iteradores"

#: src/SUMMARY.md:122
#, fuzzy
msgid "Day 3: Morning"
msgstr "D√≠a 3: Ma√±ana"

#: src/SUMMARY.md:127
#, fuzzy
msgid "Traits"
msgstr "Rasgos"

#: src/SUMMARY.md:128
#, fuzzy
msgid "Deriving Traits"
msgstr "Rasgos derivados"

#: src/SUMMARY.md:129
#, fuzzy
msgid "Default Methods"
msgstr "M√©todos predeterminados"

#: src/SUMMARY.md:130
#, fuzzy
msgid "Important Traits"
msgstr "Rasgos importantes"

#: src/SUMMARY.md:131
#, fuzzy
msgid "Iterator"
msgstr "iterador"

#: src/SUMMARY.md:132
#, fuzzy
msgid "FromIterator"
msgstr "De iterador"

#: src/SUMMARY.md:133
#, fuzzy
msgid "From and Into"
msgstr "desde y hacia"

#: src/SUMMARY.md:134
#, fuzzy
msgid "Read and Write"
msgstr "Lee y escribe"

#: src/SUMMARY.md:135
#, fuzzy
msgid "Add, Mul, ..."
msgstr "A√±adir, Mul, ..."

#: src/SUMMARY.md:136
#, fuzzy
msgid "Drop"
msgstr "Gota"

#: src/SUMMARY.md:137
#, fuzzy
msgid "Generics"
msgstr "Gen√©ricos"

#: src/SUMMARY.md:138
#, fuzzy
msgid "Generic Data Types"
msgstr "Tipos de datos gen√©ricos"

#: src/SUMMARY.md:139
#, fuzzy
msgid "Generic Methods"
msgstr "M√©todos gen√©ricos"

#: src/SUMMARY.md:140
#, fuzzy
msgid "Trait Bounds"
msgstr "L√≠mites de rasgos"

#: src/SUMMARY.md:141
#, fuzzy
msgid "impl Trait"
msgstr "rasgo impl"

#: src/SUMMARY.md:142
#, fuzzy
msgid "Closures"
msgstr "Cierres"

#: src/SUMMARY.md:143
#, fuzzy
msgid "Monomorphization"
msgstr "Monomorfizaci√≥n"

#: src/SUMMARY.md:144
#, fuzzy
msgid "Trait Objects"
msgstr "Objetos de rasgos"

#: src/SUMMARY.md:146
#, fuzzy
msgid "A Simple GUI Library"
msgstr "Una biblioteca GUI simple"

#: src/SUMMARY.md:148
#, fuzzy
msgid "Day 3: Afternoon"
msgstr "D√≠a 3: Tarde"

#: src/SUMMARY.md:150
#, fuzzy
msgid "Error Handling"
msgstr "Manejo de errores"

#: src/SUMMARY.md:151
#, fuzzy
msgid "Panics"
msgstr "P√°nicos"

#: src/SUMMARY.md:152
#, fuzzy
msgid "Catching Stack Unwinding"
msgstr "Atrapar Pila Desenrollar"

#: src/SUMMARY.md:153
#, fuzzy
msgid "Structured Error Handling"
msgstr "Manejo estructurado de errores"

#: src/SUMMARY.md:154
#, fuzzy
msgid "Propagating Errors with ?"
msgstr "Propagando errores con ?"

#: src/SUMMARY.md:155
#, fuzzy
msgid "Converting Error Types"
msgstr "Conversi√≥n de tipos de error"

#: src/SUMMARY.md:156
#, fuzzy
msgid "Deriving Error Enums"
msgstr "Derivaci√≥n de enumeraciones de errores"

#: src/SUMMARY.md:157
#, fuzzy
msgid "Dynamic Error Types"
msgstr "Tipos de errores din√°micos"

#: src/SUMMARY.md:158
#, fuzzy
msgid "Adding Context to Errors"
msgstr "Agregar contexto a los errores"

#: src/SUMMARY.md:159
#, fuzzy
msgid "Testing"
msgstr "Pruebas"

#: src/SUMMARY.md:160
#, fuzzy
msgid "Unit Tests"
msgstr "Pruebas unitarias"

#: src/SUMMARY.md:161
#, fuzzy
msgid "Test Modules"
msgstr "M√≥dulos de prueba"

#: src/SUMMARY.md:162
#, fuzzy
msgid "Documentation Tests"
msgstr "Pruebas de documentaci√≥n"

#: src/SUMMARY.md:163
#, fuzzy
msgid "Integration Tests"
msgstr "Pruebas de integraci√≥n"

#: src/SUMMARY.md:164
#, fuzzy
msgid "Unsafe Rust"
msgstr "√≥xido inseguro"

#: src/SUMMARY.md:165
#, fuzzy
msgid "Dereferencing Raw Pointers"
msgstr "Eliminaci√≥n de referencias de punteros sin procesar"

#: src/SUMMARY.md:166
#, fuzzy
msgid "Mutable Static Variables"
msgstr "Variables est√°ticas mutables"

#: src/SUMMARY.md:167
#, fuzzy
msgid "Unions"
msgstr "sindicatos"

#: src/SUMMARY.md:168
#, fuzzy
msgid "Calling Unsafe Functions"
msgstr "Llamar a funciones no seguras"

#: src/SUMMARY.md:169
#, fuzzy
msgid "Writing Unsafe Functions"
msgstr "Escribir funciones no seguras"

#: src/SUMMARY.md:170
#, fuzzy
msgid "Extern Functions"
msgstr "Funciones Externas"

#: src/SUMMARY.md:171
#, fuzzy
msgid "Implementing Unsafe Traits"
msgstr "Implementaci√≥n de rasgos inseguros"

#: src/SUMMARY.md:173
#, fuzzy
msgid "Safe FFI Wrapper"
msgstr "Envoltura FFI segura"

#: src/SUMMARY.md:176
#, fuzzy
msgid "Day 4: Morning"
msgstr "D√≠a 4: Ma√±ana"

#: src/SUMMARY.md:181
#, fuzzy
msgid "Concurrency"
msgstr "concurrencia"

#: src/SUMMARY.md:182
#, fuzzy
msgid "Threads"
msgstr "Hilos"

#: src/SUMMARY.md:183
#, fuzzy
msgid "Scoped Threads"
msgstr "Subprocesos con alcance"

#: src/SUMMARY.md:184
#, fuzzy
msgid "Channels"
msgstr "Canales"

#: src/SUMMARY.md:185
#, fuzzy
msgid "Unbounded Channels"
msgstr "Canales ilimitados"

#: src/SUMMARY.md:186
#, fuzzy
msgid "Bounded Channels"
msgstr "Canales delimitados"

#: src/SUMMARY.md:187
#, fuzzy
msgid "Shared State"
msgstr "Estado compartido"

#: src/SUMMARY.md:188
#, fuzzy
msgid "Arc"
msgstr "Arco"

#: src/SUMMARY.md:189
#, fuzzy
msgid "Mutex"
msgstr "exclusi√≥n mutua"

#: src/SUMMARY.md:191
#, fuzzy
msgid "Send and Sync"
msgstr "Enviar y sincronizar"

#: src/SUMMARY.md:191
#, fuzzy
msgid "Send"
msgstr "Enviar"

#: src/SUMMARY.md:191
#, fuzzy
msgid "Sync"
msgstr "sincronizar"

#: src/SUMMARY.md:194
#, fuzzy
msgid "Examples"
msgstr "Ejemplos"

#: src/SUMMARY.md:196
#, fuzzy
msgid "Dining Philosophers"
msgstr "Fil√≥sofos gastron√≥micos"

#: src/SUMMARY.md:197
#, fuzzy
msgid "Multi-threaded Link Checker"
msgstr "Comprobador de enlaces de subprocesos m√∫ltiples"

#: src/SUMMARY.md:199
#, fuzzy
msgid "Day 4: Afternoon"
msgstr "D√≠a 4: Tarde"

#: src/SUMMARY.md:203
#, fuzzy
msgid "Android"
msgstr "Androide"

#: src/SUMMARY.md:204
#, fuzzy
msgid "Setup"
msgstr "Configuraci√≥n"

#: src/SUMMARY.md:205
#, fuzzy
msgid "Build Rules"
msgstr "Reglas de construcci√≥n"

#: src/SUMMARY.md:206
#, fuzzy
msgid "Binary"
msgstr "Binario"

#: src/SUMMARY.md:207
#, fuzzy
msgid "Library"
msgstr "Biblioteca"

#: src/SUMMARY.md:208
#, fuzzy
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:209
#, fuzzy
msgid "Interface"
msgstr "Interfaz"

#: src/SUMMARY.md:210
#, fuzzy
msgid "Implementation"
msgstr "Implementaci√≥n"

#: src/SUMMARY.md:211
#, fuzzy
msgid "Server"
msgstr "Servidor"

#: src/SUMMARY.md:212
#, fuzzy
msgid "Deploy"
msgstr "Desplegar"

#: src/SUMMARY.md:213
#, fuzzy
msgid "Client"
msgstr "Cliente"

#: src/SUMMARY.md:214
#, fuzzy
msgid "Changing API"
msgstr "Cambio de API"

#: src/SUMMARY.md:215
#, fuzzy
msgid "Logging"
msgstr "Inicio sesi√≥n"

#: src/SUMMARY.md:216
#, fuzzy
msgid "Interoperability"
msgstr "interoperabilidad"

#: src/SUMMARY.md:217
#, fuzzy
msgid "With C"
msgstr "Con C"

#: src/SUMMARY.md:218
#, fuzzy
msgid "Calling C with Bindgen"
msgstr "Llamar a C con Bindgen"

#: src/SUMMARY.md:219
#, fuzzy
msgid "Calling Rust from C"
msgstr "Llamando a Rust desde C"

#: src/SUMMARY.md:220
#, fuzzy
msgid "With C++"
msgstr "con C++"

#: src/SUMMARY.md:221
#, fuzzy
msgid "With Java"
msgstr "con Java"

#: src/SUMMARY.md:224
#, fuzzy
msgid "Final Words"
msgstr "Ultimas palabras"

#: src/SUMMARY.md:226
#, fuzzy
msgid "Thanks!"
msgstr "¬°Gracias!"

#: src/SUMMARY.md:227
#, fuzzy
msgid "Other Resources"
msgstr "Otros recursos"

#: src/SUMMARY.md:228
#, fuzzy
msgid "Credits"
msgstr "Cr√©ditos"

#: src/SUMMARY.md:232
#, fuzzy
msgid "Solutions"
msgstr "Soluciones"

#: src/SUMMARY.md:237
#, fuzzy
msgid "Day 1 Morning"
msgstr "D√≠a 1 Ma√±ana"

#: src/SUMMARY.md:238
#, fuzzy
msgid "Day 1 Afternoon"
msgstr "D√≠a 1 Tarde"

#: src/SUMMARY.md:239
#, fuzzy
msgid "Day 2 Morning"
msgstr "D√≠a 2 Ma√±ana"

#: src/SUMMARY.md:240
#, fuzzy
msgid "Day 2 Afternoon"
msgstr "D√≠a 2 Tarde"

#: src/SUMMARY.md:241
#, fuzzy
msgid "Day 3 Morning"
msgstr "D√≠a 3 Ma√±ana"

#: src/SUMMARY.md:242
#, fuzzy
msgid "Day 3 Afternoon"
msgstr "D√≠a 3 Tarde"

#: src/SUMMARY.md:243
#, fuzzy
msgid "Day 4 Morning"
msgstr "D√≠a 4 Ma√±ana"

#: src/welcome.md:1
#, fuzzy
msgid "# Welcome to Comprehensive Rust ü¶Ä"
msgstr "# Bienvenidos a Comprehensive Rust ü¶Ä"

#: src/welcome.md:3
#, fuzzy
msgid ""
"This is a four day Rust course developed by the Android team. The course "
"covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like "
"generics\n"
"and error handling. It also includes Android-specific content on the last "
"day."
msgstr ""
"Este es un curso de Rust de cuatro d√≠as desarrollado por el equipo de "
"Android. El curso cubre\n"
"el espectro completo de Rust, desde sintaxis b√°sica hasta temas avanzados "
"como gen√©ricos\n"
"y manejo de errores. Tambi√©n incluye contenido espec√≠fico de Android en el "
"√∫ltimo d√≠a."

#: src/welcome.md:7
#, fuzzy
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything\n"
"about Rust and hope to:"
msgstr ""
"El objetivo del curso es ense√±arte Rust. Suponemos que no sabes nada.\n"
"sobre Rust y espero:"

#: src/welcome.md:10
#, fuzzy
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Brindarle una comprensi√≥n integral de la sintaxis y el lenguaje de Rust.\n"
"* Le permite modificar programas existentes y escribir nuevos programas en "
"Rust.\n"
"* Mostrar expresiones idiom√°ticas comunes de Rust."

#: src/welcome.md:14
#, fuzzy
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "En el D√≠a 4, cubriremos cosas espec√≠ficas de Android como:"

#: src/welcome.md:16
#, fuzzy
msgid ""
"* Building Android components in Rust.\n"
"* AIDL servers and clients.\n"
"* Interoperability with C, C++, and Java."
msgstr ""
"* Construcci√≥n de componentes de Android en Rust.\n"
"* Servidores y clientes AIDL.\n"
"* Interoperabilidad con C, C++ y Java."

#: src/welcome.md:20
#, fuzzy
msgid ""
"It is important to note that this course does not cover Android "
"**application** \n"
"development in Rust, and that the Android-specific parts are specifically "
"about\n"
"writing code for Android itself, the operating system. "
msgstr ""
"Es importante tener en cuenta que este curso no cubre la **aplicaci√≥n** de "
"Android\n"
"desarrollo en Rust, y que las partes espec√≠ficas de Android son "
"espec√≠ficamente sobre\n"
"escribir c√≥digo para el propio Android, el sistema operativo."

#: src/welcome.md:24
#, fuzzy
msgid "## Non-Goals"
msgstr "## Sin objetivos"

#: src/welcome.md:26
#, fuzzy
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust es un lenguaje extenso y no podremos cubrirlo todo en unos d√≠as.\n"
"Algunos no objetivos de este curso son:"

#: src/welcome.md:29
#, fuzzy
msgid ""
"* Learn how to use async Rust --- we'll only mention async Rust when\n"
"  covering traditional concurrency primitives. Please see [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
"  details on this topic.\n"
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* Aprende a usar Rust as√≠ncrono --- solo mencionaremos Rust as√≠ncrono "
"cuando\n"
"  cubriendo primitivas de concurrencia tradicionales. Consulte [As√≠ncrono\n"
"  Programaci√≥n en Rust](https://rust-lang.github.io/async-book/) en lugar "
"de\n"
"  detalles sobre este tema.\n"
"* Aprenda a desarrollar macros, consulte [Cap√≠tulo 19.5 en Rust\n"
"  Libro](https://doc.rust-lang.org/book/ch19-06-macros.html) y [Rust por\n"
"  Ejemplo](https://doc.rust-lang.org/rust-by-example/macros.html) en su "
"lugar."

#: src/welcome.md:37
#, fuzzy
msgid "## Assumptions"
msgstr "## Supuestos"

#: src/welcome.md:39
#, fuzzy
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically\n"
"typed language and we will sometimes make comparisons with C and C++ to "
"better\n"
"explain or contrast the Rust approach."
msgstr ""
"El curso asume que ya sabes programar. El √≥xido es un est√°tico\n"
"lenguaje escrito y a veces haremos comparaciones con C y C++ para mejorar\n"
"explicar o contrastar el enfoque de Rust."

#: src/welcome.md:43
#, fuzzy
msgid ""
"If you know how to program in a dynamically typed language such as Python "
"or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Si sabe c√≥mo programar en un lenguaje de escritura din√°mica como Python o\n"
"JavaScript, entonces tambi√©n podr√° seguirlo bien."

#: src/welcome.md:46 src/cargo/rust-ecosystem.md:19
#: src/cargo/code-samples.md:22 src/cargo/running-locally.md:68
#: src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8
#: src/why-rust/modern.md:19 src/basic-syntax/compound-types.md:28
#: src/basic-syntax/slices.md:18 src/basic-syntax/string-slices.md:25
#: src/basic-syntax/functions.md:33 src/basic-syntax/functions-interlude.md:25
#: src/exercises/day-1/morning.md:9 src/exercises/day-1/for-loops.md:90
#: src/basic-syntax/variables.md:15 src/basic-syntax/type-inference.md:24
#: src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27
#: src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums/variant-payloads.md:33
#: src/methods.md:28 src/pattern-matching/destructuring-enums.md:33
#: src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:40
#: src/control-flow/if-expressions.md:29
#: src/control-flow/if-let-expressions.md:19
#: src/control-flow/while-let-expressions.md:25 src/std/option-result.md:16
#: src/std/string.md:28 src/std/box.md:32 src/std/rc.md:26
#: src/exercises/day-2/afternoon.md:5 src/traits.md:39
#: src/traits/iterator.md:30 src/traits/from-iterator.md:12
#: src/traits/operators.md:24 src/traits/drop.md:32 src/generics/methods.md:23
#: src/generics/trait-bounds.md:20 src/generics/impl-trait.md:22
#: src/generics/closures.md:23 src/exercises/day-3/morning.md:5
#: src/error-handling/result.md:25 src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types.md:66
#: src/error-handling/deriving-error-enums.md:37
#: src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26
#: src/unsafe/raw-pointers.md:24 src/unsafe/mutable-static-variables.md:30
#: src/unsafe/unions.md:19 src/unsafe/writing-unsafe-functions.md:31
#: src/unsafe/extern-functions.md:19 src/unsafe/unsafe-traits.md:28
#: src/exercises/day-3/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/channels.md:25 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/example.md:21 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/sync.md:12 src/exercises/day-4/morning.md:10
#: src/android/interoperability/with-c/rust.md:81
#: src/exercises/day-4/afternoon.md:10
#, fuzzy
msgid "<details>"
msgstr "<detalles>"

#: src/welcome.md:48
#, fuzzy
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor "
"should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"Este es un ejemplo de una _nota del orador_. Usaremos estos para agregar "
"m√°s\n"
"informaci√≥n a las diapositivas. Estos podr√≠an ser puntos clave que el "
"instructor deber√≠a\n"
"cubierta, as√≠ como respuestas a preguntas t√≠picas que surgen en clase."

#: src/welcome.md:52 src/cargo/rust-ecosystem.md:67
#: src/cargo/code-samples.md:35 src/cargo/running-locally.md:74
#: src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:36 src/hello-world/small-example.md:44 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22
#: src/why-rust/modern.md:66 src/basic-syntax/compound-types.md:62
#: src/basic-syntax/references.md:28 src/basic-syntax/slices.md:36
#: src/basic-syntax/functions.md:54 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48
#: src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:32
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/borrowing.md:51
#: src/ownership/shared-unique-borrows.md:29
#: src/ownership/lifetimes-function-calls.md:60
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:103
#: src/structs.md:40 src/enums/variant-payloads.md:39 src/enums/sizes.md:49
#: src/methods/example.md:53 src/pattern-matching/destructuring-enums.md:39
#: src/exercises/day-2/morning.md:15 src/exercises/day-2/points-polygons.md:125
#: src/control-flow/if-let-expressions.md:26 src/std.md:31
#: src/std/option-result.md:25 src/std/string.md:34 src/std/vec.md:38
#: src/std/box.md:37 src/std/rc.md:32 src/exercises/day-2/afternoon.md:11
#: src/traits.md:54 src/traits/from-iterator.md:23 src/traits/operators.md:38
#: src/traits/drop.md:42 src/generics/methods.md:31 src/generics/closures.md:38
#: src/exercises/day-3/morning.md:11 src/error-handling/try-operator.md:55
#: src/error-handling/converting-error-types.md:78
#: src/error-handling/deriving-error-enums.md:45
#: src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32
#: src/unsafe/raw-pointers.md:42 src/unsafe/mutable-static-variables.md:35
#: src/unsafe/unions.md:28 src/unsafe/writing-unsafe-functions.md:38
#: src/unsafe/extern-functions.md:28 src/unsafe/unsafe-traits.md:37
#: src/exercises/day-3/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/channels.md:32 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/example.md:60
#: src/concurrency/send-sync/sync.md:18 src/exercises/day-4/morning.md:16
#: src/android/interoperability/with-c/rust.md:86
#: src/exercises/day-4/afternoon.md:15
#, fuzzy
msgid "</details>"
msgstr "</detalles>"

#: src/running-the-course.md:1
#, fuzzy
msgid "# Running the Course"
msgstr "# Ejecuci√≥n del curso"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
#, fuzzy
msgid "> This page is for the course instructor."
msgstr "> Esta p√°gina es para el instructor del curso."

#: src/running-the-course.md:5
#, fuzzy
msgid ""
"Here is a bit of background information about how we've been running the "
"course\n"
"internally at Google."
msgstr ""
"Aqu√≠ hay un poco de informaci√≥n b√°sica sobre c√≥mo hemos estado ejecutando el "
"curso.\n"
"internamente en Google."

#: src/running-the-course.md:8
#, fuzzy
msgid "To run the course, you need to:"
msgstr "Para ejecutar el curso, es necesario:"

#: src/running-the-course.md:10
#, fuzzy
msgid ""
"1. Make yourself familiar with the course material. We've included speaker "
"notes\n"
"   on some of the pages to help highlight the key points (please help us by\n"
"   contributing more speaker notes!). You should make sure to open the "
"speaker\n"
"   notes in a popup (click the link with a little arrow next to \"Speaker\n"
"   Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"1. Familiar√≠cese con el material del curso. Hemos incluido notas del orador\n"
"   en algunas de las p√°ginas para ayudar a resaltar los puntos clave (por "
"favor ay√∫denos\n"
"   contribuyendo con m√°s notas del orador!). Debes asegurarte de abrir el "
"altavoz.\n"
"   notas en una ventana emergente (haga clic en el enlace con una peque√±a "
"flecha al lado de \"Altavoz\n"
"   Notas\"). De esta manera, tiene una pantalla limpia para presentar a la "
"clase."

#: src/running-the-course.md:16
#, fuzzy
msgid ""
"2. Decide on the dates. Since the course is large, we recommend that you\n"
"   schedule the four days over two weeks. Course participants have said "
"that\n"
"   they find it helpful to have a gap in the course since it helps them "
"process\n"
"   all the information we give them."
msgstr ""
"2. Decide las fechas. Dado que el curso es grande, le recomendamos que\n"
"   programe los cuatro d√≠as durante dos semanas. Los participantes del curso "
"han dicho que\n"
"   les resulta √∫til tener una pausa en el curso, ya que les ayuda a "
"procesar\n"
"   toda la informaci√≥n que les damos."

#: src/running-the-course.md:21
#, fuzzy
msgid ""
"3. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-20 people. That's small enough that people are "
"comfortable\n"
"   asking questions --- it's also small enough that one instructor will "
"have\n"
"   time to answer the questions."
msgstr ""
"3. Encuentre una sala lo suficientemente grande para sus participantes en "
"persona. Recomendamos un\n"
"   tama√±o de la clase de 15-20 personas. Eso es lo suficientemente peque√±o "
"como para que la gente se sienta c√≥moda.\n"
"   haciendo preguntas --- tambi√©n es lo suficientemente peque√±o como para "
"que un instructor tenga\n"
"   hora de contestar las preguntas."

#: src/running-the-course.md:26
#, fuzzy
msgid ""
"4. On the day of your course, show up to the room a little early to set "
"things\n"
"   up. We recommend presenting directly using `mdbook serve` running on "
"your\n"
"   laptop. This ensures optimal performance with no lag as you change "
"pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them."
msgstr ""
"4. El d√≠a de tu curso, pres√©ntate en la sala un poco antes para arreglar las "
"cosas.\n"
"   hasta. Recomendamos presentar directamente usando `mdbook serve` "
"ejecut√°ndose en su\n"
"   ordenador port√°til. Esto garantiza un rendimiento √≥ptimo sin retrasos al "
"cambiar de p√°gina.\n"
"   El uso de su computadora port√°til tambi√©n le permitir√° corregir errores "
"tipogr√°ficos como usted o el curso.\n"
"   los participantes los detectan."

#: src/running-the-course.md:32
#, fuzzy
msgid ""
"5. Let people solve the exercises by themselves or in small groups. Make "
"sure to\n"
"   ask people if they're stuck or if there is anything you can help with. "
"When\n"
"   you see that several people have the same problem, call it out to the "
"class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"5. Deje que las personas resuelvan los ejercicios por s√≠ mismos o en "
"peque√±os grupos. Asegurate que\n"
"   pregunta a las personas si est√°n atascadas o si hay algo en lo que puedas "
"ayudar. Cu√°ndo\n"
"   ves que varias personas tienen el mismo problema, d√≠selo a la clase\n"
"   y ofrecer una soluci√≥n, por ejemplo, mostrando a las personas d√≥nde "
"encontrar la informaci√≥n relevante\n"
"   informaci√≥n en la biblioteca est√°ndar."

#: src/running-the-course.md:38
#, fuzzy
msgid ""
"6. If you don't skip the Android specific parts on Day 4, you will need an "
"[AOSP\n"
"   checkout][1]. Make a checkout of the [course repository][2] on the same\n"
"   machine and move the `src/android/` directory into the root of your AOSP\n"
"   checkout. This will ensure that the Android build system sees the\n"
"   `Android.bp` files in `src/android/`."
msgstr ""
"6. Si no omite las partes espec√≠ficas de Android en el D√≠a 4, necesitar√° un "
"[AOSP\n"
"   pagar][1]. Realice una compra en el [repositorio de cursos][2] en el "
"mismo\n"
"   m√°quina y mueva el directorio `src/android/` a la ra√≠z de su AOSP\n"
"   verificar. Esto garantizar√° que el sistema de compilaci√≥n de Android vea "
"el\n"
"   Archivos `Android.bp` en `src/android/`."

#: src/running-the-course.md:44
#, fuzzy
msgid ""
"   Ensure that `adb sync` works with your emulator or real device and "
"pre-build\n"
"   all Android examples using `src/android/build_all.sh`. Read the script to "
"see\n"
"   the commands it runs and make sure they work when you run them by hand."
msgstr ""
"   Aseg√∫rese de que `adb sync` funcione con su emulador o dispositivo real y "
"preconstruya\n"
"   todos los ejemplos de Android usando `src/android/build_all.sh`. Lea el "
"gui√≥n para ver\n"
"   los comandos que ejecuta y aseg√∫rese de que funcionan cuando los ejecuta "
"a mano."

#: src/running-the-course.md:48
#, fuzzy
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for\n"
"you as it has been for us!"
msgstr ""
"Eso es todo, ¬°buena suerte con el curso! Esperamos que sea tan divertido "
"para\n"
"usted como lo ha sido para nosotros!"

#: src/running-the-course.md:51
#, fuzzy
msgid ""
"Please [provide feedback][3] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][4]!"
msgstr ""
"Por favor, [proporcione comentarios][3] despu√©s para que podamos seguir "
"mejorando el\n"
"curso. Nos encantar√≠a saber qu√© funcion√≥ bien para usted y qu√© se puede "
"hacer\n"
"mejor. ¬°Sus estudiantes tambi√©n son bienvenidos a [enviarnos comentarios] "
"[4]!"

#: src/running-the-course.md:55
#, fuzzy
msgid ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100"
msgstr ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discusiones/86\n"
"[4]: https://github.com/google/comprehensive-rust/discusiones/100"

#: src/running-the-course/course-structure.md:1
#, fuzzy
msgid "# Course Structure"
msgstr "# Estructura del curso"

#: src/running-the-course/course-structure.md:5
#, fuzzy
msgid "The course is fast paced and covers a lot of ground:"
msgstr "El curso es r√°pido y cubre mucho terreno:"

#: src/running-the-course/course-structure.md:7
#, fuzzy
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust.\n"
"* Day 4: Concurrency in Rust and interoperability with other languages"
msgstr ""
"* D√≠a 1: Rust b√°sico, propiedad y el verificador de pr√©stamo.\n"
"* D√≠a 2: tipos de datos compuestos, coincidencia de patrones, la biblioteca "
"est√°ndar.\n"
"* D√≠a 3: Rasgos y gen√©ricos, manejo de errores, pruebas, Rust inseguro.\n"
"* D√≠a 4: Concurrencia en Rust e interoperabilidad con otros lenguajes"

#: src/running-the-course/course-structure.md:12
#, fuzzy
msgid ""
"> **Exercise for Day 4:** Do you interface with some C/C++ code in your "
"project\n"
"> which we could attempt to move to Rust? The fewer dependencies the "
"better.\n"
"> Parsing code would be ideal."
msgstr ""
"> **Ejercicio para el d√≠a 4:** ¬øInteract√∫as con alg√∫n c√≥digo C/C++ en tu "
"proyecto?\n"
"> que podr√≠amos intentar mover a Rust? Cuantas menos dependencias, mejor.\n"
"> Analizar c√≥digo ser√≠a ideal."

#: src/running-the-course/course-structure.md:16
#, fuzzy
msgid "## Format"
msgstr "## Formato"

#: src/running-the-course/course-structure.md:18
#, fuzzy
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"El curso est√° destinado a ser muy interactivo y recomendamos dejar que el\n"
"¬°Las preguntas impulsan la exploraci√≥n de Rust!"

#: src/running-the-course/keyboard-shortcuts.md:1
#, fuzzy
msgid "# Keyboard Shortcuts"
msgstr "# Atajos de teclado"

#: src/running-the-course/keyboard-shortcuts.md:3
#, fuzzy
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Hay varios atajos de teclado √∫tiles en mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
#, fuzzy
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Flecha-Izquierda</kbd>: Navegar a la p√°gina anterior.\n"
"* <kbd>Flecha-Derecha</kbd>: Navegar a la p√°gina siguiente.\n"
"* <kbd>Ctrl + Enter</kbd>: Ejecuta el ejemplo de c√≥digo que tiene el foco.\n"
"* <kbd>s</kbd>: Activa la barra de b√∫squeda."

#: src/cargo.md:1
#, fuzzy
msgid "# Using Cargo"
msgstr "# Uso de carga"

#: src/cargo.md:3
#, fuzzy
msgid ""
"When you start reading about Rust, you will soon meet "
"[Cargo](https://doc.rust-lang.org/cargo/), the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want "
"to\n"
"give a brief overview of what Cargo is and how it fits into the wider "
"ecosystem\n"
"and how it fits into this training."
msgstr ""
"Cuando empiece a leer sobre Rust, pronto conocer√° "
"[Cargo](https://doc.rust-lang.org/cargo/), la herramienta est√°ndar\n"
"utilizado en el ecosistema Rust para construir y ejecutar aplicaciones Rust. "
"Aqu√≠ queremos\n"
"dar una breve descripci√≥n de lo que es Cargo y c√≥mo encaja en el ecosistema "
"m√°s amplio\n"
"y c√≥mo encaja en esta formaci√≥n."

#: src/cargo.md:8
#, fuzzy
msgid "## Installation"
msgstr "## Instalaci√≥n"

#: src/cargo.md:10
#, fuzzy
msgid "### Rustup (Recommended)"
msgstr "### Rustup (recomendado)"

#: src/cargo.md:12
#, fuzzy
msgid ""
"You can follow the instructions to install cargo and rust compiler, among "
"other standard ecosystem tools with the [rustup][3] tool, which is "
"maintained by the Rust Foundation."
msgstr ""
"Puede seguir las instrucciones para instalar Cargo y Rust Compiler, entre "
"otras herramientas est√°ndar del ecosistema, con la herramienta [rustup][3], "
"mantenida por Rust Foundation."

#: src/cargo.md:14
#, fuzzy
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line "
"utility that you can use to install/switch toolchains, setup cross "
"compilation, etc."
msgstr ""
"Junto con cargo y rustc, Rustup se instalar√° como una utilidad de l√≠nea de "
"comandos que puede usar para instalar/cambiar cadenas de herramientas, "
"configurar la compilaci√≥n cruzada, etc."

#: src/cargo.md:16
#, fuzzy
msgid "### Package Managers"
msgstr "### Administradores de paquetes"

#: src/cargo.md:18
#, fuzzy
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
#, fuzzy
msgid "On Debian/Ubuntu, you can install Cargo and the Rust source with"
msgstr "En Debian/Ubuntu, puede instalar Cargo y la fuente de Rust con"

#: src/cargo.md:22
#, fuzzy
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src\n"
"```"
msgstr ""
"```concha\n"
"$ sudo apt install cargo rust-src\n"
"```"

#: src/cargo.md:26
#, fuzzy
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest "
"using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Esto permitir√° que [rust-analyzer][1] salte a las definiciones. Sugerimos "
"usar\n"
"[VS Code][2] para editar el c√≥digo (pero cualquier editor compatible con LSP "
"funciona)."

#: src/cargo.md:29
#, fuzzy
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do "
"their own analysis but have their own tradeoffs. If you prefer them, you can "
"install the [Rust Plugin][5]. Please take note that as of January 2023 "
"debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"A algunas personas tambi√©n les gusta usar la familia [JetBrains][4] de IDE, "
"que hacen su propio an√°lisis pero tienen sus propias compensaciones. Si los "
"prefiere, puede instalar el [Complemento Rust][5]. Tenga en cuenta que, a "
"partir de enero de 2023, la depuraci√≥n solo funciona en la versi√≥n CLion de "
"la suite JetBrains IDEA."

#: src/cargo.md:31
#, fuzzy
msgid ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/"
msgstr ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/"

#: src/cargo/rust-ecosystem.md:1
#, fuzzy
msgid "# The Rust Ecosystem"
msgstr "# El ecosistema del √≥xido"

#: src/cargo/rust-ecosystem.md:3
#, fuzzy
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"El ecosistema de Rust consta de una serie de herramientas, de las cuales las "
"principales son:"

#: src/cargo/rust-ecosystem.md:5
#, fuzzy
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and "
"other\n"
"  intermediate formats[^rustc]."
msgstr ""
"* `rustc`: el compilador de Rust que convierte los archivos `.rs` en "
"binarios y otros\n"
"  formatos intermedios[^rustc]."

#: src/cargo/rust-ecosystem.md:8
#, fuzzy
msgid ""
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them "
"to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests[^cargo]."
msgstr ""
"* `cargo`: el administrador de dependencias de Rust y la herramienta de "
"compilaci√≥n. Cargo sabe c√≥mo\n"
"  descargue las dependencias alojadas en <https://crates.io> y las pasar√° a\n"
"  `rustc` al construir su proyecto. Cargo tambi√©n viene con una prueba "
"incorporada\n"
"  runner que se utiliza para ejecutar pruebas unitarias[^cargo]."

#: src/cargo/rust-ecosystem.md:13
#, fuzzy
msgid ""
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is "
"released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and "
"`rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustup`: el instalador y actualizador de la cadena de herramientas de "
"Rust. Esta herramienta se utiliza para\n"
"  instale y actualice `rustc` y `cargo` cuando se publiquen nuevas versiones "
"de Rust.\n"
"  Adem√°s, `rustup` tambi√©n puede descargar documentaci√≥n para el est√°ndar\n"
"  biblioteca. Puede tener varias versiones de Rust instaladas a la vez y "
"`rustup`\n"
"  le permitir√° cambiar entre ellos seg√∫n sea necesario."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types.md:68
#: src/concurrency/threads.md:30
#, fuzzy
msgid "Key points:"
msgstr "Puntos clave:"

#: src/cargo/rust-ecosystem.md:23
#, fuzzy
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality."
msgstr ""
"* Rust tiene un calendario de lanzamiento r√°pido con un nuevo lanzamiento "
"por salir\n"
"  cada seis semanas. Las nuevas versiones mantienen la compatibilidad con "
"versiones anteriores de\n"
"  Versiones antiguas --- adem√°s permiten nuevas funcionalidades."

#: src/cargo/rust-ecosystem.md:27
#, fuzzy
msgid ""
"* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "* Hay tres canales de lanzamiento: \"estable\", \"beta\" y \"nocturno\"."

#: src/cargo/rust-ecosystem.md:29
#, fuzzy
msgid ""
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks."
msgstr ""
"* Se est√°n probando nuevas funciones en \"nightly\", \"beta\" es lo que se "
"convierte\n"
"  \"estable\" cada seis semanas."

#: src/cargo/rust-ecosystem.md:32
#, fuzzy
msgid ""
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018."
msgstr ""
"* Rust tambi√©n tiene [ediciones]: la edici√≥n actual es Rust 2021. Anterior\n"
"  Las ediciones fueron Rust 2015 y Rust 2018."

#: src/cargo/rust-ecosystem.md:35
#, fuzzy
msgid ""
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language."
msgstr ""
"  * Las ediciones pueden hacer cambios incompatibles con versiones "
"anteriores de\n"
"    el idioma."

#: src/cargo/rust-ecosystem.md:38
#, fuzzy
msgid ""
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file."
msgstr ""
"  * Para evitar descifrar el c√≥digo, las ediciones son opcionales: "
"seleccione el\n"
"    edici√≥n para su caja a trav√©s del archivo `Cargo.toml`."

#: src/cargo/rust-ecosystem.md:41
#, fuzzy
msgid ""
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions."
msgstr ""
"  * Para evitar dividir el ecosistema, los compiladores de Rust pueden "
"mezclar c√≥digo\n"
"    escrito para diferentes ediciones."

#: src/cargo/rust-ecosystem.md:44
#, fuzzy
msgid ""
"  * Mention that it is quite rare to ever use the compiler directly not "
"through `cargo` (most users never do)."
msgstr ""
"  * Mencione que es bastante raro usar el compilador directamente, no a "
"trav√©s de `cargo` (la mayor√≠a de los usuarios nunca lo hacen)."

#: src/cargo/rust-ecosystem.md:46
#, fuzzy
msgid ""
"  * It might be worth alluding that Cargo itself is an extremely powerful "
"and comprehensive tool.  It is capable of many advanced features including "
"but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as "
"[cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"  * Vale la pena mencionar que Cargo en s√≠ mismo es una herramienta "
"extremadamente poderosa y completa. Es capaz de muchas caracter√≠sticas "
"avanzadas que incluyen pero no se limitan a:\n"
"      * Estructura del proyecto/paquete\n"
"      * [espacios de trabajo]\n"
"      * Dependencias de desarrollo y gesti√≥n/almacenamiento en cach√© de "
"dependencias de tiempo de ejecuci√≥n\n"
"      * [creaci√≥n de secuencias de comandos]\n"
"      * [instalaci√≥n global]\n"
"      * Tambi√©n es extensible con complementos de subcomandos (como [cargo "
"clippy]).\n"
"  * Lea m√°s del [Libro de carga oficial]"

#: src/cargo/rust-ecosystem.md:55
#, fuzzy
msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
msgstr "[ediciones]: https://doc.rust-lang.org/edition-guide/"

#: src/cargo/rust-ecosystem.md:57
#, fuzzy
msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
msgstr ""
"[espacios de trabajo]: "
"https://doc.rust-lang.org/cargo/reference/workspaces.html"

#: src/cargo/rust-ecosystem.md:59
#, fuzzy
msgid ""
"[build scripting]: "
"https://doc.rust-lang.org/cargo/reference/build-scripts.html"
msgstr ""
"[creaci√≥n de secuencias de comandos]: "
"https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#: src/cargo/rust-ecosystem.md:61
#, fuzzy
msgid ""
"[global installation]: "
"https://doc.rust-lang.org/cargo/commands/cargo-install.html"
msgstr ""
"[instalaci√≥n global]: "
"https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#: src/cargo/rust-ecosystem.md:63
#, fuzzy
msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
msgstr "[recorte de carga]: https://github.com/rust-lang/rust-clippy"

#: src/cargo/rust-ecosystem.md:65
#, fuzzy
msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
msgstr "[Libro de carga oficial]: https://doc.rust-lang.org/cargo/"

#: src/cargo/code-samples.md:1
#, fuzzy
msgid "# Code Samples in This Training"
msgstr "# Ejemplos de c√≥digo en esta capacitaci√≥n"

#: src/cargo/code-samples.md:3
#, fuzzy
msgid ""
"For this training, we will mostly explore the Rust language through "
"examples\n"
"which can be executed through your browser. This makes the setup much easier "
"and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Para esta capacitaci√≥n, exploraremos principalmente el lenguaje Rust a "
"trav√©s de ejemplos.\n"
"que se puede ejecutar a trav√©s de su navegador. Esto hace que la "
"configuraci√≥n sea mucho m√°s f√°cil y\n"
"asegura una experiencia consistente para todos."

#: src/cargo/code-samples.md:7
#, fuzzy
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the\n"
"exercises. On the last day, we will do a larger exercise which shows you how "
"to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"Todav√≠a se recomienda instalar Cargo: le facilitar√° hacer el\n"
"ejercicios. El √∫ltimo d√≠a, haremos un ejercicio m√°s amplio que le mostrar√° "
"c√≥mo\n"
"trabaja con dependencias y para eso necesitas Cargo."

#: src/cargo/code-samples.md:11
#, fuzzy
msgid "The code blocks in this course are fully interactive:"
msgstr "Los bloques de c√≥digo de este curso son totalmente interactivos:"

#: src/cargo/code-samples.md:13
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    println!(\"¬°Ed√≠tame!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
#, fuzzy
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in "
"the\n"
"text box."
msgstr ""
"Puede usar <kbd>Ctrl + Enter</kbd> para ejecutar el c√≥digo cuando el foco "
"est√° en el\n"
"caja de texto."

#: src/cargo/code-samples.md:24
#, fuzzy
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"La mayor√≠a de los ejemplos de c√≥digo se pueden editar como se muestra "
"arriba. Algunas muestras de c√≥digo\n"
"no son editables por varias razones:"

#: src/cargo/code-samples.md:27
#, fuzzy
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests."
msgstr ""
"* Los juegos integrados no pueden ejecutar pruebas unitarias. Copia y pega "
"el\n"
"  c√≥digo y √°bralo en el Playground real para demostrar las pruebas unitarias."

#: src/cargo/code-samples.md:30
#, fuzzy
msgid ""
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* Los parques infantiles incrustados pierden su estado en el momento en que "
"navegas\n"
"  fuera de la p√°gina! Esta es la raz√≥n por la que los estudiantes deben\n"
"  Resuelva los ejercicios usando una instalaci√≥n local de Rust o mediante "
"el\n"
"  Patio de recreo."

#: src/cargo/running-locally.md:1
#, fuzzy
msgid "# Running Code Locally with Cargo"
msgstr "# Ejecutar c√≥digo localmente con carga"

#: src/cargo/running-locally.md:3
#, fuzzy
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time "
"of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Si desea experimentar con el c√≥digo en su propio sistema, necesitar√°\n"
"para instalar primero Rust. Haga esto siguiendo las [instrucciones en Rust\n"
"Libro 1]. Esto deber√≠a darte un `rustc` y un `cargo` que funcionen. En el "
"momento de\n"
"escribiendo, la √∫ltima versi√≥n estable de Rust tiene estos n√∫meros de "
"versi√≥n:"

#: src/cargo/running-locally.md:8
#, fuzzy
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""
"```concha\n"
"% rustc --versi√≥n\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% carga --versi√≥n\n"
"carga 1.61.0 (a028ae4 2022-04-29)\n"
"```"

#: src/cargo/running-locally.md:15
#, fuzzy
msgid ""
"With this is in place, then follow these steps to build a Rust binary from "
"one\n"
"of the examples in this training:"
msgstr ""
"Con esto en su lugar, siga estos pasos para construir un binario de Rust a "
"partir de uno\n"
"de los ejemplos en este entrenamiento:"

#: src/cargo/running-locally.md:18
#, fuzzy
msgid ""
"1. Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"1. Haga clic en el bot√≥n \"Copiar al portapapeles\" en el ejemplo que desea "
"copiar."

#: src/cargo/running-locally.md:20
#, fuzzy
msgid ""
"2. Use `cargo new exercise` to create a new `exercise/` directory for your "
"code:"
msgstr ""
"2. Use `cargo new exercise` para crear un nuevo directorio `exercise/` para "
"su c√≥digo:"

#: src/cargo/running-locally.md:22
#, fuzzy
msgid ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"
msgstr ""
"    ```concha\n"
"    $ cargo nuevo ejercicio\n"
"         Se cre√≥ el paquete `ejercicio` binario (aplicaci√≥n)\n"
"    ```"

#: src/cargo/running-locally.md:27
#, fuzzy
msgid ""
"3. Navigate into `exercise/` and use `cargo run` to build and run your "
"binary:"
msgstr ""
"3. Navegue a `exercise/` y use `cargo run` para construir y ejecutar su "
"binario:"

#: src/cargo/running-locally.md:29
#, fuzzy
msgid ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"
msgstr ""
"    ```concha\n"
"    $ cd ejercicio\n"
"    $ carrera de carga\n"
"       Ejercicio de compilaci√≥n v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Objetivos de desarrollo [no optimizados + informaci√≥n de depuraci√≥n] "
"terminados en 0,75 s\n"
"         Ejecutando `target/debug/exercise`\n"
"    ¬°Hola Mundo!\n"
"    ```"

#: src/cargo/running-locally.md:38
#, fuzzy
msgid ""
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look "
"like"
msgstr ""
"4. Reemplace el c√≥digo est√°ndar en `src/main.rs` con su propio c√≥digo. Para\n"
"   ejemplo, utilizando el ejemplo de la p√°gina anterior, haga que "
"`src/main.rs` se vea como"

#: src/cargo/running-locally.md:41
#, fuzzy
msgid ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```"
msgstr ""
"    ```herrumbre\n"
"    fn principal() {\n"
"        println!(\"¬°Ed√≠tame!\");\n"
"    }\n"
"    ```"

#: src/cargo/running-locally.md:47
#, fuzzy
msgid "5. Use `cargo run` to build and run your updated binary:"
msgstr "5. Use `cargo run` para construir y ejecutar su binario actualizado:"

#: src/cargo/running-locally.md:49
#, fuzzy
msgid ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```"
msgstr ""
"    ```concha\n"
"    $ carrera de carga\n"
"       Ejercicio de compilaci√≥n v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Objetivos de desarrollo [no optimizados + informaci√≥n de depuraci√≥n] "
"terminados en 0,24 s\n"
"         Ejecutando `target/debug/exercise`\n"
"    ¬°Ed√≠tame!\n"
"    ```"

#: src/cargo/running-locally.md:57
#, fuzzy
msgid ""
"6. Use `cargo check` to quickly check your project for errors, use `cargo "
"build`\n"
"   to compile it without running it. You will find the output in "
"`target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an "
"optimized\n"
"   release build in `target/release/`."
msgstr ""
"6. Use `cargo check` para verificar r√°pidamente su proyecto en busca de "
"errores, use `cargo build`\n"
"   para compilarlo sin ejecutarlo. Encontrar√° la salida en `target/debug/`\n"
"   para una compilaci√≥n de depuraci√≥n normal. Use `cargo build --release` "
"para producir una versi√≥n optimizada\n"
"   versi√≥n compilada en `target/release/`."

#: src/cargo/running-locally.md:62
#, fuzzy
msgid ""
"7. You can add dependencies for your project by editing `Cargo.toml`. When "
"you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"7. Puede agregar dependencias para su proyecto editando `Cargo.toml`. Cuando "
"usted\n"
"   ejecute los comandos `cargo`, se descargar√° y compilar√° autom√°ticamente\n"
"   dependencias para usted."

#: src/cargo/running-locally.md:66
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
msgstr "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"

#: src/cargo/running-locally.md:70
#, fuzzy
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Trate de animar a los participantes de la clase a instalar Cargo y utilizar "
"un\n"
"redactor local Les har√° la vida m√°s f√°cil ya que tendr√°n un\n"
"ambiente normal de desarrollo."

#: src/welcome-day-1.md:1
#, fuzzy
msgid "# Welcome to Day 1"
msgstr "# Bienvenido al D√≠a 1"

#: src/welcome-day-1.md:3
#, fuzzy
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr ""
"Este es el primer d√≠a de Comprehensive Rust. Cubriremos mucho terreno\n"
"hoy:"

#: src/welcome-day-1.md:6
#, fuzzy
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods."
msgstr ""
"* Sintaxis b√°sica de Rust: variables, tipos escalares y compuestos, "
"enumeraciones, estructuras,\n"
"  referencias, funciones y m√©todos."

#: src/welcome-day-1.md:9
#, fuzzy
msgid ""
"* Memory management: stack vs heap, manual memory management, scope-based "
"memory\n"
"  management, and garbage collection."
msgstr ""
"* Gesti√≥n de memoria: pila frente a mont√≥n, gesti√≥n de memoria manual, "
"memoria basada en alcance\n"
"  manejo y recolecci√≥n de basura."

#: src/welcome-day-1.md:12
#, fuzzy
msgid ""
"* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"* Propiedad: sem√°ntica de movimiento, copia y clonaci√≥n, pr√©stamo y vidas."

#: src/welcome-day-1.md:16
#, fuzzy
msgid "Please remind the students that:"
msgstr "Por favor, recuerde a los estudiantes que:"

#: src/welcome-day-1.md:18
#, fuzzy
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much "
"encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, "
"i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can "
"be\n"
"    hard to find the right balance, but err on the side of allowing "
"discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of leaning. "
"Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Deben hacer preguntas cuando las reciban, no las guarden para el final.\n"
"* ¬°La clase est√° destinada a ser interactiva y se recomiendan mucho las "
"discusiones!\n"
"  * Como instructor, debe tratar de mantener las discusiones relevantes, es "
"decir,\n"
"    mantenga lo relacionado con c√≥mo Rust hace las cosas frente a alg√∫n otro "
"idioma. Puede ser\n"
"    es dif√≠cil encontrar el equilibrio correcto, pero se equivoca al "
"permitir discusiones\n"
"    ya que involucran a las personas mucho m√°s que una comunicaci√≥n "
"unidireccional.\n"
"* Las preguntas probablemente significar√°n que estamos sobre las cosas antes "
"de las diapositivas.\n"
"  * ¬°Esto est√° perfectamente bien! La repetici√≥n es una parte importante de "
"la inclinaci√≥n. Recordar\n"
"    que las diapositivas son solo un apoyo y que puede omitirlas a medida "
"que\n"
"    como."

#: src/welcome-day-1.md:29
#, fuzzy
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak\n"
"about the famous borrow checker. The way Rust handles memory is a major "
"feature\n"
"and we should show students this right away."
msgstr ""
"La idea para el primer d√≠a es mostrar _lo suficiente_ de Rust para poder "
"hablar\n"
"sobre el famoso verificador de pr√©stamos. La forma en que Rust maneja la "
"memoria es una caracter√≠stica importante\n"
"y debemos mostrar esto a los estudiantes de inmediato."

#: src/welcome-day-1.md:33
#, fuzzy
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Si est√° ense√±ando esto en un sal√≥n de clases, este es un buen lugar para "
"repasar el\n"
"calendario. Sugerimos dividir el d√≠a en dos partes (siguiendo las "
"diapositivas):"

#: src/welcome-day-1.md:36
#, fuzzy
msgid "* Morning: 9:00 to 12:00,\n* Afternoon: 13:00 to 16:00."
msgstr "* Ma√±ana: 9:00 a 12:00,\n* Tarde: 13:00 a 16:00."

#: src/welcome-day-1.md:39
#, fuzzy
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks,\n"
"we recommend a break every hour!"
msgstr ""
"Por supuesto, puede ajustar esto seg√∫n sea necesario. Aseg√∫rese de incluir "
"descansos,\n"
"¬°Recomendamos un descanso cada hora!"

#: src/welcome-day-1/what-is-rust.md:1
#, fuzzy
msgid "# What is Rust?"
msgstr "# ¬øQu√© es el √≥xido?"

#: src/welcome-day-1/what-is-rust.md:3
#, fuzzy
msgid "Rust is a new programming language which had its 1.0 release in 2015:"
msgstr ""
"Rust es un nuevo lenguaje de programaci√≥n que tuvo su versi√≥n 1.0 en 2015:"

#: src/welcome-day-1/what-is-rust.md:5
#, fuzzy
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  "
"architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust es un lenguaje compilado est√°ticamente con una funci√≥n similar a C++\n"
"  * `rustc` usa LLVM como backend.\n"
"* Rust es compatible con muchas [plataformas y\n"
"  arquitecturas] "
"(https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, BRAZO, WebAssembly,...\n"
"  *Linux, Mac, Windows,...\n"
"* Rust se utiliza para una amplia gama de dispositivos:\n"
"  * firmware y cargadores de arranque,\n"
"  * pantallas inteligentes,\n"
"  * tel√©fonos m√≥viles,\n"
"  * escritorios,\n"
"  * servidores."

#: src/welcome-day-1/what-is-rust.md:21
#, fuzzy
msgid "Rust fits in the same area as C++:"
msgstr "Rust encaja en la misma √°rea que C++:"

#: src/welcome-day-1/what-is-rust.md:23
#, fuzzy
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Alta flexibilidad.\n"
"* Alto nivel de control.\n"
"* Se puede reducir a dispositivos muy limitados, como tel√©fonos m√≥viles.\n"
"* No tiene tiempo de ejecuci√≥n ni recolecci√≥n de basura.\n"
"* Se centra en la fiabilidad y la seguridad sin sacrificar el rendimiento."

#: src/hello-world.md:1
#, fuzzy
msgid "# Hello World!"
msgstr "# ¬°Hola Mundo!"

#: src/hello-world.md:3
#, fuzzy
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr ""
"Saltemos al programa Rust m√°s simple posible, un cl√°sico Hello World\n"
"programa:"

#: src/hello-world.md:6
#, fuzzy
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello üåç!\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre\n"
"fn principal() {\n"
"    println!(\"¬°Hola üåç!\");\n"
"}\n"
"```"

#: src/hello-world.md:12
#, fuzzy
msgid "What you see:"
msgstr "Lo que ves:"

#: src/hello-world.md:14
#, fuzzy
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Las funciones se introducen con `fn`.\n"
"* Los bloques est√°n delimitados por llaves como en C y C++.\n"
"* La funci√≥n `principal` es el punto de entrada del programa.\n"
"* Rust tiene macros higi√©nicas, `println!` es un ejemplo de esto.\n"
"* Las cadenas Rust est√°n codificadas en UTF-8 y pueden contener cualquier "
"car√°cter Unicode."

#: src/hello-world.md:22
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see\n"
"a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Esta diapositiva intenta que los estudiantes se sientan c√≥modos con el "
"c√≥digo Rust. Ellos ver√°n\n"
"una tonelada durante los pr√≥ximos cuatro d√≠as, as√≠ que empezamos poco a poco "
"con algo familiar."

#: src/hello-world.md:27
#, fuzzy
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary."
msgstr ""
"* Rust es muy parecido a otros lenguajes en la tradici√≥n C/C++/Java. Est√°\n"
"  imperativo (no funcional) y no trata de reinventar las cosas a menos que\n"
"  absolutamente necesario."

#: src/hello-world.md:31
#, fuzzy
msgid "* Rust is modern with full support for things like Unicode."
msgstr "* Rust es moderno con soporte completo para cosas como Unicode."

#: src/hello-world.md:33
#, fuzzy
msgid ""
"* Rust uses macros for situations where you want to have a variable number "
"of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"* Rust usa macros para situaciones en las que desea tener un n√∫mero variable "
"de\n"
"  argumentos (sin funci√≥n [sobrecarga] (sintaxis "
"b√°sica/funciones-interlude.md))."

#: src/hello-world/small-example.md:1
#, fuzzy
msgid "# Small Example"
msgstr "# Peque√±o ejemplo"

#: src/hello-world/small-example.md:3
#, fuzzy
msgid "Here is a small example program in Rust:"
msgstr "Aqu√≠ hay un peque√±o programa de ejemplo en Rust:"

#: src/hello-world/small-example.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn main() { // Punto de entrada del programa\n"
"    sea mut x: i32 = 6; // enlace de variable mutable\n"
"    imprimir!(\"{x}\"); // Macro para imprimir, como printf\n"
"    while x != 1 { // Sin par√©ntesis alrededor de la expresi√≥n\n"
"        if x % 2 == 0 { // Matem√°ticas como en otros idiomas\n"
"            x = x / 2;\n"
"        } m√°s {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        imprimir!(\" -> {x}\");\n"
"    }\n"
"    imprimir!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
#, fuzzy
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will\n"
"always end, but this is not yet proved. Edit the code and play with "
"different\n"
"inputs."
msgstr ""
"El c√≥digo implementa la conjetura de Collatz: se cree que el ciclo\n"
"siempre terminan, pero esto a√∫n no est√° probado. Edita el c√≥digo y juega con "
"diferentes\n"
"entradas."

#: src/hello-world/small-example.md:29
#, fuzzy
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to "
"trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""
"* Explique que todas las variables est√°n tipadas est√°ticamente. Intenta "
"eliminar `i32` para activar\n"
"  inferencia de tipo. Pruebe con `i8` en su lugar y active un desbordamiento "
"de enteros en tiempo de ejecuci√≥n."

#: src/hello-world/small-example.md:32
#, fuzzy
msgid "* Change `let mut x` to `let x`, discuss the compiler error."
msgstr "* Cambie `let mut x` a `let x`, discuta el error del compilador."

#: src/hello-world/small-example.md:34
#, fuzzy
msgid ""
"* Show how `print!` gives a compilation error if the arguments don't match "
"the\n"
"  format string."
msgstr ""
"* Muestra c√≥mo `print!` da un error de compilaci√≥n si los argumentos no "
"coinciden con los\n"
"  cadena de formato."

#: src/hello-world/small-example.md:37
#, fuzzy
msgid ""
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable."
msgstr ""
"* Muestra c√≥mo necesitas usar `{}` como marcador de posici√≥n si quieres "
"imprimir un\n"
"  expresi√≥n que es m√°s compleja que una sola variable."

#: src/hello-world/small-example.md:40
#, fuzzy
msgid ""
"* Show the students the standard library, show them how to search for "
"`std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that "
"the\n"
"  students become familiar with searching in the standard library."
msgstr ""
"* Muestre a los estudiantes la biblioteca est√°ndar, mu√©streles c√≥mo buscar "
"`std::fmt`\n"
"  que tiene las reglas del minilenguaje de formateo. Es importante que el\n"
"  los estudiantes se familiaricen con la b√∫squeda en la biblioteca est√°ndar."

#: src/why-rust.md:1
#, fuzzy
msgid "# Why Rust?"
msgstr "# ¬øPor qu√© se oxida?"

#: src/why-rust.md:3
#, fuzzy
msgid "Some unique selling points of Rust:"
msgstr "Algunos puntos de venta √∫nicos de Rust:"

#: src/why-rust.md:5
#, fuzzy
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Seguridad de la memoria de tiempo de compilaci√≥n.\n"
"* Falta de comportamiento de tiempo de ejecuci√≥n indefinido.\n"
"* Caracter√≠sticas del lenguaje moderno."

#: src/why-rust.md:11
#, fuzzy
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Aseg√∫rese de preguntar a la clase con qu√© idiomas tienen experiencia. "
"Dependiente\n"
"en la respuesta puede resaltar diferentes caracter√≠sticas de Rust:"

#: src/why-rust.md:14
#, fuzzy
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime "
"errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you "
"don't\n"
"  have the memory unsafety issues. In addition, you get a modern language "
"with\n"
"  constructs like pattern matching and built-in dependency management."
msgstr ""
"* Experiencia con C o C++: Rust elimina toda una clase de _errores de tiempo "
"de ejecuci√≥n_\n"
"  a trav√©s del verificador de pr√©stamo. Obtiene un rendimiento como en C y "
"C++, pero no\n"
"  tienen los problemas de inseguridad de la memoria. Adem√°s, obtienes un "
"lenguaje moderno con\n"
"  construcciones como la coincidencia de patrones y la gesti√≥n de "
"dependencias integrada."

#: src/why-rust.md:19
#, fuzzy
msgid ""
"* Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety\n"
"  as in those languages, plus a similar high-level language feeling. In "
"addition\n"
"  you get fast and predictable performance like C and C++ (no garbage "
"collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Experiencia con Java, Go, Python, JavaScript...: obtienes la misma "
"seguridad de memoria\n"
"  como en esos idiomas, adem√°s de una sensaci√≥n de lenguaje de alto nivel "
"similar. Adem√°s\n"
"  obtiene un rendimiento r√°pido y predecible como C y C++ (sin recolector de "
"basura)\n"
"  as√≠ como acceso a hardware de bajo nivel (si lo necesita)"

#: src/why-rust/compile-time.md:1
#, fuzzy
msgid "# Compile Time Guarantees"
msgstr "# Garant√≠as de tiempo de compilaci√≥n"

#: src/why-rust/compile-time.md:3
#, fuzzy
msgid "Static memory management at compile time:"
msgstr "Gesti√≥n de memoria est√°tica en tiempo de compilaci√≥n:"

#: src/why-rust/compile-time.md:5
#, fuzzy
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Sin variables no inicializadas.\n"
"* Sin fugas de memoria (_principalmente_, ver notas).\n"
"* Sin dobles gratis.\n"
"* No use-after-free.\n"
"* Sin punteros `NULL`.\n"
"* Sin exclusi√≥n mutua bloqueada olvidada.\n"
"* No hay carreras de datos entre subprocesos.\n"
"* Sin invalidaci√≥n del iterador."

#: src/why-rust/compile-time.md:16
#, fuzzy
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"Es posible producir p√©rdidas de memoria en Rust (seguro). Algunos ejemplos\n"
"est√°n:"

#: src/why-rust/compile-time.md:19
#, fuzzy
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Puede usar [`Box::leak`] para filtrar un puntero. Un uso de esto podr√≠a\n"
"  ser para obtener variables est√°ticas inicializadas en tiempo de ejecuci√≥n "
"y del tama√±o del tiempo de ejecuci√≥n\n"
"* Puedes usar [`std::mem::forget`] para hacer que el compilador \"olvide\"\n"
"  un valor (lo que significa que el destructor nunca se ejecuta).\n"
"* Tambi√©n puede crear accidentalmente un [ciclo de referencia] con `Rc` o\n"
"  `Arco`.\n"
"* De hecho, algunos considerar√°n poblar infinitamente una colecci√≥n como una "
"memoria\n"
"  fugas y Rust no protege de ellas."

#: src/why-rust/compile-time.md:28
#, fuzzy
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"A los efectos de este curso, debe entenderse \"sin p√©rdidas de memoria\".\n"
"como \"Pr√°cticamente no hay p√©rdidas de memoria *accidentales*\"."

#: src/why-rust/compile-time.md:31
#, fuzzy
msgid ""
"[`Box::leak`]: "
"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[reference cycle]: "
"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
msgstr ""
"[`Cuadro::fuga`]: "
"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[ciclo de referencia]: "
"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"

#: src/why-rust/runtime.md:1
#, fuzzy
msgid "# Runtime Guarantees"
msgstr "# Garant√≠as de tiempo de ejecuci√≥n"

#: src/why-rust/runtime.md:3
#, fuzzy
msgid "No undefined behavior at runtime:"
msgstr "Sin comportamiento indefinido en tiempo de ejecuci√≥n:"

#: src/why-rust/runtime.md:5
#, fuzzy
msgid "* Array access is bounds checked.\n* Integer overflow is defined."
msgstr ""
"* Se comprueban los l√≠mites del acceso a la matriz.\n"
"* Se define el desbordamiento de enteros."

#: src/why-rust/runtime.md:12
#, fuzzy
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`)."
msgstr ""
"* El desbordamiento de enteros se define a trav√©s de un indicador de tiempo "
"de compilaci√≥n. las opciones son\n"
"  ya sea un p√°nico (un bloqueo controlado del programa) o un ajuste\n"
"  sem√°ntica. De forma predeterminada, obtiene p√°nicos en modo de depuraci√≥n "
"(`cargo build`)\n"
"  y envolvente en modo de lanzamiento (`cargo build --release`)."

#: src/why-rust/runtime.md:17
#, fuzzy
msgid ""
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* La verificaci√≥n de l√≠mites no se puede deshabilitar con un indicador de "
"compilador. Tambi√©n puede\n"
"  no se puede deshabilitar directamente con la palabra clave `inseguro`. Sin "
"embargo,\n"
"  `unsafe` le permite llamar a funciones como `slice::get_unchecked`\n"
"  que no comprueba los l√≠mites."

#: src/why-rust/modern.md:1
#, fuzzy
msgid "# Modern Features"
msgstr "# Funciones modernas"

#: src/why-rust/modern.md:3
#, fuzzy
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr ""
"Rust est√° construido con toda la experiencia adquirida en los √∫ltimos 40 "
"a√±os."

#: src/why-rust/modern.md:5
#, fuzzy
msgid "## Language Features"
msgstr "## Caracter√≠sticas del idioma"

#: src/why-rust/modern.md:7
#, fuzzy
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Enumeraciones y coincidencia de patrones.\n"
"* Gen√©ricos.\n"
"* Sin gastos generales de FFI.\n"
"* Abstracciones de costo cero."

#: src/why-rust/modern.md:12
#, fuzzy
msgid "## Tooling"
msgstr "## Herramientas"

#: src/why-rust/modern.md:14
#, fuzzy
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* Grandes errores del compilador.\n"
"* Administrador de dependencias incorporado.\n"
"* Soporte incorporado para pruebas.\n"
"* Excelente compatibilidad con el protocolo del servidor de idiomas."

#: src/why-rust/modern.md:23
#, fuzzy
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to "
"'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct."
msgstr ""
"* Abstracciones de costo cero, similares a C++, significa que no tiene que "
"'pagar'\n"
"  para construcciones de programaci√≥n de alto nivel con memoria o CPU. Por "
"ejemplo,\n"
"  escribir un ciclo usando `for` deber√≠a dar como resultado aproximadamente "
"el mismo nivel bajo\n"
"  instrucciones como usar la construcci√≥n `.iter().fold()`."

#: src/why-rust/modern.md:28
#, fuzzy
msgid ""
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
"also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`."
msgstr ""
"* Vale la pena mencionar que las enumeraciones de Rust son 'Tipos de datos "
"algebraicos', tambi√©n\n"
"  conocidos como 'tipos de suma', que permiten que el sistema de tipos "
"exprese cosas como\n"
"  `Opci√≥n<T>` y `Resultado<T, E>`."

#: src/why-rust/modern.md:32
#, fuzzy
msgid ""
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with "
"_actionable_\n"
"  feedback, ready to copy-paste into your code."
msgstr ""
"* Recuerde a las personas que lean los errores --- muchos desarrolladores se "
"han acostumbrado a\n"
"  ignorar la salida larga del compilador. El compilador Rust es "
"significativamente m√°s\n"
"  hablador que otros compiladores. A menudo le proporcionar√° _accionable_\n"
"  comentarios, listos para copiar y pegar en su c√≥digo."

#: src/why-rust/modern.md:37
#, fuzzy
msgid ""
"* The Rust standard library is small compared to languages like Java, "
"Python,\n"
"  and Go. Rust does not come with several things you might consider standard "
"and\n"
"  essential:"
msgstr ""
"* La biblioteca est√°ndar de Rust es peque√±a en comparaci√≥n con lenguajes "
"como Java, Python,\n"
"  y ve. Rust no viene con varias cosas que podr√≠a considerar est√°ndar y\n"
"  b√°sico:"

#: src/why-rust/modern.md:41
#, fuzzy
msgid ""
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json]."
msgstr ""
"  * un generador de n√∫meros aleatorios, pero vea [rand].\n"
"  * soporte para SSL o TLS, pero consulte [rusttls].\n"
"  * soporte para JSON, pero vea [serde_json]."

#: src/why-rust/modern.md:45
#, fuzzy
msgid ""
"  The reasoning behind this is that functionality in the standard library "
"cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps "
"there\n"
"  isn't a single \"best solution\" for some of these things."
msgstr ""
"  El razonamiento detr√°s de esto es que la funcionalidad en la biblioteca "
"est√°ndar no puede\n"
"  desaparecer, por lo que tiene que ser muy estable. Para los ejemplos "
"anteriores, el Rust\n"
"  comunidad todav√≠a est√° trabajando para encontrar la mejor soluci√≥n --- y "
"quiz√°s haya\n"
"  no es una sola \"mejor soluci√≥n\" para algunas de estas cosas."

#: src/why-rust/modern.md:50
#, fuzzy
msgid ""
"  Rust comes with a built-in package manager in the form of Cargo and this "
"makes\n"
"  it trivial to download and compile third-party crates. A consequence of "
"this\n"
"  is that the standard library can be smaller."
msgstr ""
"  Rust viene con un administrador de paquetes incorporado en forma de Cargo "
"y esto hace\n"
"  es trivial descargar y compilar cajas de terceros. Una consecuencia de "
"esto\n"
"  es que la biblioteca est√°ndar puede ser m√°s peque√±a."

#: src/why-rust/modern.md:54
#, fuzzy
msgid ""
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics "
"for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"  Descubrir buenas cajas de terceros puede ser un problema. Sitios como\n"
"  <https://lib.rs/> ayude con esto permiti√©ndole comparar m√©tricas de salud "
"para\n"
"  cajas para encontrar una buena y de confianza.\n"
"  \n"
"* [rust-analyzer] es una implementaci√≥n LSP bien soportada que se utiliza en "
"las principales\n"
"  IDE y editores de texto."

#: src/why-rust/modern.md:61
#, fuzzy
msgid ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"
msgstr ""
"[rand]: https://docs.rs/rand/\n"
"[rustls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[analizador de √≥xido]: https://rust-analyzer.github.io/"

#: src/basic-syntax.md:1
#, fuzzy
msgid "# Basic Syntax"
msgstr "# Sintaxis b√°sica"

#: src/basic-syntax.md:3
#, fuzzy
msgid "Much of the Rust syntax will be familiar to you from C or C++:"
msgstr "Gran parte de la sintaxis de Rust le resultar√° familiar de C o C++:"

#: src/basic-syntax.md:5
#, fuzzy
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* "
"...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* Los bloques y √°mbitos est√°n delimitados por llaves.\n"
"* Los comentarios de l√≠nea comienzan con `//`, los comentarios de bloque "
"est√°n delimitados por `/* ...\n"
"  */`.\n"
"* Las palabras clave como `si` y `mientras` funcionan de la misma manera.\n"
"* La asignaci√≥n de variables se realiza con `=`, la comparaci√≥n se realiza "
"con `==`."

#: src/basic-syntax/scalar-types.md:1
#, fuzzy
msgid "# Scalar Types"
msgstr "# Tipos escalares"

#: src/basic-syntax/scalar-types.md:3
#, fuzzy
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | "
"`-10`, `0`, `1_000`, `123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, "
"`123`, `10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | "
"`3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                | `&str`                                     | "
"`\"foo\"`, `r#\"\\\\\"#`            |\n"
"| Unicode scalar values  | `char`                                     | "
"`'a'`, `'Œ±'`, `'‚àû'`           |\n"
"| Byte strings           | `&[u8]`                                    | "
"`b\"abc\"`, `br#\" \" \"#`         |\n"
"| Booleans               | `bool`                                     | "
"`true`, `false`               |"
msgstr ""
"| | Tipos | Literales |\n"
"|------------------------|------------------------ "
"-----------|--------------------------------------------- --|\n"
"| Enteros con signo | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, "
"`0`, `1_000`, `123i64` |\n"
"| Enteros sin signo | `u8`, `u16`, `u32`, `u64`, `u128`, `usar tama√±o` | "
"`0`, `123`, `10u16` |\n"
"| N√∫meros de coma flotante | `f32`, `f64` | `3.14`, `-10.0e20`, `2f32` |\n"
"| Cuerdas | `&str` | `\"foo\"`, `r#\"\\\\\"#` |\n"
"| Valores escalares Unicode | `char` | `'a'`, `'Œ±'`, `'‚àû'` |\n"
"| Cadenas de bytes | `&[u8]` | `b\"abc\"`, `br#\" \" \"#` |\n"
"| Booleanos | `bool` | `verdadero`, `falso` |"

#: src/basic-syntax/scalar-types.md:13
#, fuzzy
msgid "The types have widths as follows:"
msgstr "Los tipos tienen anchos de la siguiente manera:"

#: src/basic-syntax/scalar-types.md:15
#, fuzzy
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN` y `fN` tienen _N_ bits de ancho,\n"
"* `isize` y `usize` son el ancho de un puntero,\n"
"* `char` tiene 32 bits de ancho,\n"
"* `bool` tiene un ancho de 8 bits."

#: src/basic-syntax/compound-types.md:1
#, fuzzy
msgid "# Compound Types"
msgstr "# Tipos de compuestos"

#: src/basic-syntax/compound-types.md:3
#, fuzzy
msgid ""
"|        | Types                         | Literals                          "
"|\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          "
"|\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"
msgstr ""
"| | Tipos | Literales |\n"
"|--------|-------------------------------|-------- "
"---------------------------|\n"
"| Matrices | `[T; N]` | `[20, 30, 40]`, `[0; 3]` |\n"
"| tuplas | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"

#: src/basic-syntax/compound-types.md:8
#, fuzzy
msgid "Array assignment and access:"
msgstr "Asignaci√≥n de matriz y acceso:"

#: src/basic-syntax/compound-types.md:10
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:18
#, fuzzy
msgid "Tuple assignment and access:"
msgstr "Asignaci√≥n de tuplas y acceso:"

#: src/basic-syntax/compound-types.md:20
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea t: (i8, bool) = (7, verdadero);\n"
"    println!(\"1er √≠ndice: {}\", t.0);\n"
"    println!(\"Segundo √≠ndice: {}\", t.1);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:32
#, fuzzy
msgid "Arrays:"
msgstr "Matrices:"

#: src/basic-syntax/compound-types.md:34
#, fuzzy
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a "
"compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that "
"`[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types."
msgstr ""
"* Los arreglos tienen elementos del mismo tipo, `T`, y longitud, `N`, que es "
"una constante de tiempo de compilaci√≥n.\n"
"  Tenga en cuenta que la longitud de la matriz es *parte de su tipo*, lo que "
"significa que `[u8; 3]` y\n"
"  `[u8; 4]` se consideran dos tipos diferentes."

#: src/basic-syntax/compound-types.md:38
#, fuzzy
msgid "* We can use literals to assign values to arrays."
msgstr "* Podemos usar literales para asignar valores a matrices."

#: src/basic-syntax/compound-types.md:40
#, fuzzy
msgid ""
"* In the main function, the print statement asks for the debug "
"implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after "
"the\n"
"  format string."
msgstr ""
"* En la funci√≥n principal, la declaraci√≥n de impresi√≥n solicita la "
"implementaci√≥n de depuraci√≥n con el formato `?`\n"
"  par√°metro: `{}` da la salida predeterminada, `{:?}` da la salida de "
"depuraci√≥n. Nosotros\n"
"  tambi√©n podr√≠a haber usado `{a}` y `{a:?}` sin especificar el valor "
"despu√©s del\n"
"  cadena de formato."

#: src/basic-syntax/compound-types.md:45
#, fuzzy
msgid ""
"* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can "
"be easier to read."
msgstr ""
"* Agregar `#`, por ejemplo, `{a:#?}`, invoca un formato de \"impresi√≥n "
"bonita\", que puede ser m√°s f√°cil de leer."

#: src/basic-syntax/compound-types.md:47
#, fuzzy
msgid "Tuples:"
msgstr "Tuplas:"

#: src/basic-syntax/compound-types.md:49
#, fuzzy
msgid "* Like arrays, tuples have a fixed length."
msgstr "* Al igual que los arreglos, las tuplas tienen una longitud fija."

#: src/basic-syntax/compound-types.md:51
#, fuzzy
msgid "* Tuples group together values of different types into a compound type."
msgstr "* Las tuplas agrupan valores de diferentes tipos en un tipo compuesto."

#: src/basic-syntax/compound-types.md:53
#, fuzzy
msgid ""
"* Fields of a tuple can be accessed by the period and the index of the "
"value, e.g. `t.0`, `t.1`."
msgstr ""
"* Se puede acceder a los campos de una tupla por el per√≠odo y el √≠ndice del "
"valor, p. `t.0`, `t.1`."

#: src/basic-syntax/compound-types.md:55
#, fuzzy
msgid ""
"* The empty tuple `()` is also known as the \"unit type\". It is both a "
"type, and\n"
"  the only valid value of that type - that is to say both the type and its "
"value\n"
"  are expressed as `()`. It is used to indicate, for example, that a "
"function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* La tupla vac√≠a `()` tambi√©n se conoce como \"tipo de unidad\". Es a la vez "
"un tipo y\n"
"  el √∫nico valor v√°lido de ese tipo, es decir, tanto el tipo como su valor\n"
"  se expresan como `()`. Se utiliza para indicar, por ejemplo, que una "
"funci√≥n o\n"
"  expresi√≥n no tiene valor de retorno, como veremos en una diapositiva "
"futura.\n"
"    * Puede considerarlo como un \"vac√≠o\" que puede resultarle familiar de "
"otros\n"
"      lenguajes de programaci√≥n."

#: src/basic-syntax/references.md:1
#, fuzzy
msgid "# References"
msgstr "# Referencias"

#: src/basic-syntax/references.md:3
#, fuzzy
msgid "Like C++, Rust has references:"
msgstr "Como C++, Rust tiene referencias:"

#: src/basic-syntax/references.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut x: i32 = 10;\n"
"    sea ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    imprimir!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references.md:14
#, fuzzy
msgid "Some notes:"
msgstr "Algunas notas:"

#: src/basic-syntax/references.md:16
#, fuzzy
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values "
"over their lifetime."
msgstr ""
"* Debemos quitar la referencia a `ref_x` al asignarle, de forma similar a "
"los punteros de C y C++.\n"
"* Rust eliminar√° autom√°ticamente la referencia en algunos casos, en "
"particular al invocar\n"
"  m√©todos (pruebe con `ref_x.count_ones()`).\n"
"* Las referencias que se declaran como `mut` se pueden vincular a diferentes "
"valores durante su vida √∫til."

#: src/basic-syntax/references.md:21
#, fuzzy
msgid "<details>\nKey points:"
msgstr "<detalles>\nPuntos clave:"

#: src/basic-syntax/references.md:24
#, fuzzy
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let "
"ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound "
"to\n"
"  different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"* Aseg√∫rese de notar la diferencia entre `let mut ref_x: &i32` y `let "
"ref_x:\n"
"  &mut i32`. El primero representa una referencia mutable que puede "
"vincularse a\n"
"  diferentes valores, mientras que el segundo representa una referencia a un "
"valor mutable."

#: src/basic-syntax/references-dangling.md:1
#, fuzzy
msgid "# Dangling References"
msgstr "# Referencias colgantes"

#: src/basic-syntax/references-dangling.md:3
#, fuzzy
msgid "Rust will statically forbid dangling references:"
msgstr "Rust prohibir√° est√°ticamente las referencias colgantes:"

#: src/basic-syntax/references-dangling.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn principal() {\n"
"    sea ref_x: &i32;\n"
"    {\n"
"        sea x: i32 = 10;\n"
"        referencia_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"

#: src/basic-syntax/references-dangling.md:16
#, fuzzy
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* Se dice que una referencia \"toma prestado\" el valor al que se refiere.\n"
"* Rust est√° rastreando la vida √∫til de todas las referencias para garantizar "
"que vivan mucho tiempo\n"
"  suficiente.\n"
"* Hablaremos m√°s sobre los pr√©stamos cuando lleguemos a la propiedad."

#: src/basic-syntax/slices.md:1
#, fuzzy
msgid "# Slices"
msgstr "# rebanadas"

#: src/basic-syntax/slices.md:3
#, fuzzy
msgid "A slice gives you a view into a larger collection:"
msgstr "Un segmento te da una vista de una colecci√≥n m√°s grande:"

#: src/basic-syntax/slices.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"

#: src/basic-syntax/slices.md:10
#, fuzzy
msgid ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""
"    sea: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/slices.md:15
#, fuzzy
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* Las rebanadas toman prestados datos del tipo de rebanada.\n"
"* Pregunta: ¬øQu√© pasa si modificas `a[3]`?"

#: src/basic-syntax/slices.md:20
#, fuzzy
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"* Creamos una rebanada tomando prestada `a` y especificando los √≠ndices "
"inicial y final entre par√©ntesis."

#: src/basic-syntax/slices.md:22
#, fuzzy
msgid ""
"* If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"* Si el segmento comienza en el √≠ndice 0, la sintaxis de rango de Rust nos "
"permite descartar el √≠ndice inicial, lo que significa que `&a[0..a.len()]` y "
"`&a[..a.len()]` son id√©nticos .\n"
"    \n"
"* Lo mismo ocurre con el √∫ltimo √≠ndice, por lo que `&a[2..a.len()]` y "
"`&a[2..]` son id√©nticos."

#: src/basic-syntax/slices.md:26
#, fuzzy
msgid ""
"* To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"* Para crear f√°cilmente una porci√≥n de la matriz completa, podemos usar "
"`&a[..]`."

#: src/basic-syntax/slices.md:28
#, fuzzy
msgid ""
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to "
"remain 'alive' (in scope) for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, "
"but the answer is that for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read "
"the data from both `a` and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* `s` es una referencia a una porci√≥n de `i32`s. Tenga en cuenta que el tipo "
"de `s` (`&[i32]`) ya no menciona la longitud de la matriz. Esto nos permite "
"realizar c√°lculos en rebanadas de diferentes tama√±os.\n"
" \n"
"* Las rebanadas siempre toman prestadas de otro objeto. En este ejemplo, 'a' "
"tiene que permanecer 'vivo' (en el alcance) durante al menos el mismo tiempo "
"que nuestro segmento.\n"
"    \n"
"* La pregunta sobre la modificaci√≥n de `a[3]` puede generar una discusi√≥n "
"interesante, pero la respuesta es que por razones de seguridad de la "
"memoria\n"
"  no puede hacerlo a trav√©s de `a` despu√©s de crear un segmento, pero puede "
"leer los datos tanto de `a` como de `s` de forma segura.\n"
"  Se explicar√°n m√°s detalles en la secci√≥n de verificaci√≥n de pr√©stamo."

#: src/basic-syntax/string-slices.md:1
#, fuzzy
msgid "# `String` vs `str`"
msgstr "# `String` frente a `str`"

#: src/basic-syntax/string-slices.md:3
#, fuzzy
msgid "We can now understand the two string types in Rust:"
msgstr "Ahora podemos entender los dos tipos de cadenas en Rust:"

#: src/basic-syntax/string-slices.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s1: &str = \"Mundo\";\n"
"    imprimir!(\"s1: {s1}\");"

#: src/basic-syntax/string-slices.md:10
#, fuzzy
msgid ""
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""
"    let mut s2: String = String::from(\"Hola\");\n"
"    imprimir!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    imprimir!(\"s2: {s2}\");\n"
"    \n"
"    sea s3: &str = &s2[6..];\n"
"    imprimir!(\"s3: {s3}\");\n"
"}\n"
"```"

#: src/basic-syntax/string-slices.md:20
#, fuzzy
msgid "Rust terminology:"
msgstr "Terminolog√≠a de √≥xido:"

#: src/basic-syntax/string-slices.md:22
#, fuzzy
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` una referencia inmutable a un segmento de cadena.\n"
"* `String` un b√∫fer de cadena mutable."

#: src/basic-syntax/string-slices.md:27
#, fuzzy
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data \n"
"  stored in a block of memory. String literals (`‚ÄùHello‚Äù`), are stored in "
"the program‚Äôs binary."
msgstr ""
"* `&str` introduce un segmento de cadena, que es una referencia inmutable a "
"los datos de cadena codificados en UTF-8\n"
"  almacenado en un bloque de memoria. Los literales de cadena (`‚ÄùHola‚Äù`), se "
"almacenan en el binario del programa."

#: src/basic-syntax/string-slices.md:30
#, fuzzy
msgid ""
"* Rust‚Äôs `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` \n"
"  creates a new empty string, to which string data can be added using the "
"`push()` and `push_str()` methods."
msgstr ""
"* El tipo `String` de Rust es un contenedor alrededor de un vector de bytes. "
"Al igual que con `Vec<T>`, es propiedad.\n"
"    \n"
"* Al igual que con muchos otros tipos `String::from()` crea una cadena a "
"partir de una cadena literal; `Cadena::nuevo()`\n"
"  crea una nueva cadena vac√≠a, a la que se pueden agregar datos de cadena "
"usando los m√©todos `push()` y `push_str()`."

#: src/basic-syntax/string-slices.md:35
#, fuzzy
msgid ""
"* The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range "
"selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the "
"one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of "
"`std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never "
"use a small-string optimization).\n"
"    \n"
"</details>"
msgstr ""
"* La macro `formato! ()` es una forma conveniente de generar una cadena "
"propia a partir de valores din√°micos. Eso\n"
"  acepta la misma especificaci√≥n de formato que `println!()`.\n"
"    \n"
"* Puede tomar prestados segmentos `&str` de `String` a trav√©s de `&` y, "
"opcionalmente, selecci√≥n de rango.\n"
"    \n"
"* Para programadores de C++: piense en `&str` como `const char*` de C++, "
"pero el que siempre apunta\n"
"  a una cadena v√°lida en la memoria. Rust `String` es un equivalente "
"aproximado de `std::string` de C++\n"
"  (diferencia principal: solo puede contener bytes codificados en UTF-8 y "
"nunca utilizar√° una optimizaci√≥n de cadena peque√±a).\n"
"    \n"
"</detalles>"

#: src/basic-syntax/functions.md:1
#, fuzzy
msgid "# Functions"
msgstr "# Funciones"

#: src/basic-syntax/functions.md:3
#, fuzzy
msgid ""
"A Rust version of the famous "
"[FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview question:"
msgstr ""
"Una versi√≥n Rust de la famosa pregunta de la entrevista "
"[FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    fizzbuzz_to(20); // Definido a continuaci√≥n, no se necesita declaraci√≥n "
"de reenv√≠o\n"
"}"

#: src/basic-syntax/functions.md:10
#, fuzzy
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}"
msgstr ""
"fn es_divisible_por(lhs: u32, rhs: u32) -> bool {\n"
"    si derecho == 0 {\n"
"        falso retorno; // Caso de esquina, retorno anticipado\n"
"    }\n"
"    lhs % rhs == 0 // La √∫ltima expresi√≥n en un bloque es el valor de "
"retorno\n"
"}"

#: src/basic-syntax/functions.md:17
#, fuzzy
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit "
"type `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"
msgstr ""
"fn fizzbuzz(n: u32) -> () { // Sin valor devuelto significa devolver el tipo "
"de unidad `()`\n"
"    coincidir (es_divisible_por(n, 3), es_divisible_por(n, 5)) {\n"
"        (verdadero, verdadero) => println!(\"fizzbuzz\"),\n"
"        (verdadero, falso) => println!(\"efervescencia\"),\n"
"        (falso, verdadero) => println!(\"zumbido\"),\n"
"        (falso, falso) => println!(\"{n}\"),\n"
"    }\n"
"}"

#: src/basic-syntax/functions.md:26
#, fuzzy
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn fizzbuzz_to(n: u32) { // `-> ()` normalmente se omite\n"
"    para i en 1..=n {\n"
"        efervescencia(i);\n"
"    }\n"
"}\n"
"```"

#: src/basic-syntax/functions.md:35
#, fuzzy
msgid ""
"* We refer in `main` to a function written below. Neither forward "
"declarations nor headers are necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type.\n"
"* The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, "
"which causes it to include the upper bound.\n"
"* The `match` expression in `fizzbuzz()` is doing a lot of work. It is "
"expanded below to show what is happening."
msgstr ""
"* Nos referimos en `main` a una funci√≥n escrita a continuaci√≥n. No son "
"necesarias declaraciones de reenv√≠o ni encabezados.\n"
"* Los par√°metros de declaraci√≥n son seguidos por un tipo (lo contrario de "
"algunos lenguajes de programaci√≥n), luego un tipo de retorno.\n"
"* La √∫ltima expresi√≥n en el cuerpo de una funci√≥n (o cualquier bloque) se "
"convierte en el valor devuelto. Simplemente omita `;` al final de la "
"expresi√≥n.\n"
"* Algunas funciones no tienen valor de retorno y devuelven el 'tipo de "
"unidad', `()`. El compilador inferir√° esto si se omite el tipo de retorno "
"`-> ()`.\n"
"* La expresi√≥n de rango en el ciclo `for` en `fizzbuzz_to()` contiene `=n`, "
"lo que hace que incluya el l√≠mite superior.\n"
"* La expresi√≥n `match` en `fizzbuzz()` est√° haciendo mucho trabajo. Se "
"ampl√≠a a continuaci√≥n para mostrar lo que est√° sucediendo."

#: src/basic-syntax/functions.md:42
#, fuzzy
msgid "  (Type annotations added for clarity, but they can be elided.)"
msgstr ""
"  (Se agregaron anotaciones de tipo para mayor claridad, pero se pueden "
"omitir)."

#: src/basic-syntax/functions.md:44
#, fuzzy
msgid ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"
msgstr ""
"  ```oxidar, ignorar\n"
"  sea por_3: bool = es_divisible_por(n, 3);\n"
"  sea por_5: bool = es_divisible_por(n, 5);\n"
"  sea por_35: (bool, bool) = (por_3, por_5);\n"
"  emparejar por_35 {\n"
"    // ...\n"
"  ```"

#: src/basic-syntax/functions.md:52
msgid "  "
msgstr ""

#: src/basic-syntax/methods.md:1 src/methods.md:1
#, fuzzy
msgid "# Methods"
msgstr "# M√©todos"

#: src/basic-syntax/methods.md:3
#, fuzzy
msgid ""
"Rust has methods, they are simply functions that are associated with a "
"particular type. The\n"
"first argument of a method is an instance of the type it is associated with:"
msgstr ""
"Rust tiene m√©todos, son simplemente funciones que est√°n asociadas a un tipo "
"particular. √âl\n"
"El primer argumento de un m√©todo es una instancia del tipo al que est√° "
"asociado:"

#: src/basic-syntax/methods.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"estructura Rect√°ngulo {\n"
"    ancho: u32,\n"
"    altura: u32,\n"
"}"

#: src/basic-syntax/methods.md:12
#, fuzzy
msgid ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"
msgstr ""
"Rect√°ngulo impl {\n"
"    √°rea fn(&self) -> u32 {\n"
"        propio.ancho * propio.alto\n"
"    }"

#: src/basic-syntax/methods.md:17
#, fuzzy
msgid ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"
msgstr ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        auto.ancho += delta;\n"
"    }\n"
"}"

#: src/basic-syntax/methods.md:22
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let mut rect = Rectangle { ancho: 10, alto: 5 };\n"
"    println!(\"√°rea antigua: {}\", rect.area());\n"
"    rect.inc_ancho(5);\n"
"    println!(\"nueva area: {}\", rect.area());\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:30
#, fuzzy
msgid ""
"* We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"* Veremos mucho m√°s los m√©todos en el ejercicio de hoy y en la clase de "
"ma√±ana."

#: src/basic-syntax/functions-interlude.md:1
#, fuzzy
msgid "# Function Overloading"
msgstr "# Sobrecarga de funciones"

#: src/basic-syntax/functions-interlude.md:3
#, fuzzy
msgid "Overloading is not supported:"
msgstr "No se admite la sobrecarga:"

#: src/basic-syntax/functions-interlude.md:5
#, fuzzy
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Cada funci√≥n tiene una sola implementaci√≥n:\n"
"  * Siempre toma un n√∫mero fijo de par√°metros.\n"
"  * Siempre toma un solo conjunto de tipos de par√°metros.\n"
"* Los valores predeterminados no son compatibles:\n"
"  * Todos los sitios de llamadas tienen el mismo n√∫mero de argumentos.\n"
"  * Las macros a veces se utilizan como alternativa."

#: src/basic-syntax/functions-interlude.md:12
#, fuzzy
msgid "However, function parameters can be generic:"
msgstr "Sin embargo, los par√°metros de funci√≥n pueden ser gen√©ricos:"

#: src/basic-syntax/functions-interlude.md:14
#, fuzzy
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn elegir_uno<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"

#: src/basic-syntax/functions-interlude.md:19
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    println!(\"lanzamiento de moneda: {}\", pick_one(\"cara\", \"cruz\"));\n"
"    println!(\"premio en efectivo: {}\", pick_one(500, 1000));\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:27
#, fuzzy
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind "
"of limited\n"
"  polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"* Al usar gen√©ricos, `Into<T>` de la biblioteca est√°ndar puede proporcionar "
"una especie de\n"
"  polimorfismo en tipos de argumentos. Veremos m√°s detalles en un apartado "
"posterior."

#: src/basic-syntax/functions-interlude.md:30
#, fuzzy
msgid "</defails>"
msgstr "</falla>"

#: src/exercises/day-1/morning.md:1
#, fuzzy
msgid "# Day 1: Morning Exercises"
msgstr "# D√≠a 1: Ejercicios Matutinos"

#: src/exercises/day-1/morning.md:3
#, fuzzy
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "En estos ejercicios, exploraremos dos partes de Rust:"

#: src/exercises/day-1/morning.md:5
#, fuzzy
msgid "* Implicit conversions between types."
msgstr "* Conversiones impl√≠citas entre tipos."

#: src/exercises/day-1/morning.md:7
#, fuzzy
msgid "* Arrays and `for` loops."
msgstr "* Matrices y bucles `for`."

#: src/exercises/day-1/morning.md:11
#, fuzzy
msgid "A few things to consider while solving the exercises:"
msgstr "Algunas cosas a tener en cuenta al resolver los ejercicios:"

#: src/exercises/day-1/morning.md:13
#, fuzzy
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for "
"details\n"
"  on installing Rust."
msgstr ""
"* Use una instalaci√≥n local de Rust, si es posible. De esta forma puedes "
"conseguir\n"
"  autocompletado en su editor. Consulte la p√°gina sobre [Uso de la carga] "
"para obtener m√°s informaci√≥n.\n"
"  en la instalaci√≥n de Rust."

#: src/exercises/day-1/morning.md:17
#, fuzzy
msgid "* Alternatively, use the Rust Playground."
msgstr "* Alternativamente, use Rust Playground."

#: src/exercises/day-1/morning.md:19
#, fuzzy
msgid ""
"The code snippets are not editable on purpose: the inline code snippets "
"lose\n"
"their state if you navigate away from the page."
msgstr ""
"Los fragmentos de c√≥digo no se pueden editar a prop√≥sito: los fragmentos de "
"c√≥digo en l√≠nea pierden\n"
"su estado si navega fuera de la p√°gina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
#, fuzzy
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "Despu√©s de ver los ejercicios, puede ver las [soluciones] provistas."

#: src/exercises/day-1/morning.md:24 src/exercises/day-2/morning.md:13
#: src/exercises/day-3/morning.md:9 src/exercises/day-4/morning.md:14
#, fuzzy
msgid "[solutions]: solutions-morning.md"
msgstr "[soluciones]: soluciones-ma√±ana.md"

#: src/exercises/day-1/morning.md:26
#, fuzzy
msgid "[Using Cargo]: ../../cargo.md"
msgstr "[Usando Cargo]: ../../cargo.md"

#: src/exercises/day-1/implicit-conversions.md:1
#, fuzzy
msgid "# Implicit Conversions"
msgstr "# Conversiones impl√≠citas"

#: src/exercises/day-1/implicit-conversions.md:3
#, fuzzy
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust no aplicar√° autom√°ticamente _conversiones impl√≠citas_ entre tipos ([a "
"diferencia de\n"
"C++][3]). Puedes ver esto en un programa como este:"

#: src/exercises/day-1/implicit-conversions.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn multiplicar(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"

#: src/exercises/day-1/implicit-conversions.md:11
#, fuzzy
msgid ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"
msgstr ""
"fn principal() {\n"
"    sea x: i8 = 15;\n"
"    sea y: i16 = 1000;"

#: src/exercises/day-1/implicit-conversions.md:15
#, fuzzy
msgid ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""
"    println!(\"{x} * {y} = {}\", multiplicar(x, y));\n"
"}\n"
"```"

#: src/exercises/day-1/implicit-conversions.md:19
#, fuzzy
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single "
"`from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted "
"into\n"
"another type."
msgstr ""
"Todos los tipos enteros de Rust implementan [`From<T>`][1] y [`Into<T>`][2]\n"
"rasgos que nos permitan convertir entre ellos. El rasgo `From<T>` tiene un "
"solo `from()`\n"
"y de manera similar, el rasgo `Into<T>` tiene un √∫nico m√©todo `into()`.\n"
"La implementaci√≥n de estos rasgos es la forma en que un tipo expresa que se "
"puede convertir en\n"
"otro tipo."

#: src/exercises/day-1/implicit-conversions.md:25
#, fuzzy
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"La biblioteca est√°ndar tiene una implementaci√≥n de `From<i8> para i16`, lo "
"que significa\n"
"que podemos convertir una variable `x` de tipo `i8` a `i16` llamando\n"
"`i16::desde(x)`. O, m√°s simple, con `x.into()`, porque `From<i8> for i16`\n"
"La implementaci√≥n crea autom√°ticamente una implementaci√≥n de `Into<i16> para "
"i8`."

#: src/exercises/day-1/implicit-conversions.md:30
#, fuzzy
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is\n"
"sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"Lo mismo se aplica a sus propias implementaciones `From` para sus propios "
"tipos, por lo que es\n"
"suficiente para implementar solo 'From' para obtener una implementaci√≥n "
"'Into' respectiva autom√°ticamente."

#: src/exercises/day-1/implicit-conversions.md:33
#, fuzzy
msgid "1. Execute the above program and look at the compiler error."
msgstr "1. Ejecute el programa anterior y observe el error del compilador."

#: src/exercises/day-1/implicit-conversions.md:35
#, fuzzy
msgid "2. Update the code above to use `into()` to do the conversion."
msgstr ""
"2. Actualice el c√≥digo anterior para usar `into()` para realizar la "
"conversi√≥n."

#: src/exercises/day-1/implicit-conversions.md:37
#, fuzzy
msgid ""
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented "
"for\n"
"   the pairs you check."
msgstr ""
"3. Cambie los tipos de `x` e `y` a otras cosas (como `f32`, `bool`,\n"
"   `i128`) para ver qu√© tipos puede convertir a qu√© otros tipos. Intentar\n"
"   convertir tipos peque√±os en tipos grandes y viceversa. Comprobar el\n"
"   [documentaci√≥n de biblioteca est√°ndar][1] para ver si `From<T>` est√° "
"implementado para\n"
"   los pares que revisas."

#: src/exercises/day-1/implicit-conversions.md:43
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"

#: src/exercises/day-1/for-loops.md:1
#, fuzzy
msgid "# Arrays and `for` Loops"
msgstr "# Matrices y bucles `for`"

#: src/exercises/day-1/for-loops.md:3
#, fuzzy
msgid "We saw that an array can be declared like this:"
msgstr "Vimos que una matriz se puede declarar as√≠:"

#: src/exercises/day-1/for-loops.md:5
#, fuzzy
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""
"```herrumbre\n"
"let matriz = [10, 20, 30];\n"
"```"

#: src/exercises/day-1/for-loops.md:9
#, fuzzy
msgid ""
"You can print such an array by asking for its debug representation with "
"`{:?}`:"
msgstr ""
"Puede imprimir una matriz de este tipo solicitando su representaci√≥n de "
"depuraci√≥n con `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let matriz = [10, 20, 30];\n"
"    println!(\"matriz: {matriz:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:18
#, fuzzy
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust te permite iterar cosas como arreglos y rangos usando `for`\n"
"palabra clave:"

#: src/exercises/day-1/for-loops.md:21
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let matriz = [10, 20, 30];\n"
"    print!(\"Iterando sobre el arreglo:\");\n"
"    para n en matriz {\n"
"        imprimir!(\" {n}\");\n"
"    }\n"
"    imprimir!();"

#: src/exercises/day-1/for-loops.md:30
#, fuzzy
msgid ""
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"    print!(\"Iterando sobre el rango:\");\n"
"    para i en 0..3 {\n"
"        imprimir!(\" {}\", matriz[i]);\n"
"    }\n"
"    imprimir!();\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:38
#, fuzzy
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and\n"
"a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"Use lo anterior para escribir una funci√≥n `pretty_print` que imprima una "
"matriz y\n"
"una funci√≥n `transponer` que transpondr√° una matriz (convertir filas en "
"columnas):"

#: src/exercises/day-1/for-loops.md:41
#, fuzzy
msgid ""
"```bob\n"
"           ‚éõ‚é°1 2 3‚é§‚éû      ‚é°1 4 7‚é§\n"
"\"transpose\"‚éú‚é¢4 5 6‚é•‚éü  \"==\"‚é¢2 5 8‚é•\n"
"           ‚éù‚é£7 8 9‚é¶‚é†      ‚é£3 6 9‚é¶\n"
"```"
msgstr ""
"``` bob\n"
"           ‚éõ‚é°1 2 3‚é§‚éû ‚é°1 4 7‚é§\n"
"\"transponer\"‚éú‚é¢4 5 6‚é•‚éü \"==\"‚é¢2 5 8‚é•\n"
"           ‚éù‚é£7 8 9‚é¶‚é† ‚é£3 6 9‚é¶\n"
"```"

#: src/exercises/day-1/for-loops.md:47
#, fuzzy
msgid "Hard-code both functions to operate on 3 √ó 3 matrices."
msgstr "Codifique ambas funciones para operar en matrices de 3 √ó 3."

#: src/exercises/day-1/for-loops.md:49
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Copie el c√≥digo siguiente en <https://play.rust-lang.org/> e implemente el\n"
"funciones:"

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20
#: src/exercises/day-2/health-statistics.md:13
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```herrumbre, deber√≠a_p√°nico\n"
"// TODO: elimine esto cuando haya terminado con su implementaci√≥n.\n"
"#![permitir(variables_no_usadas, c√≥digo_muerto)]"

#: src/exercises/day-1/for-loops.md:56
#, fuzzy
msgid ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn transpose(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    sin implementar!()\n"
"}"

#: src/exercises/day-1/for-loops.md:60
#, fuzzy
msgid ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn pretty_print(matriz: &[[i32; 3]; 3]) {\n"
"    sin implementar!()\n"
"}"

#: src/exercises/day-1/for-loops.md:64
#, fuzzy
msgid ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""
"fn principal() {\n"
"    sea matriz = [\n"
"        [101, 102, 103], // <-- el comentario hace que rustfmt agregue una "
"nueva l√≠nea\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"

#: src/exercises/day-1/for-loops.md:71
#: src/exercises/day-1/solutions-morning.md:70
#, fuzzy
msgid "    println!(\"matrix:\");\n    pretty_print(&matrix);"
msgstr "    println!(\"matriz:\");\n    bonita_impresi√≥n(&matriz);"

#: src/exercises/day-1/for-loops.md:74
#, fuzzy
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"    let transpuesto = transponer (matriz);\n"
"    println!(\"transpuesto:\");\n"
"    pretty_print(&transpuesto);\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:80
#, fuzzy
msgid "## Bonus Question"
msgstr "## Pregunta extra"

#: src/exercises/day-1/for-loops.md:82
#, fuzzy
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 √ó 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"¬øPodr√≠a usar segmentos `&[i32]` en lugar de matrices codificadas de 3 √ó 3 "
"para su\n"
"argumento y tipos de retorno? Algo as√≠ como `&[&[i32]]` para un "
"bidimensional\n"
"rebanada de rebanadas. ¬øPor qu√© o por qu√© no?"

#: src/exercises/day-1/for-loops.md:87
#, fuzzy
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
"quality\n"
"implementation."
msgstr ""
"Vea la [caja `ndarray`](https://docs.rs/ndarray/) para una calidad de "
"producci√≥n\n"
"implementaci√≥n."

#: src/exercises/day-1/for-loops.md:92
#, fuzzy
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"La soluci√≥n y la respuesta a la secci√≥n de bonificaci√≥n est√°n disponibles en "
"el\n"
"Secci√≥n [Soluci√≥n](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
#, fuzzy
msgid "# Variables"
msgstr "# Variables"

#: src/basic-syntax/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by\n"
"default:"
msgstr ""
"Rust proporciona seguridad de tipos a trav√©s de tipos est√°ticos. Los enlaces "
"de variables son inmutables por\n"
"por defecto:"

#: src/basic-syntax/variables.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea x: i32 = 10;\n"
"    imprimir!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/variables.md:17
#, fuzzy
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the type progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the "
"function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"* Debido a la inferencia de tipo, el `i32` es opcional. Gradualmente "
"mostraremos los tipos cada vez menos a medida que avanza el tipo.\n"
"* Tenga en cuenta que dado que `println!` es una macro, `x` no se mueve, "
"incluso usando la funci√≥n como la sintaxis de `println! (\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
#, fuzzy
msgid "# Type Inference"
msgstr "# Tipo de inferencia"

#: src/basic-syntax/type-inference.md:3
#, fuzzy
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust ver√° c√≥mo se _utiliza_ la variable para determinar el tipo:"

#: src/basic-syntax/type-inference.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn toma_u32(x: u32) {\n"
"    imprimir!(\"u32: {x}\");\n"
"}"

#: src/basic-syntax/type-inference.md:10
#, fuzzy
msgid ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"
msgstr ""
"fn toma_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"

#: src/basic-syntax/type-inference.md:14
#, fuzzy
msgid ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"
msgstr ""
"fn principal() {\n"
"    sea x = 10;\n"
"    sea y = 20;"

#: src/basic-syntax/type-inference.md:18
#, fuzzy
msgid ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""
"    toma_u32(x);\n"
"    toma_i8(y);\n"
"    // toma_u32(y);\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:26
#, fuzzy
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages.\n"
"    \n"
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical "
"to the explicit declaration of a type.\n"
"The compiler does the job for us and helps us to write a more concise code."
msgstr ""
"Esta diapositiva demuestra c√≥mo el compilador de Rust infiere tipos en "
"funci√≥n de las restricciones dadas por declaraciones y usos de variables.\n"
"    \n"
"Es muy importante recalcar que las variables declaradas as√≠ no son de alg√∫n "
"tipo de din√°mica \"cualquier tipo\" que pueda\n"
"mantener ning√∫n dato. El c√≥digo m√°quina generado por tal declaraci√≥n es "
"id√©ntico a la declaraci√≥n expl√≠cita de un tipo.\n"
"El compilador hace el trabajo por nosotros y nos ayuda a escribir un c√≥digo "
"m√°s conciso."

#: src/basic-syntax/type-inference.md:32
#, fuzzy
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"El siguiente c√≥digo le dice al compilador que copie en un determinado "
"contenedor gen√©rico sin que el c√≥digo especifique expl√≠citamente el tipo "
"contenido, usando `_` como marcador de posici√≥n:"

#: src/basic-syntax/type-inference.md:34
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, falso));\n"
"    v.push((20, verdadero));\n"
"    println!(\"v: {v:?}\");"

#: src/basic-syntax/type-inference.md:41
#, fuzzy
msgid ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""
"    let vv = v.iter().collect::<std::colecciones::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:46
#, fuzzy
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) "
"relies on `FromIterator`, which "
"[`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) "
"se basa en `FromIterator`, que [`HashSet`](https:/ "
"/doc.rust-lang.org/std/iter/trait.FromIterator.html) implementa."

#: src/basic-syntax/static-and-const.md:1
#, fuzzy
msgid "# Static and Constant Variables"
msgstr "# Variables Est√°ticas y Constantes"

#: src/basic-syntax/static-and-const.md:3
#, fuzzy
msgid "Global state is managed with static and constant variables."
msgstr "El estado global se gestiona con variables est√°ticas y constantes."

#: src/basic-syntax/static-and-const.md:5
#, fuzzy
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
#, fuzzy
msgid "You can declare compile-time constants:"
msgstr "Puede declarar constantes de tiempo de compilaci√≥n:"

#: src/basic-syntax/static-and-const.md:9
#, fuzzy
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"
msgstr ""
"```herrumbre, editable\n"
"const DIGESTI√ìN_TAMA√ëO: tama√±o de uso = 3;\n"
"const CERO: Opci√≥n<u8> = Algunos(42);"

#: src/basic-syntax/static-and-const.md:13
#, fuzzy
msgid ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % "
"DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"
msgstr ""
"fn computar_digest(texto: &str) -> [u8; DIGESTI√ìN_TAMA√ëO] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGESTI√ìN_TAMA√ëO];\n"
"    para (idx, &b) en texto.as_bytes().iter().enumerate() {\n"
"        resumen[idx % DIGESTI√ìN_TAMA√ëO] = resumen[idx % "
"DIGESTI√ìN_TAMA√ëO].wrapping_add(b);\n"
"    }\n"
"    digerir\n"
"}"

#: src/basic-syntax/static-and-const.md:21
#, fuzzy
msgid ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let digest = computar_digest(\"Hola\");\n"
"    println!(\"Resumen: {resumen:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:27
#, fuzzy
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr ""
"De acuerdo con el [Libro RFC de Rust][1], estos se insertan en el momento "
"del uso."

#: src/basic-syntax/static-and-const.md:29
#, fuzzy
msgid "## `static`"
msgstr "## `est√°tico`"

#: src/basic-syntax/static-and-const.md:31
#, fuzzy
msgid "You can also declare static variables:"
msgstr "Tambi√©n puede declarar variables est√°ticas:"

#: src/basic-syntax/static-and-const.md:33
#, fuzzy
msgid "```rust,editable\nstatic BANNER: &str = \"Welcome to RustOS 3.14\";"
msgstr ""
"```herrumbre, editable\n"
"BANDERA est√°tica: &str = \"Bienvenido a RustOS 3.14\";"

#: src/basic-syntax/static-and-const.md:36
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    println!(\"{BANDERA}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:41
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have "
"an actual associated memory location.  This is useful for unsafe and "
"embedded code, and the variable lives through the entirety of the program "
"execution."
msgstr ""
"Como se indica en el [Libro RFC de Rust][1], estos no est√°n alineados al "
"usarse y tienen una ubicaci√≥n de memoria asociada real. Esto es √∫til para "
"c√≥digo no seguro e incrustado, y la variable vive durante toda la ejecuci√≥n "
"del programa."

#: src/basic-syntax/static-and-const.md:44
#, fuzzy
msgid ""
"We will look at mutating static data in the [chapter on Unsafe "
"Rust](../unsafe.md)."
msgstr ""
"Veremos la mutaci√≥n de datos est√°ticos en el [cap√≠tulo sobre Unsafe "
"Rust](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
#, fuzzy
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++.\n"
"* It isn't super common that one would need a runtime evaluated constant, "
"but it is helpful and safer than using a static."
msgstr ""
"* Mencione que `const` se comporta sem√°nticamente similar a `constexpr` de "
"C++.\n"
"* `static`, por otro lado, es mucho m√°s similar a una `const` o variable "
"global mutable en C++.\n"
"* No es muy com√∫n que uno necesite una constante evaluada en tiempo de "
"ejecuci√≥n, pero es √∫til y m√°s seguro que usar una est√°tica."

#: src/basic-syntax/static-and-const.md:54
#, fuzzy
msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
msgstr "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"

#: src/basic-syntax/scopes-shadowing.md:1
#, fuzzy
msgid "# Scopes and Shadowing"
msgstr "# √Åmbitos y sombreado"

#: src/basic-syntax/scopes-shadowing.md:3
#, fuzzy
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the\n"
"same scope:"
msgstr ""
"Puede sombrear variables, tanto las de los √°mbitos externos como las "
"variables del\n"
"mismo alcance:"

#: src/basic-syntax/scopes-shadowing.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea a = 10;\n"
"    println!(\"antes: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:11
#, fuzzy
msgid ""
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");"
msgstr ""
"    {\n"
"        sea a = \"hola\";\n"
"        println!(\"alcance interno: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:15
#, fuzzy
msgid ""
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }"
msgstr ""
"        sea a = verdadero;\n"
"        println!(\"sombreado en el √°mbito interno: {a}\");\n"
"    }"

#: src/basic-syntax/scopes-shadowing.md:19
#, fuzzy
msgid ""
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"despues de: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
#, fuzzy
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to "
"values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"* Definici√≥n: El sombreado es diferente de la mutaci√≥n, porque despu√©s del "
"sombreado, las ubicaciones de memoria de ambas variables existen al mismo "
"tiempo. Ambos est√°n disponibles con el mismo nombre, dependiendo de d√≥nde lo "
"use en el c√≥digo.\n"
"* Una variable de sombreado puede tener un tipo diferente.\n"
"* El sombreado parece oscuro al principio, pero es conveniente para "
"conservar los valores despu√©s de `.unwrap()`.\n"
"* El siguiente c√≥digo demuestra por qu√© el compilador no puede simplemente "
"reutilizar las ubicaciones de memoria cuando oculta una variable inmutable "
"en un √°mbito, incluso si el tipo no cambia."

#: src/basic-syntax/scopes-shadowing.md:30
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea a = 1;\n"
"    sea b = &a;\n"
"    sea a = a + 1;\n"
"    imprimir!(\"{a} {b}\");\n"
"}\n"
"```"

#: src/memory-management.md:1
#, fuzzy
msgid "# Memory Management"
msgstr "# Gesti√≥n de la memoria"

#: src/memory-management.md:3
#, fuzzy
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradicionalmente, los idiomas se han dividido en dos grandes categor√≠as:"

#: src/memory-management.md:5
#, fuzzy
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"* Control total a trav√©s de la gesti√≥n manual de la memoria: C, C++, Pascal, "
"...\n"
"* Seguridad total a trav√©s de la gesti√≥n autom√°tica de la memoria en tiempo "
"de ejecuci√≥n: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
#, fuzzy
msgid "Rust offers a new mix:"
msgstr "Rust ofrece una nueva mezcla:"

#: src/memory-management.md:10
#, fuzzy
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Control total *y* seguridad a trav√©s de la aplicaci√≥n del tiempo de "
"compilaci√≥n de la memoria correcta\n"
"> gesti√≥n."

#: src/memory-management.md:13
#, fuzzy
msgid "It does this with an explicit ownership concept."
msgstr "Lo hace con un concepto de propiedad expl√≠cito."

#: src/memory-management.md:15
#, fuzzy
msgid "First, let's refresh how memory management works."
msgstr "Primero, actualicemos c√≥mo funciona la administraci√≥n de memoria."

#: src/memory-management/stack-vs-heap.md:1
#, fuzzy
msgid "# The Stack vs The Heap"
msgstr "# La pila vs el mont√≥n"

#: src/memory-management/stack-vs-heap.md:3
#, fuzzy
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality."
msgstr ""
"* Pila: √Årea continua de memoria para variables locales.\n"
"  * Los valores tienen tama√±os fijos conocidos en tiempo de compilaci√≥n.\n"
"  * Extremadamente r√°pido: simplemente mueva un puntero de pila.\n"
"  * F√°cil de administrar: sigue las llamadas de funci√≥n.\n"
"  * Gran memoria localidad."

#: src/memory-management/stack-vs-heap.md:9
#, fuzzy
msgid ""
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Mont√≥n: almacenamiento de valores fuera de las llamadas a funciones.\n"
"  * Los valores tienen tama√±os din√°micos determinados en tiempo de "
"ejecuci√≥n.\n"
"  * Ligeramente m√°s lento que la pila: se necesita algo de contabilidad.\n"
"  * No hay garant√≠a de localidad de memoria."

#: src/memory-management/stack.md:1
#, fuzzy
msgid "# Stack Memory"
msgstr "# memoria de pila"

#: src/memory-management/stack.md:3
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically "
"sized\n"
"data on the heap:"
msgstr ""
"La creaci√≥n de una `String` coloca datos de tama√±o fijo en la pila y de "
"tama√±o din√°mico\n"
"datos en el mont√≥n:"

#: src/memory-management/stack.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s1 = String::from(\"Hola\");\n"
"}\n"
"```"

#: src/memory-management/stack.md:12
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - -.\n"
": : : :\n"
": s1 : : :\n"
": +-----------+-------+ : : +----+----+----+----+----+ :\n"
": | ptr | o---+---+-----+-->| H | mi | yo | yo | o | :\n"
": | Len | 5 | : : +----+----+----+----+----+ :\n"
": | capacidad | 5 | : : :\n"
": +-----------+-------+ : : :\n"
": : `- - - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/stack.md:28
#, fuzzy
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"* Mencione que un 'String' est√° respaldado por un 'Vec', por lo que tiene "
"una capacidad y longitud y puede crecer si es mutable a trav√©s de la "
"reasignaci√≥n en el mont√≥n."

#: src/memory-management/stack.md:30
#, fuzzy
msgid ""
"* If students ask about it, you can mention that the underlying memory is "
"heap allocated using the [System Allocator] and custom allocators can be "
"implemented using the [Allocator API]"
msgstr ""
"* Si los estudiantes preguntan al respecto, puede mencionar que la memoria "
"subyacente se asigna mediante el [Asignador del sistema] y los asignadores "
"personalizados se pueden implementar mediante la [API del asignador]"

#: src/memory-management/stack.md:34
#, fuzzy
msgid ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
msgstr ""
"[Asignador del sistema]: "
"https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[API del asignador]: https://doc.rust-lang.org/std/alloc/index.html"

#: src/memory-management/manual.md:1
#, fuzzy
msgid "# Manual Memory Management"
msgstr "# Gesti√≥n de memoria manual"

#: src/memory-management/manual.md:3
#, fuzzy
msgid "You allocate and deallocate heap memory yourself."
msgstr "Usted mismo asigna y desasigna la memoria del mont√≥n."

#: src/memory-management/manual.md:5
#, fuzzy
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Si no se hace con cuidado, esto puede provocar bloqueos, errores, "
"vulnerabilidades de seguridad y p√©rdidas de memoria."

#: src/memory-management/manual.md:7
#, fuzzy
msgid "## C Example"
msgstr "## C Ejemplo"

#: src/memory-management/manual.md:9
#, fuzzy
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Debe llamar a `free` en cada puntero que asigne con `malloc`:"

#: src/memory-management/manual.md:11
#, fuzzy
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"foo vac√≠o (tama√±o_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... mucho c√≥digo\n"
"    //\n"
"    libre (matriz_int);\n"
"}\n"
"```"

#: src/memory-management/manual.md:21
#, fuzzy
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"La memoria se pierde si la funci√≥n regresa temprano entre `malloc` y `free`: "
"el\n"
"el puntero se pierde y no podemos desasignar la memoria."

#: src/memory-management/scope-based.md:1
#, fuzzy
msgid "# Scope-Based Memory Management"
msgstr "# Gesti√≥n de memoria basada en el alcance"

#: src/memory-management/scope-based.md:3
#, fuzzy
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr ""
"Los constructores y destructores te permiten engancharte a la vida √∫til de "
"un objeto."

#: src/memory-management/scope-based.md:5
#, fuzzy
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception "
"is\n"
"raised."
msgstr ""
"Al envolver un puntero en un objeto, puede liberar memoria cuando el objeto "
"es\n"
"destruido. El compilador garantiza que esto suceda, incluso si se produce "
"una excepci√≥n.\n"
"aument√≥."

#: src/memory-management/scope-based.md:9
#, fuzzy
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives\n"
"you smart pointers."
msgstr ""
"Esto a menudo se llama _adquisici√≥n de recursos es inicializaci√≥n_ (RAII) y "
"da\n"
"punteros inteligentes."

#: src/memory-management/scope-based.md:12
#, fuzzy
msgid "## C++ Example"
msgstr "## Ejemplo de C++"

#: src/memory-management/scope-based.md:14
#, fuzzy
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Persona> persona) {\n"
"  std::cout << \"Hola \" << persona->nombre << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
#, fuzzy
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* El objeto `std::unique_ptr` se asigna en la pila y apunta a\n"
"  memoria asignada en el mont√≥n.\n"
"* Al final de `say_hello`, se ejecutar√° el destructor `std::unique_ptr`.\n"
"* El destructor libera el objeto `Persona` al que apunta."

#: src/memory-management/scope-based.md:25
#, fuzzy
msgid "Special move constructors are used when passing ownership to a function:"
msgstr ""
"Los constructores de movimientos especiales se usan cuando se pasa la "
"propiedad a una funci√≥n:"

#: src/memory-management/scope-based.md:27
#, fuzzy
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""
"```c++\n"
"std::unique_ptr<Persona> persona = find_person(\"Carla\");\n"
"say_hello(std::mover(persona));\n"
"```"

#: src/memory-management/garbage-collection.md:1
#, fuzzy
msgid "# Automatic Memory Management"
msgstr "# Gesti√≥n autom√°tica de memoria"

#: src/memory-management/garbage-collection.md:3
#, fuzzy
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory\n"
"management:"
msgstr ""
"Una alternativa a la gesti√≥n de memoria manual y basada en el √°mbito es la "
"memoria autom√°tica.\n"
"administraci√≥n:"

#: src/memory-management/garbage-collection.md:6
#, fuzzy
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"* El programador nunca asigna o desasigna memoria expl√≠citamente.\n"
"* Un recolector de basura encuentra memoria no utilizada y la desasigna para "
"el programador."

#: src/memory-management/garbage-collection.md:9
#, fuzzy
msgid "## Java Example"
msgstr "## Ejemplo Java"

#: src/memory-management/garbage-collection.md:11
#, fuzzy
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "El objeto `persona` no se desasigna despu√©s de que `sayHello` devuelve:"

#: src/memory-management/garbage-collection.md:13
#, fuzzy
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void decirHola(Persona persona) {\n"
"  System.out.println(\"Hola \" + persona.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
#, fuzzy
msgid "# Memory Management in Rust"
msgstr "# Gesti√≥n de memoria en Rust"

#: src/memory-management/rust.md:3
#, fuzzy
msgid "Memory management in Rust is a mix:"
msgstr "La gesti√≥n de la memoria en Rust es una combinaci√≥n:"

#: src/memory-management/rust.md:5
#, fuzzy
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you "
"choose, can be a single unique pointer, reference counted, or atomically "
"reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"* Seguro y correcto como Java, pero sin un recolector de basura.\n"
"* Seg√∫n la abstracci√≥n (o combinaci√≥n de abstracciones) que elija, puede ser "
"un solo puntero √∫nico, una referencia contada o una referencia at√≥mica "
"contada.\n"
"* Basado en el alcance como C ++, pero el compilador impone una adherencia "
"total.\n"
"* Un usuario de Rust puede elegir la abstracci√≥n correcta para la situaci√≥n, "
"algunos incluso no tienen costo en tiempo de ejecuci√≥n como C."

#: src/memory-management/rust.md:10
#, fuzzy
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "Logra esto modelando _propiedad_ expl√≠citamente."

#: src/memory-management/rust.md:14
#, fuzzy
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box], [Vec], [Rc], or [Arc]. These "
"encapsulate ownership and memory allocation via various means, and prevent "
"the potential errors in C."
msgstr ""
"* Si se le pregunta c√≥mo en este punto, puede mencionar que en Rust esto "
"generalmente se maneja con tipos de contenedores RAII como [Box], [Vec], "
"[Rc] o [Arc]. Estos encapsulan la propiedad y la asignaci√≥n de memoria a "
"trav√©s de varios medios y evitan los posibles errores en C."

#: src/memory-management/rust.md:16
#, fuzzy
msgid ""
"* You may be asked about destructors here, the [Drop] trait is the Rust "
"equivalent."
msgstr ""
"* Es posible que se le pregunte acerca de los destructores aqu√≠, el rasgo "
"[Drop] es el equivalente de Rust."

#: src/memory-management/rust.md:20
#, fuzzy
msgid ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""
"[Cuadro]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Ver]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arco]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Soltar]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#: src/memory-management/comparison.md:1
#, fuzzy
msgid "# Comparison"
msgstr "# Comparaci√≥n"

#: src/memory-management/comparison.md:3
#, fuzzy
msgid "Here is a rough comparison of the memory management techniques."
msgstr ""
"Aqu√≠ hay una comparaci√≥n aproximada de las t√©cnicas de administraci√≥n de "
"memoria."

#: src/memory-management/comparison.md:5
#, fuzzy
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Ventajas de las diferentes t√©cnicas de gesti√≥n de la memoria"

#: src/memory-management/comparison.md:7
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Manual como C:\n"
"  * Sin sobrecarga de tiempo de ejecuci√≥n.\n"
"* Autom√°tico como Java:\n"
"  * Completamente automatico.\n"
"  * Seguro y correcto.\n"
"* Basado en el alcance como C++:\n"
"  * Parcialmente autom√°tico.\n"
"  * Sin sobrecarga de tiempo de ejecuci√≥n.\n"
"* Basado en el alcance aplicado por el compilador como Rust:\n"
"  * Aplicado por el compilador.\n"
"  * Sin sobrecarga de tiempo de ejecuci√≥n.\n"
"  * Seguro y correcto."

#: src/memory-management/comparison.md:20
#, fuzzy
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Contras de diferentes t√©cnicas de gesti√≥n de memoria"

#: src/memory-management/comparison.md:22
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Manual como C:\n"
"  * Uso despu√©s de libre.\n"
"  * Dobles libres.\n"
"  * P√©rdidas de memoria.\n"
"* Autom√°tico como Java:\n"
"  * Pausa en la recolecci√≥n de basura.\n"
"  * Retrasos del destructor.\n"
"* Basado en el alcance como C++:\n"
"  * Complejo, opt-in por programador.\n"
"  * Potencial de uso despu√©s de libre.\n"
"* Reforzado por el compilador y basado en el alcance como Rust:\n"
"  * Cierta complejidad inicial.\n"
"  * Puede rechazar programas v√°lidos."

#: src/ownership.md:1
#, fuzzy
msgid "# Ownership"
msgstr "# Propiedad"

#: src/ownership.md:3
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to\n"
"use a variable outside its scope:"
msgstr ""
"Todos los enlaces de variables tienen un _√°mbito_ donde son v√°lidos y es un "
"error\n"
"use una variable fuera de su alcance:"

#: src/ownership.md:6
#, fuzzy
msgid "```rust,editable,compile_fail\nstruct Point(i32, i32);"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"punto de estructura (i32, i32);"

#: src/ownership.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    {\n"
"        sea p = Punto(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"

#: src/ownership.md:18
#, fuzzy
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* Al final del alcance, la variable se _cae_ y los datos se liberan.\n"
"* Un destructor puede correr aqu√≠ para liberar recursos.\n"
"* Decimos que la variable _posee_ el valor."

#: src/ownership/move-semantics.md:1
#, fuzzy
msgid "# Move Semantics"
msgstr "# Mover sem√°ntica"

#: src/ownership/move-semantics.md:3
#, fuzzy
msgid "An assignment will transfer ownership between variables:"
msgstr "Una asignaci√≥n transferir√° la propiedad entre las variables:"

#: src/ownership/move-semantics.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s1: String = String::from(\"¬°Hola!\");\n"
"    sea s2: Cadena = s1;\n"
"    imprimir!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
#, fuzzy
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* La asignaci√≥n de `s1` a `s2` transfiere la propiedad.\n"
"* Los datos fueron _movidos_ de `s1` y `s1` ya no es accesible.\n"
"* Cuando `s1` sale del alcance, no pasa nada: no tiene propiedad.\n"
"* Cuando `s2` queda fuera del alcance, los datos de la cadena se liberan.\n"
"* Siempre hay _exactamente_ un enlace de variable que posee un valor."

#: src/ownership/move-semantics.md:22
#, fuzzy
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"* Mencione que esto es lo opuesto a los valores predeterminados en C++, que "
"copia por valor a menos que use `std::move` (¬°y el constructor de movimiento "
"est√° definido!)."

#: src/ownership/move-semantics.md:24
#, fuzzy
msgid "* In Rust, you clones are explicit (by using `clone`)."
msgstr "* En Rust, tus clones son expl√≠citos (usando `clone`)."

#: src/ownership/moved-strings-rust.md:1
#, fuzzy
msgid "# Moved Strings in Rust"
msgstr "# Cuerdas movidas en Rust"

#: src/ownership/moved-strings-rust.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    sea s2: Cadena = s1;\n"
"}\n"
"```"

#: src/ownership/moved-strings-rust.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* Los datos del mont√≥n de `s1` se reutilizan para `s2`.\n"
"* Cuando `s1` sale del alcance, no pasa nada (se ha movido)."

#: src/ownership/moved-strings-rust.md:13
#, fuzzy
msgid "Before move to `s2`:"
msgstr "Antes de pasar a `s2`:"

#: src/ownership/moved-strings-rust.md:15
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - - - - -.\n"
": : : :\n"
": s1 : : :\n"
": +-----------+-------+ : : +----+----+----+----+ :\n"
": | ptr | o---+---+-----+-->| R | tu | s | t | :\n"
": | Len | 4 | : : +----+----+----+----+ :\n"
": | capacidad | 4 | : : :\n"
": +-----------+-------+ : : :\n"
": : `- - - - - - - - - - - - - -'\n"
": :\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moved-strings-rust.md:30
#, fuzzy
msgid "After move to `s2`:"
msgstr "Despu√©s de pasar a `s2`:"

#: src/ownership/moved-strings-rust.md:32
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - - - - -.\n"
": : : :\n"
": s1 \"(inaccesible)\" : : :\n"
": +-----------+-------+ : : +----+----+----+----+ :\n"
": | ptr | o---+---+--+--+-->| R | tu | s | t | :\n"
": | Len | 4 | : | : +----+----+----+----+ :\n"
": | capacidad | 4 | : | : :\n"
": +----------+-------+ : | : :\n"
": : | `- - - - - - - - - - - - - - -'\n"
": s2 : |\n"
": +----------+-------+ : |\n"
": | ptr | o---+---+--'\n"
": | Len | 4 | :\n"
": | capacidad | 4 | :\n"
": +-----------+-------+ :\n"
": :\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
#, fuzzy
msgid "# Double Frees in Modern C++"
msgstr "# Liberaciones dobles en C++ moderno"

#: src/ownership/double-free-modern-cpp.md:3
#, fuzzy
msgid "Modern C++ solves this differently:"
msgstr "C ++ moderno resuelve esto de manera diferente:"

#: src/ownership/double-free-modern-cpp.md:5
#, fuzzy
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"est√°ndar::cadena s1 = \"Cpp\";\n"
"est√°ndar::cadena s2 = s1; // Duplicar los datos en s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent "
"copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* Los datos del mont√≥n de `s1` se duplican y `s2` obtiene su propia copia "
"independiente.\n"
"* Cuando `s1` y `s2` quedan fuera del alcance, cada uno libera su propia "
"memoria."

#: src/ownership/double-free-modern-cpp.md:13
#, fuzzy
msgid "Before copy-assignment:"
msgstr "Antes de la tarea de copia:"

#: src/ownership/double-free-modern-cpp.md:16
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - -.\n"
": : : :\n"
": s1 : : :\n"
": +-----------+-------+ : : +----+----+----+ :\n"
": | ptr | o---+---+--+--+-->| C | pag | pag | :\n"
": | Len | 3 | : : +----+----+----+ :\n"
": | capacidad | 3 | : : :\n"
": +-----------+-------+ : : :\n"
": : `- - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:30
#, fuzzy
msgid "After copy-assignment:"
msgstr "Despu√©s de la asignaci√≥n de copias:"

#: src/ownership/double-free-modern-cpp.md:32
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - -.\n"
": : : :\n"
": s1 : : :\n"
": +-----------+-------+ : : +----+----+----+ :\n"
": | ptr | o---+---+--+--+-->| C | pag | pag | :\n"
": | Len | 3 | : : +----+----+----+ :\n"
": | capacidad | 3 | : : :\n"
": +-----------+-------+ : : :\n"
": : : :\n"
": s2 : : :\n"
": +-----------+-------+ : : +----+----+----+ :\n"
": | ptr | o---+---+-----+-->| C | pag | pag | :\n"
": | Len | 3 | : : +----+----+----+ :\n"
": | capacidad | 3 | : : :\n"
": +-----------+-------+ : : :\n"
": : `- - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moves-function-calls.md:1
#, fuzzy
msgid "# Moves in Function Calls"
msgstr "# Movimientos en llamadas a funciones"

#: src/ownership/moves-function-calls.md:3
#, fuzzy
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Cuando pasa un valor a una funci√≥n, el valor se asigna a la funci√≥n\n"
"par√°metro. Esto transfiere la propiedad:"

#: src/ownership/moves-function-calls.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn say_hello(nombre: Cadena) {\n"
"    println!(\"Hola {nombre}\")\n"
"}"

#: src/ownership/moves-function-calls.md:11
#, fuzzy
msgid ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let nombre = String::from(\"Alicia\");\n"
"    decir_hola(nombre);\n"
"    // decir_hola(nombre);\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:20
#, fuzzy
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) "
"and if `say_hello` accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call "
"(`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making "
"move semantics the default, and by forcing programmers to make clones "
"explicit."
msgstr ""
"* Con la primera llamada a `say_hello`, `main` renuncia a la propiedad de "
"`name`. Posteriormente, `name` ya no se puede usar dentro de `main`.\n"
"* La memoria del mont√≥n asignada para `name` se liberar√° al final de la "
"funci√≥n `say_hello`.\n"
"* `main` puede retener la propiedad si pasa `name` como referencia (`&name`) "
"y si `say_hello` acepta una referencia como par√°metro.\n"
"* Alternativamente, `main` puede pasar un clon de `name` en la primera "
"llamada (`name.clone()`).\n"
"* Rust hace que sea m√°s dif√≠cil que C ++ crear copias sin darse cuenta al "
"hacer que la sem√°ntica de movimiento sea la predeterminada y al obligar a "
"los programadores a hacer clones expl√≠citos."

#: src/ownership/copy-clone.md:1
#, fuzzy
msgid "# Copying and Cloning"
msgstr "# Copia y Clonaci√≥n"

#: src/ownership/copy-clone.md:3
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Si bien la sem√°ntica de movimiento es la predeterminada, ciertos tipos se "
"copian de forma predeterminada:"

#: src/ownership/copy-clone.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea x = 42;\n"
"    sea y = x;\n"
"    imprimir!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:14
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Estos tipos implementan el rasgo `Copiar`."

#: src/ownership/copy-clone.md:16
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr "Puede optar por sus propios tipos para usar la sem√°ntica de copia:"

#: src/ownership/copy-clone.md:18
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```herrumbre, editable\n"
"#[derive(Copiar, Clonar, Depurar)]\n"
"punto de estructura (i32, i32);"

#: src/ownership/copy-clone.md:22
#, fuzzy
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p1 = Punto(3, 4);\n"
"    sea p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:30
#, fuzzy
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Despu√©s de la asignaci√≥n, tanto `p1` como `p2` poseen sus propios datos.\n"
"* Tambi√©n podemos usar `p1.clone()` para copiar expl√≠citamente los datos."

#: src/ownership/copy-clone.md:35
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copiar y clonar no es lo mismo:"

#: src/ownership/copy-clone.md:37
#, fuzzy
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in "
"C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* Copiar se refiere a copias bit a bit de regiones de memoria y no funciona "
"en objetos arbitrarios.\n"
"* La copia no permite una l√≥gica personalizada (a diferencia de los "
"constructores de copias en C++).\n"
"* La clonaci√≥n es una operaci√≥n m√°s general y tambi√©n permite un "
"comportamiento personalizado al implementar el rasgo `Clonar`.\n"
"* La copia no funciona en tipos que implementan el rasgo `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
#, fuzzy
msgid "In the above example, try the following:"
msgstr "En el ejemplo anterior, intente lo siguiente:"

#: src/ownership/copy-clone.md:44
#, fuzzy
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because "
"`String` is not a `Copy` type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in "
"the `println!` for  `p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Agregue un campo `String` a `struct Point`. No se compilar√° porque "
"`String` no es del tipo `Copy`.\n"
"* Eliminar `Copiar` del atributo `derivar`. El error del compilador ahora "
"est√° en `println!` para `p1`.\n"
"* Demuestra que funciona si clonas `p1` en su lugar."

#: src/ownership/copy-clone.md:48
#, fuzzy
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust\n"
"at compile time. In this case the default implementations of `Copy` and "
"`Clone` traits are generated.\n"
"    \n"
"</details>"
msgstr ""
"Si los estudiantes preguntan sobre `derive`, es suficiente decir que esta es "
"una forma de generar c√≥digo en Rust\n"
"en tiempo de compilaci√≥n. En este caso, se generan las implementaciones "
"predeterminadas de los rasgos `Copiar` y `Clonar`.\n"
"    \n"
"</detalles>"

#: src/ownership/borrowing.md:1
#, fuzzy
msgid "# Borrowing"
msgstr "# pr√©stamo"

#: src/ownership/borrowing.md:3
#, fuzzy
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"En lugar de transferir la propiedad al llamar a una funci√≥n, puede dejar que "
"un\n"
"funci√≥n _pedir prestado_ el valor:"

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"punto de estructura (i32, i32);"

#: src/ownership/borrowing.md:10
#, fuzzy
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"
msgstr ""
"fn add(p1: &Punto, p2: &Punto) -> Punto {\n"
"    Punto (p1.0 + p2.0, p1.1 + p2.1)\n"
"}"

#: src/ownership/borrowing.md:14
#, fuzzy
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p1 = Punto(3, 4);\n"
"    sea p2 = Punto(10, 20);\n"
"    sea p3 = sumar(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"

#: src/ownership/borrowing.md:22
#, fuzzy
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* La funci√≥n `add` _toma prestados_ dos puntos y devuelve un nuevo punto.\n"
"* La persona que llama conserva la propiedad de las entradas."

#: src/ownership/borrowing.md:27
#, fuzzy
msgid ""
"Notes on stack returns:\n"
"* Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground]. In the \"DEBUG\" optimization level, the "
"addresses should change, while the stay the same when changing to the "
"\"RELEASE\" setting:"
msgstr ""
"Notas sobre las devoluciones de pila:\n"
"* Demostrar que el retorno de `add` es barato porque el compilador puede "
"eliminar la operaci√≥n de copia. Cambie el c√≥digo anterior para imprimir las "
"direcciones de la pila y ejec√∫telo en el [Patio de juegos]. En el nivel de "
"optimizaci√≥n \"DEBUG\", las direcciones deben cambiar, mientras que "
"permanecen iguales cuando se cambia a la configuraci√≥n \"RELEASE\":"

#: src/ownership/borrowing.md:30
#, fuzzy
msgid ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"  ```herrumbre, editable\n"
"  #[derivar(Depurar)]\n"
"  punto de estructura (i32, i32);"

#: src/ownership/borrowing.md:34
#, fuzzy
msgid ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"
msgstr ""
"  fn add(p1: &Punto, p2: &Punto) -> Punto {\n"
"      sea p = Punto(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      pag\n"
"  }"

#: src/ownership/borrowing.md:40
#, fuzzy
msgid ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification "
"because constructors can have side effects. In Rust, this is not an issue at "
"all. If RVO did not happen, Rust will always performs a simple and efficient "
"`memcpy` copy."
msgstr ""
"  fn principal() {\n"
"      sea p1 = Punto(3, 4);\n"
"      sea p2 = Punto(10, 20);\n"
"      sea p3 = sumar(&p1, &p2);\n"
"      imprimir!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* El compilador Rust puede optimizar el valor de retorno (RVO).\n"
"* En C++, la elisi√≥n de copia debe definirse en la especificaci√≥n del "
"lenguaje porque los constructores pueden tener efectos secundarios. En Rust, "
"esto no es un problema en absoluto. Si RVO no sucedi√≥, Rust siempre "
"realizar√° una copia `memcpy` simple y eficiente."

#: src/ownership/borrowing.md:53
#, fuzzy
msgid "[Playground]: https://play.rust-lang.org/"
msgstr "[Patio de juegos]: https://play.rust-lang.org/"

#: src/ownership/shared-unique-borrows.md:1
#, fuzzy
msgid "# Shared and Unique Borrows"
msgstr "# Pr√©stamos compartidos y √∫nicos"

#: src/ownership/shared-unique-borrows.md:3
#, fuzzy
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr ""
"Rust impone restricciones en las formas en que puede tomar prestados valores:"

#: src/ownership/shared-unique-borrows.md:5
#, fuzzy
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Puede tener uno o m√°s valores `&T` en cualquier momento, _o_\n"
"* Puede tener exactamente un valor `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn principal() {\n"
"    sea mut a: i32 = 10;\n"
"    sea b: &i32 = &a;"

#: src/ownership/shared-unique-borrows.md:13
#, fuzzy
msgid ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"
msgstr ""
"    {\n"
"        sea c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
#, fuzzy
msgid ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/ownership/shared-unique-borrows.md:25
#, fuzzy
msgid ""
"* The above code does not compile because `a` is borrowed as mutable "
"(through `c`) and as immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"* El c√≥digo anterior no se compila porque `a` se toma prestado como mutable "
"(a trav√©s de `c`) y como inmutable (a trav√©s de `b`) al mismo tiempo.\n"
"* Mueva la declaraci√≥n `println!` para `b` antes del alcance que introduce "
"`c` para hacer que el c√≥digo se compile.\n"
"* Despu√©s de ese cambio, el compilador se da cuenta de que `b` solo se usa "
"antes del nuevo pr√©stamo mutable de `a` a `c`. Esta es una caracter√≠stica "
"del verificador de pr√©stamos llamada \"vida √∫til no l√©xica\"."

#: src/ownership/lifetimes.md:1
#, fuzzy
msgid "# Lifetimes"
msgstr "# vidas"

#: src/ownership/lifetimes.md:3
#, fuzzy
msgid "A borrowed value has a _lifetime_:"
msgstr "Un valor prestado tiene un _lifetime_:"

#: src/ownership/lifetimes.md:5
#, fuzzy
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a "
"lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that "
"there is\n"
"    a valid solution."
msgstr ""
"* El tiempo de vida se puede elidir: `add(p1: &Point, p2: &Point) -> "
"Point`.\n"
"* Los tiempos de vida tambi√©n pueden ser expl√≠citos: `&'a Point`, "
"`&'document str`.\n"
"* Lee `&'un Punto` como \"un `Punto` prestado que es v√°lido por al menos el\n"
"  toda la vida `a`\".\n"
"* El tiempo de vida siempre es inferido por el compilador: no se puede "
"asignar un tiempo de vida\n"
"  usted mismo.\n"
"  * Las anotaciones de por vida crean restricciones; el compilador verifica "
"que hay\n"
"    una soluci√≥n v√°lida."

#: src/ownership/lifetimes-function-calls.md:1
#, fuzzy
msgid "# Lifetimes in Function Calls"
msgstr "# Vida √∫til en llamadas a funciones"

#: src/ownership/lifetimes-function-calls.md:3
#, fuzzy
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"Adem√°s de tomar prestados sus argumentos, una funci√≥n puede devolver un "
"valor prestado:"

#: src/ownership/lifetimes-function-calls.md:9
#, fuzzy
msgid ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"
msgstr ""
"fn left_most<'a>(p1: &'a Punto, p2: &'a Punto) -> &'a Punto {\n"
"    si p1.0 < p2.0 { p1 } si no { p2 }\n"
"}"

#: src/ownership/lifetimes-function-calls.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p1: Punto = Punto(10, 10);\n"
"    sea p2: Punto = Punto(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"Punto m√°s a la izquierda: {:?}\", p3);\n"
"}\n"
"```"

#: src/ownership/lifetimes-function-calls.md:21
#, fuzzy
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` es un par√°metro gen√©rico, es inferido por el compilador.\n"
"* Los tiempos de vida comienzan con `'` y `'a` es un nombre predeterminado "
"t√≠pico.\n"
"* Lee `&'un Punto` como \"un `Punto` prestado que es v√°lido por al menos el\n"
"  toda la vida `a`\".\n"
"  * La parte _al menos_ es importante cuando los par√°metros est√°n en "
"diferentes √°mbitos."

#: src/ownership/lifetimes-function-calls.md:31
#, fuzzy
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), "
"resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"* Mueve la declaraci√≥n de `p2` y `p3` a un nuevo √°mbito (`{ ... }`), lo que "
"da como resultado el siguiente c√≥digo:\n"
"  ```oxidar, ignorar\n"
"  #[derivar(Depurar)]\n"
"  punto de estructura (i32, i32);"

#: src/ownership/lifetimes-function-calls.md:36
#, fuzzy
msgid ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"
msgstr ""
"  fn left_most<'a>(p1: &'a Punto, p2: &'a Punto) -> &'a Punto {\n"
"      si p1.0 < p2.0 { p1 } si no { p2 }\n"
"  }"

#: src/ownership/lifetimes-function-calls.md:40
#, fuzzy
msgid ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"  fn principal() {\n"
"      sea p1: Punto = Punto(10, 10);\n"
"      vamos p3: &Punto;\n"
"      {\n"
"          sea p2: Punto = Punto(20, 20);\n"
"          p3 = m√°s a la izquierda (&p1, &p2);\n"
"      }\n"
"      println!(\"Punto m√°s a la izquierda: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Tenga en cuenta que esto no se compila ya que `p3` sobrevive a `p2`."

#: src/ownership/lifetimes-function-calls.md:52
#, fuzzy
msgid ""
"* Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function "
"returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global "
"variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the "
"returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* Reinicie el espacio de trabajo y cambie la firma de la funci√≥n a `fn "
"left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. Esto no se "
"compilar√° porque la relaci√≥n entre las vidas `'a` y `'b` no est√° clara.\n"
"* Otra forma de explicarlo:\n"
"  * Una funci√≥n toma prestadas dos referencias a dos valores y la funci√≥n "
"devuelve\n"
"    otra referencia\n"
"  * Debe haber venido de una de esas dos entradas (o de una variable "
"global).\n"
"  * ¬øCu√°l es? El compilador necesita saber, por lo que en el sitio de la "
"llamada no se usa la referencia devuelta\n"
"    durante m√°s tiempo que una variable de donde provino la referencia."

#: src/ownership/lifetimes-data-structures.md:1
#, fuzzy
msgid "# Lifetimes in Data Structures"
msgstr "# Vidas en estructuras de datos"

#: src/ownership/lifetimes-data-structures.md:3
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Si un tipo de datos almacena datos prestados, debe anotarse con un tiempo de "
"vida:"

#: src/ownership/lifetimes-data-structures.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"estructura Destacar<'doc>(&'doc str);"

#: src/ownership/lifetimes-data-structures.md:9
#, fuzzy
msgid ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"
msgstr ""
"fn erase(texto: Cadena) {\n"
"    println!(\"Adi√≥s {texto}!\");\n"
"}"

#: src/ownership/lifetimes-data-structures.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy "
"dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let text = String::from(\"El veloz zorro marr√≥n salta sobre el perro "
"perezoso.\");\n"
"    let zorro = Destacar(&texto[4..19]);\n"
"    dejar perro = Destacar(&texto[35..43]);\n"
"    // borrar(texto);\n"
"    println!(\"{zorro:?}\");\n"
"    println!(\"{perro:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
#, fuzzy
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one "
"lifetime annotation. This can be necessary if there is a need to describe "
"lifetime relationships between the references themselves, in addition to the "
"lifetime of the struct itself. Those are very advanced use cases.\n"
"</details>"
msgstr ""
"* En el ejemplo anterior, la anotaci√≥n en `Highlight` impone que los datos "
"subyacentes al `&str` contenido vivan al menos tanto tiempo como cualquier "
"instancia de `Highlight` que use esos datos.\n"
"* Si 'texto' se consume antes del final de la vida √∫til de 'zorro' (o "
"'perro'), el verificador de pr√©stamos arroja un error.\n"
"* Los tipos con datos prestados obligan a los usuarios a conservar los datos "
"originales. Esto puede ser √∫til para crear vistas ligeras, pero generalmente "
"las hace un poco m√°s dif√≠ciles de usar.\n"
"* Cuando sea posible, haga que las estructuras de datos sean propietarias de "
"sus datos directamente.\n"
"* Algunas estructuras con m√∫ltiples referencias internas pueden tener m√°s de "
"una anotaci√≥n de por vida. Esto puede ser necesario si existe la necesidad "
"de describir las relaciones de duraci√≥n entre las propias referencias, "
"adem√°s de la duraci√≥n de la estructura en s√≠. Esos son casos de uso muy "
"avanzados.\n"
"</detalles>"

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "# Day 1: Afternoon Exercises"
msgstr "# D√≠a 1: Ejercicios por la tarde"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Veremos dos cosas:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid "* A small book library,"
msgstr "* Una peque√±a biblioteca de libros,"

#: src/exercises/day-1/afternoon.md:7
#, fuzzy
msgid "* Iterators and ownership (hard)."
msgstr "* Iteradores y propiedad (dif√≠cil)."

#: src/exercises/day-1/afternoon.md:13 src/exercises/day-2/afternoon.md:9
#, fuzzy
msgid "[solutions]: solutions-afternoon.md"
msgstr "[soluciones]: soluciones-tarde.md"

#: src/exercises/day-1/book-library.md:1
#, fuzzy
msgid "# Designing a Library"
msgstr "# Dise√±ando una Biblioteca"

#: src/exercises/day-1/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now,\n"
"you just need to know part of its API:"
msgstr ""
"Aprenderemos mucho m√°s sobre las estructuras y el tipo `Vec<T>` ma√±ana. Por "
"ahora,\n"
"solo necesitas conocer parte de su API:"

#: src/exercises/day-1/book-library.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"valor medio: {}\", vec[vec.len() / 2]);\n"
"    para elemento en vec.iter() {\n"
"        println!(\"elemento: {elemento}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:17
#, fuzzy
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Use esto para crear una aplicaci√≥n de biblioteca. Copie el c√≥digo de abajo "
"para\n"
"<https://play.rust-lang.org/> y actualice los tipos para compilarlo:"

#: src/exercises/day-1/book-library.md:24
#, fuzzy
msgid ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"Biblioteca de estructura {\n"
"    libros: Vec<Libro>,\n"
"}"

#: src/exercises/day-1/book-library.md:28
#: src/exercises/day-1/solutions-afternoon.md:27
#, fuzzy
msgid ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"
msgstr ""
"libro de estructura {\n"
"    t√≠tulo: Cadena,\n"
"    a√±o: u16,\n"
"}"

#: src/exercises/day-1/book-library.md:33
#: src/exercises/day-1/solutions-afternoon.md:32
#, fuzzy
msgid ""
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"libro impl {\n"
"    // Este es un constructor, usado a continuaci√≥n.\n"
"    fn nuevo(t√≠tulo: &str, a√±o: u16) -> Libro {\n"
"        Libro {\n"
"            t√≠tulo: Cadena::de(t√≠tulo),\n"
"            a√±o,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:43
#, fuzzy
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"
msgstr ""
"// Esto hace posible imprimir valores de libros con {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Resultado {\n"
"        escribe!(f, \"{} ({})\", auto.t√≠tulo, auto.a√±o)\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:50
#, fuzzy
msgid ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"Biblioteca impl {\n"
"    fn nuevo() -> Biblioteca {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-1/book-library.md:55
#, fuzzy
msgid ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn len(self) -> usar {\n"
"    // sin implementar!()\n"
"    //"

#: src/exercises/day-1/book-library.md:59
#, fuzzy
msgid ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn is_empty(self) -> bool {\n"
"    // sin implementar!()\n"
"    //"

#: src/exercises/day-1/book-library.md:63
#, fuzzy
msgid ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn add_book(self, libro: Libro) {\n"
"    // sin implementar!()\n"
"    //"

#: src/exercises/day-1/book-library.md:67
#, fuzzy
msgid ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn imprimir_libros(self) {\n"
"    // sin implementar!()\n"
"    //"

#: src/exercises/day-1/book-library.md:71
#, fuzzy
msgid ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"
msgstr ""
"    //fn libro_antiguo(self) -> Opci√≥n<&Libro> {\n"
"    // sin implementar!()\n"
"    //\n"
"}"

#: src/exercises/day-1/book-library.md:76
#, fuzzy
msgid ""
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// Esto muestra el comportamiento deseado. Descomente el c√≥digo a "
"continuaci√≥n y\n"
"// implementar los m√©todos faltantes. Deber√° actualizar el\n"
"// firmas de m√©todos, incluido el par√°metro \"self\"! Puedes\n"
"// tambi√©n es necesario actualizar los enlaces de variables dentro de main.\n"
"fn principal() {\n"
"    let biblioteca = Biblioteca::nuevo();"

#: src/exercises/day-1/book-library.md:83
#, fuzzy
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"```"
msgstr ""
"    //println!(\"Nuestra biblioteca est√° vac√≠a: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"El Se√±or de los Anillos\", 1954));\n"
"    //library.add_book(Book::new(\"Las aventuras de Alicia en el pa√≠s de las "
"maravillas\", 1865));\n"
"    //\n"
"    //biblioteca.print_books();\n"
"    //\n"
"    //coincide biblioteca.libro_antiguo() {\n"
"    // Algunos(libro) => println!(\"Mi libro m√°s antiguo es {libro}\"),\n"
"    // Ninguno => println!(\"¬°Mi biblioteca est√° vac√≠a!\"),\n"
"    //\n"
"    //\n"
"    //println!(\"Nuestra biblioteca tiene {} libros\", biblioteca.len());\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:99
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"<detalles>\n"
"    \n"
"[Soluci√≥n](soluciones-tarde.md#dise√±o-de-una-biblioteca)"

#: src/exercises/day-1/iterators-and-ownership.md:1
#, fuzzy
msgid "# Iterators and Ownership"
msgstr "# iteradores y propiedad"

#: src/exercises/day-1/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"El modelo de propiedad de Rust afecta a muchas API. Un ejemplo de esto es "
"el\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) y\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"rasgos."

#: src/exercises/day-1/iterators-and-ownership.md:8
#, fuzzy
msgid "## `Iterator`"
msgstr "## `Iterador`"

#: src/exercises/day-1/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. "
"The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Los rasgos son como interfaces: describen el comportamiento (m√©todos) para "
"un tipo. √âl\n"
"El rasgo 'Iterador' simplemente dice que puede llamar a 'siguiente' hasta "
"que obtenga 'Ninguno' de vuelta:"

#: src/exercises/day-1/iterators-and-ownership.md:13
#, fuzzy
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""
"```herrumbre\n"
"iterador de rasgo pub {\n"
"    tipo Art√≠culo;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "Usas este rasgo as√≠:"

#: src/exercises/day-1/iterators-and-ownership.md:22
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:27
#, fuzzy
msgid ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""
"    println!(\"v[0]: {:?}\", iter.siguiente());\n"
"    println!(\"v[1]: {:?}\", iter.siguiente());\n"
"    println!(\"v[2]: {:?}\", iter.siguiente());\n"
"    println!(\"No m√°s elementos: {:?}\", iter.next());\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "¬øCu√°l es el tipo devuelto por el iterador? Prueba tu respuesta aqu√≠:"

#: src/exercises/day-1/iterators-and-ownership.md:36
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn principal() {\n"
"    sea v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:41
#: src/exercises/day-1/iterators-and-ownership.md:78
#, fuzzy
msgid ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "¬øPor qu√© se utiliza este tipo?"

#: src/exercises/day-1/iterators-and-ownership.md:48
#, fuzzy
msgid "## `IntoIterator`"
msgstr "## `EnIterador`"

#: src/exercises/day-1/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"El rasgo `Iterador` te dice c√≥mo _iterar_ una vez que hayas creado un\n"
"iterador El rasgo relacionado `IntoIterator` te dice c√≥mo crear el iterador:"

#: src/exercises/day-1/iterators-and-ownership.md:53
#, fuzzy
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"
msgstr ""
"```herrumbre\n"
"pub rasgo IntoIterator {\n"
"    tipo Art√≠culo;\n"
"    escriba IntoIter: Iterator<Item = Self::Item>;"

#: src/exercises/day-1/iterators-and-ownership.md:58
#, fuzzy
msgid ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"La sintaxis aqu√≠ significa que cada implementaci√≥n de `IntoIterator` debe\n"
"declarar dos tipos:"

#: src/exercises/day-1/iterators-and-ownership.md:65
#, fuzzy
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: el tipo sobre el que iteramos, como `i8`,\n"
"* `IntoIter`: el tipo `Iterator` devuelto por el m√©todo `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Tenga en cuenta que `IntoIter` y `Item` est√°n vinculados: el iterador debe "
"tener el mismo\n"
"Tipo `Item`, lo que significa que devuelve `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Como antes, ¬øcu√°l es el tipo devuelto por el iterador?"

#: src/exercises/day-1/iterators-and-ownership.md:73
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), "
"String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn principal() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), "
"String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"

#: src/exercises/day-1/iterators-and-ownership.md:83
#, fuzzy
msgid "## `for` Loops"
msgstr "## Bucles `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Ahora que conocemos tanto `Iterator` como `IntoIterator`, podemos construir "
"bucles `for`.\n"
"Llaman a `into_iter()` en una expresi√≥n e itera sobre el resultado\n"
"iterador:"

#: src/exercises/day-1/iterators-and-ownership.md:89
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"

#: src/exercises/day-1/iterators-and-ownership.md:93
#, fuzzy
msgid ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"
msgstr ""
"    para palabra en &v {\n"
"        println!(\"palabra: {palabra}\");\n"
"    }"

#: src/exercises/day-1/iterators-and-ownership.md:97
#, fuzzy
msgid ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    para palabra en v {\n"
"        println!(\"palabra: {palabra}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "¬øCu√°l es el tipo de `palabra` en cada bucle?"

#: src/exercises/day-1/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for "
"[`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"Experimente con el c√≥digo anterior y luego consulte la documentaci√≥n para "
"[`impl\n"
"en iterador para\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"y [`impl IntoIterator para\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"para comprobar sus respuestas."

#: src/welcome-day-2.md:1
#, fuzzy
msgid "# Welcome to Day 2"
msgstr "# Bienvenido al D√≠a 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Ahora que hemos visto una buena cantidad de Rust, continuaremos con:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid "* Structs, enums, methods."
msgstr "* Estructuras, enumeraciones, m√©todos."

#: src/welcome-day-2.md:7
#, fuzzy
msgid "* Pattern matching: destructuring enums, structs, and arrays."
msgstr ""
"* Coincidencia de patrones: desestructuraci√≥n de enumeraciones, estructuras "
"y matrices."

#: src/welcome-day-2.md:9
#, fuzzy
msgid ""
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
"and\n"
"  `continue`."
msgstr ""
"* Construcciones de flujo de control: `if`, `if let`, `while`, `while let`, "
"`break` y\n"
"  `continuar`."

#: src/welcome-day-2.md:12
#, fuzzy
msgid ""
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  and `Arc`."
msgstr ""
"* La biblioteca est√°ndar: `String`, `Option` y `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  y `Arco`."

#: src/welcome-day-2.md:15
#, fuzzy
msgid "* Modules: visibility, paths, and filesystem hierarchy."
msgstr "* M√≥dulos: visibilidad, rutas y jerarqu√≠a del sistema de archivos."

#: src/structs.md:1
#, fuzzy
msgid "# Structs"
msgstr "# Estructuras"

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr ""
"Al igual que C y C++, Rust tiene soporte para estructuras personalizadas:"

#: src/structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"estructura Persona {\n"
"    nombre: cadena,\n"
"    edad: u8,\n"
"}"

#: src/structs.md:11
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let mut peter = Persona {\n"
"        nombre: String::from(\"Pedro\"),\n"
"        edad: 27,\n"
"    };\n"
"    println!(\"{} tiene {} a√±os\", pedro.nombre, pedro.edad);\n"
"    \n"
"    pedro.edad = 28;\n"
"    println!(\"{} tiene {} a√±os\", pedro.nombre, pedro.edad);\n"
"    \n"
"    let jackie = Persona {\n"
"        nombre: Cadena::desde(\"Jackie\"),\n"
"        ..pedro\n"
"    };\n"
"    println!(\"{} tiene {} a√±os\", jackie.nombre, jackie.edad);\n"
"}\n"
"```"

#: src/structs.md:29
#, fuzzy
msgid "<details>\nKey Points: "
msgstr "<detalles>\nPuntos clave:"

#: src/structs.md:32
#, fuzzy
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following "
"slides.\n"
"* This may be a good time to let people know there are different types of "
"structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but don‚Äôt have any data that you want to store in the "
"value itself. \n"
"  * The next slide will introduce Tuple structs."
msgstr ""
"* Las estructuras funcionan como en C o C++.\n"
"  * Al igual que en C++, ya diferencia de C, no se necesita typedef para "
"definir un tipo.\n"
"  * A diferencia de C++, no hay herencia entre estructuras.\n"
"* Los m√©todos se definen en un bloque `impl`, que veremos en las siguientes "
"diapositivas.\n"
"* Este puede ser un buen momento para que la gente sepa que hay diferentes "
"tipos de estructuras.\n"
"  * Las estructuras de tama√±o cero `por ejemplo, struct Foo;` pueden usarse "
"al implementar un rasgo en alg√∫n tipo pero no tienen ning√∫n dato que desee "
"almacenar en el valor en s√≠.\n"
"  * La siguiente diapositiva presentar√° las estructuras Tuple."

#: src/structs/tuple-structs.md:1
#, fuzzy
msgid "# Tuple Structs"
msgstr "# Estructuras de tupla"

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"Si los nombres de los campos no son importantes, puede usar una estructura "
"de tupla:"

#: src/structs/tuple-structs.md:5
#, fuzzy
msgid "```rust,editable\nstruct Point(i32, i32);"
msgstr "```herrumbre, editable\npunto de estructura (i32, i32);"

#: src/structs/tuple-structs.md:8
#, fuzzy
msgid ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p = Punto(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Esto se usa a menudo para envoltorios de un solo campo (llamados nuevos "
"tipos):"

#: src/structs/tuple-structs.md:16
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"struct LibraDeFuerza(f64);\n"
"estructura Newtons(f64);"

#: src/structs/tuple-structs.md:20
#, fuzzy
msgid ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}"
msgstr ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo! (\"Preg√∫ntale a un cient√≠fico de cohetes en la NASA\")\n"
"}"

#: src/structs/tuple-structs.md:24
#, fuzzy
msgid ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"
msgstr ""
"fn set_thruster_force(fuerza: Newtons) {\n"
"    // ...\n"
"}"

#: src/structs/tuple-structs.md:28
#, fuzzy
msgid ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"
msgstr ""
"fn principal() {\n"
"    let fuerza = computar_propulsor_fuerza();\n"
"    set_thruster_force(fuerza);\n"
"}"

#: src/structs/tuple-structs.md:33 src/generics/trait-objects.md:86
#, fuzzy
msgid "```"
msgstr "```"

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer "
"have to validate it again at every use: 'PhoneNumber(String)` or "
"`OddNumber(u32)`.\n"
"    \n"
"</details>"
msgstr ""
"Los tipos nuevos son una excelente manera de codificar informaci√≥n adicional "
"sobre el valor en un tipo primitivo, por ejemplo:\n"
"  * El n√∫mero se mide en algunas unidades: `Newtons` en el ejemplo "
"anterior.\n"
"  * El valor pas√≥ cierta validaci√≥n cuando se cre√≥, por lo que ya no tendr√° "
"que volver a validarlo cada vez que lo use: 'PhoneNumber(String)' o "
"'OddNumber(u32)'.\n"
"    \n"
"</detalles>"

#: src/structs/field-shorthand.md:1
#, fuzzy
msgid "# Field Shorthand Syntax"
msgstr "# Sintaxis abreviada de campo"

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Si ya tiene variables con los nombres correctos, puede crear las\n"
"estructura usando una abreviatura:"

#: src/structs/field-shorthand.md:6 src/methods.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"estructura Persona {\n"
"    nombre: cadena,\n"
"    edad: u8,\n"
"}"

#: src/structs/field-shorthand.md:13
#, fuzzy
msgid ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"
msgstr ""
"impl Persona {\n"
"    fn nuevo(nombre: Cadena, edad: u8) -> Persona {\n"
"        Persona { nombre, edad }\n"
"    }\n"
"}"

#: src/structs/field-shorthand.md:19
#, fuzzy
msgid ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let peter = Persona::nuevo(String::from(\"Peter\"), 27);\n"
"    println!(\"{pedro:?}\");\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:27
#, fuzzy
msgid ""
"The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""
"La funci√≥n `nueva` podr√≠a escribirse usando `Self` como un tipo, ya que es "
"intercambiable con el nombre del tipo de estructura"

#: src/structs/field-shorthand.md:29
#, fuzzy
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"</details>"
msgstr ""
"```oxidar, ignorar\n"
"impl Persona {\n"
"    fn nuevo(nombre: Cadena, edad: u8) -> Self {\n"
"        Yo { nombre, edad }\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"</detalles>"

#: src/enums.md:1
#, fuzzy
msgid "# Enums"
msgstr "# enumeraciones"

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"La palabra clave `enum` permite la creaci√≥n de un tipo que tiene algunos\n"
"diferentes variantes:"

#: src/enums.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn generar_n√∫mero_aleatorio() -> i32 {\n"
"    4 // Elegido por tirada justa de dados. Garantizado para ser al azar.\n"
"}"

#: src/enums.md:11
#, fuzzy
msgid ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"
msgstr ""
"#[derivar(Depurar)]\n"
"enum CoinFlip {\n"
"    cabezas,\n"
"    Cruz,\n"
"}"

#: src/enums.md:17
#, fuzzy
msgid ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"
msgstr ""
"fn flip_coin() -> CoinFlip {\n"
"    let n√∫mero_aleatorio = generar_n√∫mero_aleatorio();\n"
"    si n√∫mero_aleatorio % 2 == 0 {\n"
"        volver CoinFlip::Cabezas;\n"
"    } m√°s {\n"
"        volver CoinFlip::Colas;\n"
"    }\n"
"}"

#: src/enums.md:26
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    println!(\"Obtuviste: {:?}\", flip_coin());\n"
"}\n"
"```"

#: src/enums.md:31
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:"
msgstr ""
"<detalles>\n"
"    \n"
"Puntos clave:"

#: src/enums.md:35
#, fuzzy
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tail`. You might note the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or "
"one with different types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate "
"structs but then they wouldn‚Äôt be the same type as they would if they were "
"all defined in an enum. \n"
"</details>"
msgstr ""
"* Las enumeraciones le permiten recopilar un conjunto de valores bajo un "
"tipo\n"
"* Esta p√°gina ofrece un tipo de enumeraci√≥n `CoinFlip` con dos variantes "
"`Heads` y `Tail`. Puede anotar el espacio de nombres cuando use variantes.\n"
"* Este podr√≠a ser un buen momento para comparar Structs y Enums:\n"
"  * En ambos, puedes tener una versi√≥n simple sin campos (unit struct) o una "
"con diferentes tipos de campos (variant payloads).\n"
"  * En ambos, las funciones asociadas se definen dentro de un bloque "
"`impl`.\n"
"  * Incluso podr√≠a implementar las diferentes variantes de una enumeraci√≥n "
"con estructuras separadas, pero entonces no ser√≠an del mismo tipo que si "
"estuvieran todas definidas en una enumeraci√≥n.\n"
"</detalles>"

#: src/enums/variant-payloads.md:1
#, fuzzy
msgid "# Variant Payloads"
msgstr "# Cargas √∫tiles variantes"

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"Puede definir enumeraciones m√°s ricas donde las variantes llevan datos. A "
"continuaci√≥n, puede utilizar el\n"
"instrucci√≥n `match` para extraer los datos de cada variante:"

#: src/enums/variant-payloads.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"enumeraci√≥n WebEvent {\n"
"    PageLoad, // Variante sin payload\n"
"    KeyPress(char), // Variante de estructura de tupla\n"
"    Haga clic en { x: i64, y: i64 }, // Variante de estructura completa\n"
"}"

#: src/enums/variant-payloads.md:13
#, fuzzy
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}"
msgstr ""
"#[rustfmt::saltar]\n"
"fn inspeccionar (evento: WebEvent) {\n"
"    evento de partido {\n"
"        WebEvent::PageLoad => println!(\"p√°gina cargada\"),\n"
"        WebEvent::KeyPress(c) => println!(\"puls√≥ '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"hizo clic en x={x}, "
"y={y}\"),\n"
"    }\n"
"}"

#: src/enums/variant-payloads.md:22
#, fuzzy
msgid ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""
"fn principal() {\n"
"    dejar cargar = WebEvent::PageLoad;\n"
"    vamos a presionar = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"

#: src/enums/variant-payloads.md:27
#, fuzzy
msgid ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""
"    inspeccionar (cargar);\n"
"    inspeccionar (presionar);\n"
"    inspeccionar (clic);\n"
"}\n"
"```"

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"* In the above example, accessing the `char` in `KeyPress`, or `x` and `y` "
"in `Click` only works within a `match` statement.\n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* `WebEvent::Click { ... }` is not exactly the same as "
"`WebEvent::Click(Click)` with a top level `struct Click { ... }`. The "
"inlined version cannot implement traits, for example."
msgstr ""
"* En el ejemplo anterior, acceder a `char` en `KeyPress`, o `x` e `y` en "
"`Click` solo funciona dentro de una instrucci√≥n `match`.\n"
"* `match` inspecciona un campo discriminante oculto en `enum`.\n"
"* `WebEvent::Click { ... }` no es exactamente lo mismo que "
"`WebEvent::Click(Click)` con un nivel superior `struct Click { ... }`. La "
"versi√≥n en l√≠nea no puede implementar rasgos, por ejemplo."

#: src/enums/sizes.md:1
#, fuzzy
msgid "# Enum Sizes"
msgstr "# Tama√±os de enumeraci√≥n"

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Las enumeraciones de Rust est√°n apretadas, teniendo en cuenta las "
"restricciones debidas a la alineaci√≥n:"

#: src/enums/sizes.md:5
#, fuzzy
msgid "```rust,editable\nuse std::mem::{align_of, size_of};"
msgstr "```herrumbre, editable\nuse std::mem::{align_of, size_of};"

#: src/enums/sizes.md:8
#, fuzzy
msgid ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"
msgstr ""
"macro_reglas! tama√±o_dbg {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: tama√±o {} bytes, alineaci√≥n: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"

#: src/enums/sizes.md:15
#, fuzzy
msgid ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"
msgstr ""
"enumeraci√≥n Foo {\n"
"    A,\n"
"    B,\n"
"}"

#: src/enums/sizes.md:20
#, fuzzy
msgid ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"
msgstr ""
"#[repr(u32)]\n"
"barra de enumeraci√≥n {\n"
"    un, // 0\n"
"    B = 10000,\n"
"    c, // 10001\n"
"}"

#: src/enums/sizes.md:27
#, fuzzy
msgid ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    tama√±o_dbg!(Foo);\n"
"    tama√±o_dbg!(Barra);\n"
"    tama√±o_dbg!(bool);\n"
"    dbg_size!(Opci√≥n<bool>);\n"
"    tama√±o_dbg!(&i32);\n"
"    dbg_size!(Opci√≥n<&i32>);\n"
"}\n"
"```"

#: src/enums/sizes.md:37
#, fuzzy
msgid ""
"* See the [Rust "
"Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr ""
"* Consulte la [Referencia de Rust] "
"(https://doc.rust-lang.org/reference/type-layout.html)."

#: src/enums/sizes.md:39
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points: \n"
" * Internally Rust is using a field (discriminant) to keep track of the enum "
"variant.\n"
" * `Bar` enum demonstrates that there is a way to control the discriminant "
"value and type. If `repr` is removed, the discriminant type takes 2 bytes, "
"becuase 10001 fits 2 bytes.\n"
" * As a niche optimization an enum discriminant is merged with the pointer "
"so that `Option<&Foo>` is the same size as `&Foo`.\n"
" * `Option<bool>` is another example of tight packing.\n"
" * For [some types](https://doc.rust-lang.org/std/option/#representation), "
"Rust guarantees that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
" * Zero-sized types allow for efficient implementation of `HashSet` using "
"`HashMap` with `()` as the value."
msgstr ""
"<detalles>\n"
"    \n"
"Puntos clave:\n"
" * Internamente, Rust est√° usando un campo (discriminante) para realizar un "
"seguimiento de la variante de enumeraci√≥n.\n"
" * La enumeraci√≥n `Bar` demuestra que hay una forma de controlar el valor y "
"el tipo del discriminante. Si se elimina `repr`, el tipo discriminante ocupa "
"2 bytes, porque 10001 cabe en 2 bytes.\n"
" * Como optimizaci√≥n de nicho, un discriminante de enumeraci√≥n se fusiona "
"con el puntero para que `Option<&Foo>` tenga el mismo tama√±o que `&Foo`.\n"
" * `Option<bool>` es otro ejemplo de empaquetado ajustado.\n"
" * Para [algunos "
"tipos](https://doc.rust-lang.org/std/option/#representation), Rust garantiza "
"que `size_of::<T>()` es igual a `size_of::<Option<T> >()`.\n"
" * Los tipos de tama√±o cero permiten una implementaci√≥n eficiente de "
"`HashSet` utilizando `HashMap` con `()` como valor."

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an\n"
"`impl` block:"
msgstr ""
"Rust le permite asociar funciones con sus nuevos tipos. Haces esto con un\n"
"Bloque `impl`:"

#: src/methods.md:13
#, fuzzy
msgid ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Persona {\n"
"    fn decir_hola(&self) {\n"
"        println!(\"Hola, mi nombre es {}\", self.nombre);\n"
"    }\n"
"}"

#: src/methods.md:19
#, fuzzy
msgid ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let peter = Persona {\n"
"        nombre: String::from(\"Pedro\"),\n"
"        edad: 27,\n"
"    };\n"
"    peter.di_hola();\n"
"}\n"
"```"

#: src/methods.md:30
#, fuzzy
msgid ""
"Key Points:\n"
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), "
"the first parameter represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method "
"receiver syntax and to help keep them more organized. By using methods we "
"can keep all the implementation code in one predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show "
"how the struct name could also be used. \n"
"  * Explain that Self is a type alias for the type the `impl` block is in "
"and can be used elsewhere in the block.\n"
"  * Note how self is used like other structs and dot notation can be used to "
"refer to individual fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from "
"`self` by modifying the code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   \n"
"</details>"
msgstr ""
"Puntos clave:\n"
"* Puede ser √∫til presentar m√©todos compar√°ndolos con funciones.\n"
"  * Los m√©todos se llaman en una instancia de un tipo (como una estructura o "
"una enumeraci√≥n), el primer par√°metro representa la instancia como "
"\"auto\".\n"
"  * Los desarrolladores pueden optar por utilizar m√©todos para aprovechar la "
"sintaxis del receptor de m√©todos y ayudar a mantenerlos m√°s organizados. "
"Mediante el uso de m√©todos podemos mantener todo el c√≥digo de implementaci√≥n "
"en un lugar predecible.\n"
"* Se√±ale el uso de la palabra clave `self`, un m√©todo receptor.\n"
"  * Muestre que es un t√©rmino abreviado para `self:&Self` y tal vez muestre "
"c√≥mo tambi√©n podr√≠a usarse el nombre de la estructura.\n"
"  * Explique que Self es un alias de tipo para el tipo en el que se "
"encuentra el bloque `impl` y se puede usar en cualquier otra parte del "
"bloque.\n"
"  * Tenga en cuenta c√≥mo se usa self como otras estructuras y la notaci√≥n de "
"puntos se puede usar para referirse a campos individuales.\n"
"  * Este podr√≠a ser un buen momento para demostrar c√≥mo `&self` difiere de "
"`self` modificando el c√≥digo e intentando ejecutar say_hello dos veces.\n"
"* A continuaci√≥n describimos la distinci√≥n entre receptores de m√©todos.\n"
"   \n"
"</detalles>"

#: src/methods/receiver.md:1
#, fuzzy
msgid "# Method Receiver"
msgstr "# M√©todo Receptor"

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There\n"
"are other possible receivers for a method:"
msgstr ""
"El `&self` anterior indica que el m√©todo toma prestado el objeto de forma "
"inmutable. All√≠\n"
"son otros posibles receptores para un m√©todo:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and "
"mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. "
"The\n"
"  method becomes the owner of the object. The object will be dropped "
"(deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used "
"to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: toma prestado el objeto de la persona que llama usando un "
"compartido e inmutable\n"
"  referencia. El objeto se puede utilizar de nuevo despu√©s.\n"
"* `&mut self`: toma prestado el objeto de la persona que llama usando un "
"√∫nico y mutable\n"
"  referencia. El objeto se puede utilizar de nuevo despu√©s.\n"
"* `self`: toma posesi√≥n del objeto y lo aleja de la persona que llama. √âl\n"
"  m√©todo se convierte en el propietario del objeto. El objeto ser√° "
"descartado (desasignado)\n"
"  cuando el m√©todo regresa, a menos que su propiedad est√© expl√≠citamente\n"
"  transmitido.\n"
"* `mut self`: igual que arriba, pero mientras el m√©todo posee el objeto, "
"puede\n"
"  mutarlo tambi√©n. La propiedad completa no significa autom√°ticamente "
"mutabilidad.\n"
"* Sin receptor: esto se convierte en un m√©todo est√°tico en la estructura. "
"T√≠picamente usado para\n"
"  crear constructores que se llaman `nuevo` por convenci√≥n."

#: src/methods/receiver.md:19
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper "
"types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"M√°s all√° de las variantes de `self`, tambi√©n hay\n"
"[tipos de contenedores "
"especiales](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"pueden ser tipos de receptores, como `Box<Self>`."

#: src/methods/receiver.md:23
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"Consider emphasizing on \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It "
"won't be possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) "
"method on it.\n"
"  \n"
"</details>"
msgstr ""
"<detalles>\n"
"  \n"
"Considere enfatizar en \"compartido e inmutable\" y \"√∫nico y mutable\". "
"Estas limitaciones siempre vienen\n"
"juntos en Rust debido a las reglas del corrector de pr√©stamo, y `self` no es "
"una excepci√≥n. no sera posible\n"
"haga referencia a una estructura desde varias ubicaciones y llame a un "
"m√©todo de mutaci√≥n (`&mut self`) en ella.\n"
"  \n"
"</detalles>"

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
#, fuzzy
msgid "# Example"
msgstr "# Ejemplo"

#: src/methods/example.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"carrera de estructura {\n"
"    nombre: cadena,\n"
"    vueltas: Vec<i32>,\n"
"}"

#: src/methods/example.md:10
#, fuzzy
msgid ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"
msgstr ""
"Raza impl {\n"
"    fn new(name: &str) -> Race { // Sin receptor, un m√©todo est√°tico\n"
"        Carrera { nombre: String::from(name), vueltas: Vec::new() }\n"
"    }"

#: src/methods/example.md:15
#, fuzzy
msgid ""
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }"
msgstr ""
"    fn add_lap(&mut self, lap: i32) { // Acceso exclusivo prestado de "
"lectura y escritura a uno mismo\n"
"        self.laps.push(vuelta);\n"
"    }"

#: src/methods/example.md:19
#, fuzzy
msgid ""
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"
msgstr ""
"    fn print_laps(&self) { // Acceso prestado compartido y de solo lectura a "
"s√≠ mismo\n"
"        println!(\"Se registraron {} vueltas para {}:\", self.laps.len(), "
"self.name);\n"
"        para (idx, vuelta) en self.laps.iter().enumerate() {\n"
"            println!(\"Vuelta {idx}: {vuelta} seg\");\n"
"        }\n"
"    }"

#: src/methods/example.md:26
#, fuzzy
msgid ""
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}"
msgstr ""
"    fn finish(self) { // Propiedad exclusiva de uno mismo\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Carrera {} finalizada, tiempo total de vuelta: {}\", "
"self.name, total);\n"
"    }\n"
"}"

#: src/methods/example.md:32
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let mut race = Race::new(\"Gran Premio de M√≥naco\");\n"
"    carrera.add_lap(70);\n"
"    carrera.add_lap(68);\n"
"    carrera.print_laps();\n"
"    carrera.add_lap(71);\n"
"    carrera.print_laps();\n"
"    carrera.terminar();\n"
"    // carrera.add_lap(42);\n"
"}\n"
"```"

#: src/methods/example.md:44
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` "
"twice.\n"
"* Note, that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"<detalles>\n"
"    \n"
"Puntos clave:\n"
"* Los cuatro m√©todos aqu√≠ usan un receptor de m√©todo diferente.\n"
"  * Puede se√±alar c√≥mo eso cambia lo que la funci√≥n puede hacer con los "
"valores de las variables y si/c√≥mo se puede usar nuevamente en `main`.\n"
"  * Puede mostrar el error que aparece al intentar llamar a `finish` dos "
"veces.\n"
"* Tenga en cuenta que, aunque los receptores de m√©todos son diferentes, las "
"funciones no est√°ticas se denominan de la misma manera en el cuerpo "
"principal. Rust permite la referencia y la desreferenciaci√≥n autom√°ticas al "
"llamar a m√©todos. Rust agrega autom√°ticamente `&`, `*`, `muts` para que ese "
"objeto coincida con la firma del m√©todo.\n"
"* Puede se√±alar que `print_laps` est√° usando un vector que se itera. "
"Describiremos los vectores con m√°s detalle en la tarde."

#: src/pattern-matching.md:1
#, fuzzy
msgid "# Pattern Matching"
msgstr "# La coincidencia de patrones"

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"La palabra clave `match` le permite hacer coincidir un valor con uno o m√°s "
"_patrones_. √âl\n"
"las comparaciones se hacen de arriba hacia abajo y gana el primero."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Los patrones pueden ser valores simples, similar a `switch` en C y C++:"

#: src/pattern-matching.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    dejar entrada = 'x';"

#: src/pattern-matching.md:12
#, fuzzy
msgid ""
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    entrada de coincidencia {\n"
"        'q' => println!(\"Saliendo\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Movi√©ndose\"),\n"
"        '0'..='9' => println!(\"Entrada de n√∫mero\"),\n"
"        _ => println!(\"Algo m√°s\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "El patr√≥n `_` es un patr√≥n comod√≠n que coincide con cualquier valor."

#: src/pattern-matching.md:23
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* You might point out how some specific characters are being used when in a "
"patten\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages.\n"
"   \n"
"</details>"
msgstr ""
"<detalles>\n"
"    \n"
"Puntos clave:\n"
"* Puede se√±alar c√≥mo se utilizan algunos caracteres espec√≠ficos en un "
"patr√≥n\n"
"  * `|` como un `o`\n"
"  * `..` puede expandirse tanto como sea necesario\n"
"  * `1..=5` representa un rango inclusivo\n"
"  * `_` es un comod√≠n\n"
"* Puede ser √∫til para mostrar c√≥mo funciona el enlace, por ejemplo, "
"reemplazando un car√°cter comod√≠n con una variable, o eliminando las comillas "
"alrededor de `q`.\n"
"* Puede demostrar la coincidencia en una referencia.\n"
"* Este podr√≠a ser un buen momento para mencionar el concepto de patrones "
"irrefutables, ya que el t√©rmino puede aparecer en los mensajes de error.\n"
"   \n"
"</detalles>"

#: src/pattern-matching/destructuring-enums.md:1
#, fuzzy
msgid "# Destructuring Enums"
msgstr "# Desestructuraci√≥n de enumeraciones"

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how\n"
"you inspect the structure of your types. Let us start with a simple `enum` "
"type:"
msgstr ""
"Los patrones tambi√©n se pueden usar para vincular variables a partes de sus "
"valores. As√≠ es como\n"
"usted inspecciona la estructura de sus tipos. Empecemos con un simple tipo "
"`enum`:"

#: src/pattern-matching/destructuring-enums.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"resultado de la enumeraci√≥n {\n"
"    Bien (i32),\n"
"    Err(Cadena),\n"
"}"

#: src/pattern-matching/destructuring-enums.md:12
#, fuzzy
msgid ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {} into two equal parts\", n))\n"
"    }\n"
"}"
msgstr ""
"fn dividir_en_dos(n: i32) -> Resultado {\n"
"    si n % 2 == 0 {\n"
"        Resultado::Ok(n/2)\n"
"    } m√°s {\n"
"        Resultado::Err(formato!(\"no se puede dividir {} en dos partes "
"iguales\", n))\n"
"    }\n"
"}"

#: src/pattern-matching/destructuring-enums.md:20
#, fuzzy
msgid ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea n = 100;\n"
"    partido divide_en_dos (n) {\n"
"        Resultado::Ok(mitad) => println!(\"{n} dividido en dos es "
"{mitad}\"),\n"
"        Resultado::Err(mensaje) => println!(\"lo siento, ocurri√≥ un error: "
"{mensaje}\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the "
"first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Aqu√≠ hemos usado los brazos para _desestructurar_ el valor `Resultado`. En "
"el primero\n"
"arm, `half` est√° vinculado al valor dentro de la variante `Ok`. En el "
"segundo brazo,\n"
"`msg` est√° ligado al mensaje de error."

#: src/pattern-matching/destructuring-enums.md:35
#, fuzzy
msgid ""
"Key points:\n"
"* The `if`/`else` expression is returning an enum that is later unpacked "
"with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying "
"the errors when running the code. Point out the places where your code is "
"now inexhaustive and how the compiler trys to give you hints."
msgstr ""
"Puntos clave:\n"
"* La expresi√≥n `if`/`else` devuelve una enumeraci√≥n que luego se "
"desempaqueta con una `coincidencia`.\n"
"* Puede intentar agregar una tercera variante a la definici√≥n de enumeraci√≥n "
"y mostrar los errores al ejecutar el c√≥digo. Se√±ale los lugares donde su "
"c√≥digo ahora es inexhaustivo y c√≥mo el compilador intenta darle pistas."

#: src/pattern-matching/destructuring-structs.md:1
#, fuzzy
msgid "# Destructuring Structs"
msgstr "# Estructuras destructivas"

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Tambi√©n puedes desestructurar `estructuras`:"

#: src/pattern-matching/destructuring-structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"estructura Foo {\n"
"    x: (u32, u32),\n"
"    y:u32,\n"
"}"

#: src/pattern-matching/destructuring-structs.md:11
#, fuzzy
msgid ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, i = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"#[rustfmt::saltar]\n"
"fn principal() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    partido foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i } => println!(\"y = 2, i = {i:?}\"),\n"
"        Foo { y, .. } => println!(\"y = {y}, se ignoraron otros campos\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:1
#, fuzzy
msgid "# Destructuring Arrays"
msgstr "# Destrucci√≥n de arreglos"

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr ""
"Puede desestructurar matrices, tuplas y segmentos haciendo coincidir sus "
"elementos:"

#: src/pattern-matching/destructuring-arrays.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"#[rustfmt::saltar]\n"
"fn principal() {\n"
"    sea triple = [0, -2, 3];\n"
"    println!(\"H√°blame de {triple:?}\");\n"
"    partido triple {\n"
"        [0, y, z] => println!(\"Primero es 0, y = {y} y z = {z}\"),\n"
"        [1, ..] => println!(\"Primero es 1 y el resto fueron ignorados\"),\n"
"        _ => println!(\"Todos los elementos fueron ignorados\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:1
#, fuzzy
msgid "# Match Guards"
msgstr "# Guardias de partido"

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Al hacer coincidir, puede agregar un _guardia_ a un patr√≥n. Este es un "
"booleano arbitrario\n"
"expresi√≥n que se ejecutar√° si el patr√≥n coincide:"

#: src/pattern-matching/match-guards.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"#[rustfmt::saltar]\n"
"fn principal() {\n"
"    sea par = (2, -2);\n"
"    println!(\"H√°blame de {par:?}\");\n"
"    emparejar par {\n"
"        (x, y) if x == y => println!(\"Estos son gemelos\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimateria, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"El primero es impar\"),\n"
"        _ => println!(\"Sin correlaci√≥n...\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:22
#, fuzzy
msgid ""
"Key Points:\n"
"* Match guards as a separate syntax feature are important and necessary.\n"
"* They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a "
"pattern with an `|`.\n"
"</details>"
msgstr ""
"Puntos clave:\n"
"* Las protecciones de coincidencia como caracter√≠stica de sintaxis "
"independiente son importantes y necesarias.\n"
"* No son lo mismo que la expresi√≥n `if` separada dentro del brazo de "
"coincidencia. Una expresi√≥n `if` dentro del bloque de bifurcaci√≥n (despu√©s "
"de `=>`) ocurre despu√©s de que se selecciona el brazo de coincidencia. "
"Fallar la condici√≥n `si` dentro de ese bloque no dar√° como resultado otros "
"brazos\n"
"de la expresi√≥n `coincidencia` original que se est√° considerando.\n"
"* Puede usar las variables definidas en el patr√≥n en su expresi√≥n if.\n"
"* La condici√≥n definida en el guard se aplica a cada expresi√≥n en un patr√≥n "
"con `|`.\n"
"</detalles>"

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "# Day 2: Morning Exercises"
msgstr "# D√≠a 2: Ejercicios Matutinos"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Veremos la implementaci√≥n de m√©todos en dos contextos:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid "* Simple struct which tracks health statistics."
msgstr "* Estructura simple que rastrea las estad√≠sticas de salud."

#: src/exercises/day-2/morning.md:7
#, fuzzy
msgid "* Multiple structs and enums for a drawing library."
msgstr "* M√∫ltiples estructuras y enumeraciones para una biblioteca de dibujos."

#: src/exercises/day-2/health-statistics.md:1
#, fuzzy
msgid "# Health Statistics"
msgstr "# Estad√≠sticas de Salud"

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you\n"
"need to keep track of users' health statistics."
msgstr ""
"Est√° trabajando en la implementaci√≥n de un sistema de control de la salud. "
"Como parte de eso, usted\n"
"necesidad de realizar un seguimiento de las estad√≠sticas de salud de los "
"usuarios."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Comenzar√° con algunas funciones a√±adidas en un bloque `impl` as√≠ como un "
"`Usuario`\n"
"definici√≥n de estructura. Su objetivo es implementar los m√©todos stubed out "
"en el\n"
"`Usuario` `estructura` definida en el bloque `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:"
msgstr ""
"Copie el c√≥digo a continuaci√≥n a <https://play.rust-lang.org/> y rellene lo "
"que falta\n"
"m√©todos:"

#: src/exercises/day-2/health-statistics.md:17
#, fuzzy
msgid ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"
msgstr ""
"usuario de estructura {\n"
"    nombre: cadena,\n"
"    edad: u32,\n"
"    peso: f32,\n"
"}"

#: src/exercises/day-2/health-statistics.md:23
#, fuzzy
msgid ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"usuario impl {\n"
"    pub fn new(nombre: String, edad: u32, peso: f32) -> Self {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:28
#, fuzzy
msgid ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn nombre(&self) -> &str {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:32
#, fuzzy
msgid ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn age(&self) -> u32 {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:36
#, fuzzy
msgid ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn peso(&self) -> f32 {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:40
#, fuzzy
msgid ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:44
#, fuzzy
msgid ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        sin implementar!()\n"
"    }\n"
"}"

#: src/exercises/day-2/health-statistics.md:49
#, fuzzy
msgid ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}"
msgstr ""
"fn principal() {\n"
"    let bob = Usuario::nuevo(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Soy {} y mi edad es {}\", bob.nombre(), bob.edad());\n"
"}"

#: src/exercises/day-2/health-statistics.md:54
#, fuzzy
msgid ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"
msgstr ""
"#[prueba]\n"
"fn prueba_peso() {\n"
"    let bob = Usuario::nuevo(String::from(\"Bob\"), 32, 155.2);\n"
"    afirmar_eq!(bob.peso(), 155.2);\n"
"}"

#: src/exercises/day-2/health-statistics.md:60
#, fuzzy
msgid ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""
"#[prueba]\n"
"fn test_set_edad() {\n"
"    let mut bob = Usuario::nuevo(String::from(\"Bob\"), 32, 155.2);\n"
"    afirmar_eq!(bob.edad(), 32);\n"
"    bob.set_age(33);\n"
"    afirmar_eq!(bob.edad(), 33);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:1
#, fuzzy
msgid "# Polygon Struct"
msgstr "# Estructura poligonal"

#: src/exercises/day-2/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make "
"the\n"
"tests pass:"
msgstr ""
"Crearemos una estructura `Pol√≠gono` que contenga algunos puntos. Copie el "
"c√≥digo de abajo\n"
"a <https://play.rust-lang.org/> y complete los m√©todos que faltan para hacer "
"el\n"
"pasan las pruebas:"

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23
#: src/exercises/day-2/strings-iterators.md:12
#, fuzzy
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```herrumbre\n"
"// TODO: elimine esto cuando haya terminado con su implementaci√≥n.\n"
"#![permitir(variables_no_usadas, c√≥digo_muerto)]"

#: src/exercises/day-2/points-polygons.md:11
#, fuzzy
msgid ""
"pub struct Point {\n"
"    // add fields\n"
"}"
msgstr ""
"pub punto de estructura {\n"
"    // agregar campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:15
#, fuzzy
msgid ""
"impl Point {\n"
"    // add methods\n"
"}"
msgstr ""
"punto impl {\n"
"    // agregar m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:19
#, fuzzy
msgid ""
"pub struct Polygon {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Pol√≠gono {\n"
"    // agregar campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:23
#, fuzzy
msgid ""
"impl Polygon {\n"
"    // add methods\n"
"}"
msgstr ""
"pol√≠gono impl {\n"
"    // agregar m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:27
#, fuzzy
msgid ""
"pub struct Circle {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Circulo {\n"
"    // agregar campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:31
#, fuzzy
msgid ""
"impl Circle {\n"
"    // add methods\n"
"}"
msgstr ""
"c√≠rculo impl {\n"
"    // agregar m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:35
#, fuzzy
msgid ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"
msgstr ""
"pub enum Forma {\n"
"    Pol√≠gono(Pol√≠gono),\n"
"    C√≠rculo (C√≠rculo),\n"
"}"

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
#, fuzzy
msgid ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"#[cfg(prueba)]\n"
"pruebas de modificaci√≥n {\n"
"    usar super::*;"

#: src/exercises/day-2/points-polygons.md:44
#: src/exercises/day-2/solutions-morning.md:165
#, fuzzy
msgid ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"
msgstr ""
"    fn ronda_dos_d√≠gitos(x: f64) -> f64 {\n"
"        (x * 100.0).redondo() / 100.0\n"
"    }"

#: src/exercises/day-2/points-polygons.md:48
#: src/exercises/day-2/solutions-morning.md:169
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"
msgstr ""
"    #[prueba]\n"
"    fn test_point_magnitude() {\n"
"        sea p1 = Punto::nuevo(12, 13);\n"
"        afirmar_eq!(ronda_dos_d√≠gitos(p1.magnitud()), 17.69);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:54
#: src/exercises/day-2/solutions-morning.md:175
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"
msgstr ""
"    #[prueba]\n"
"    fn test_point_dist() {\n"
"        let p1 = Punto::nuevo(10, 10);\n"
"        sea p2 = Punto::nuevo(14, 13);\n"
"        afirmar_eq!(redondear_dos_d√≠gitos(p1.dist(p2)), 5.00);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:61
#: src/exercises/day-2/solutions-morning.md:182
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"
msgstr ""
"    #[prueba]\n"
"    fn test_point_add() {\n"
"        sea p1 = Punto::nuevo(16, 16);\n"
"        sea p2 = p1 + Punto::nuevo(-4, 3);\n"
"        afirmar_eq!(p2, Punto::nuevo(12, 19));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:68
#: src/exercises/day-2/solutions-morning.md:189
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[prueba]\n"
"    fn test_polygon_left_most_point() {\n"
"        sea p1 = Punto::nuevo(12, 13);\n"
"        sea p2 = Punto::nuevo(16, 16);"

#: src/exercises/day-2/points-polygons.md:73
#: src/exercises/day-2/solutions-morning.md:194
#, fuzzy
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"
msgstr ""
"        let mut poli = Pol√≠gono::nuevo();\n"
"        poli.agregar_punto(p1);\n"
"        poli.agregar_punto(p2);\n"
"        afirmar_eq!(poly.left_most_point(), Some(p1));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:79
#: src/exercises/day-2/solutions-morning.md:200
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[prueba]\n"
"    fn test_polygon_iter() {\n"
"        sea p1 = Punto::nuevo(12, 13);\n"
"        sea p2 = Punto::nuevo(16, 16);"

#: src/exercises/day-2/points-polygons.md:84
#: src/exercises/day-2/solutions-morning.md:205
#, fuzzy
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"
msgstr ""
"        let mut poli = Pol√≠gono::nuevo();\n"
"        poli.agregar_punto(p1);\n"
"        poli.agregar_punto(p2);"

#: src/exercises/day-2/points-polygons.md:88
#: src/exercises/day-2/solutions-morning.md:209
#, fuzzy
msgid ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"
msgstr ""
"        let puntos = poly.iter().cloned().collect::<Vec<_>>();\n"
"        afirmar_eq!(puntos, vec![Punto::nuevo(12, 13), Punto::nuevo(16, "
"16)]);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:92
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"
msgstr ""
"    #[prueba]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poli = Pol√≠gono::nuevo();\n"
"        poly.add_point(Punto::nuevo(12, 13));\n"
"        poly.add_point(Punto::nuevo(17, 11));\n"
"        poly.add_point(Punto::nuevo(16, 16));\n"
"        let formas = vec![\n"
"            Forma::de (poli),\n"
"            Forma::desde(C√≠rculo::nuevo(Punto::nuevo(10, 20), 5)),\n"
"        ];\n"
"        sea per√≠metros = formas\n"
"            .iter()\n"
"            .map(Forma::per√≠metro)\n"
"            .mapa(ronda_dos_d√≠gitos)\n"
"            .recoger::<Vec<_>>();\n"
"        afirmar_eq!(per√≠metros, vec![15.48, 31.42]);\n"
"    }\n"
"}"

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
#: src/exercises/day-2/solutions-morning.md:233
#, fuzzy
msgid ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"#[permitir(c√≥digo_muerto)]\n"
"fnprincipal() {}\n"
"```"

#: src/exercises/day-2/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part\n"
"of the exercise is to specify those correctly."
msgstr ""
"Dado que las firmas del m√©todo faltan en las declaraciones del problema, la "
"parte clave\n"
"del ejercicio es especificarlas correctamente."

#: src/exercises/day-2/points-polygons.md:120
#, fuzzy
msgid ""
"Other interesting parts of the exercise:\n"
"    \n"
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be "
"addable via \"+\".    "
msgstr ""
"Otras partes interesantes del ejercicio:\n"
"    \n"
"* Derivar un rasgo `Copiar` para algunas estructuras, ya que en las pruebas "
"los m√©todos a veces no toman prestados sus argumentos.\n"
"* Descubra que el rasgo `Add` debe implementarse para que dos objetos se "
"puedan agregar a trav√©s de \"+\"."

#: src/control-flow.md:1
#, fuzzy
msgid "# Control Flow"
msgstr "# Flujo de control"

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes\n"
"the value of the `if` expression. Other control flow expressions work "
"similarly\n"
"in Rust."
msgstr ""
"Como hemos visto, `if` es una expresi√≥n en Rust. Se utiliza para "
"condicionalmente\n"
"evaluar uno de dos bloques, pero los bloques pueden tener un valor que luego "
"se convierte en\n"
"el valor de la expresi√≥n `si`. Otras expresiones de flujo de control "
"funcionan de manera similar\n"
"en √≥xido."

#: src/control-flow/blocks.md:1
#, fuzzy
msgid "# Blocks"
msgstr "# Bloques"

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust has a value and a type: the value is the last expression of "
"the\n"
"block:"
msgstr ""
"Un bloque en Rust tiene un valor y un tipo: el valor es la √∫ltima expresi√≥n "
"del\n"
"bloquear:"

#: src/control-flow/blocks.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea x = {\n"
"        sea y = 10;\n"
"        println!(\"y: {y}\");\n"
"        sea z = {\n"
"            sea w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        imprimir!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    imprimir!(\"x: {x}\");\n"
"}\n"
"```"

#: src/control-flow/blocks.md:25
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"La misma regla se usa para las funciones: el valor del cuerpo de la funci√≥n "
"es el\n"
"valor de retorno:"

#: src/control-flow/blocks.md:28
#, fuzzy
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn doble(x: i32) -> i32 {\n"
"    x + x\n"
"}"

#: src/control-flow/blocks.md:33
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    println!(\"duplicado: {}\", doble(7));\n"
"}\n"
"```"

#: src/control-flow/blocks.md:38
#, fuzzy
msgid ""
"However if the last expression ends with `;`, then the resulting value and "
"type is `()`."
msgstr ""
"Sin embargo, si la √∫ltima expresi√≥n termina con `;`, entonces el valor y el "
"tipo resultantes son `()`."

#: src/control-flow/blocks.md:42
#, fuzzy
msgid ""
"Key Points:\n"
"* The point of this slide is to show that blocks have a type and value in "
"Rust. \n"
"* You can show how the value of the block changes by changing the last line "
"in the block. For instance, adding/removing a semicolon or using a "
"`return`.\n"
"   \n"
"</details>"
msgstr ""
"Puntos clave:\n"
"* El objetivo de esta diapositiva es mostrar que los bloques tienen un tipo "
"y un valor en Rust.\n"
"* Puede mostrar c√≥mo cambia el valor del bloque cambiando la √∫ltima l√≠nea "
"del bloque. Por ejemplo, agregar/eliminar un punto y coma o usar un "
"`retorno`.\n"
"   \n"
"</detalles>"

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "# `if` expressions"
msgstr "# Expresiones `si`"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "Usas `if` de manera muy similar a como lo har√≠as en otros idiomas:"

#: src/control-flow/if-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut x = 10;\n"
"    si x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } m√°s {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:16
#, fuzzy
msgid ""
"In addition, you can use it as an expression. This does the same as above:"
msgstr "Adem√°s, puedes usarlo como una expresi√≥n. Esto hace lo mismo que arriba:"

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut x = 10;\n"
"    x = si x % 2 == 0 {\n"
"        x / 2\n"
"    } m√°s {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:31
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example.\n"
"    \n"
"</details>"
msgstr ""
"Debido a que `if` es una expresi√≥n y debe tener un tipo particular, sus dos "
"bloques de rama deben tener el mismo tipo. Considere mostrar lo que sucede "
"si agrega `;` despu√©s de `x / 2` en el segundo ejemplo.\n"
"    \n"
"</detalles>"

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "# `if let` expressions"
msgstr "# expresiones `if let`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "Si desea hacer coincidir un valor con un patr√≥n, puede usar `if let`:"

#: src/control-flow/if-let-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let arg = std::env::args().next();\n"
"    si dejar Algunos (valor) = arg {\n"
"        println!(\"Nombre del programa: {valor}\");\n"
"    } m√°s {\n"
"        println!(\"¬øFalta el nombre?\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-let-expressions.md:16
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in\n"
"Rust."
msgstr ""
"Consulte [coincidencia de patrones](../pattern-matching.md) para obtener m√°s "
"detalles sobre patrones en\n"
"√ìxido."

#: src/control-flow/if-let-expressions.md:21
#, fuzzy
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is "
"interesting. In contrast, `match` requires all branches to be covered.\n"
"    * For the similar use case consider demonstrating a newly stabilized "
"[`let else`](https://github.com/rust-lang/rust/pull/93628) feature.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern "
"matching."
msgstr ""
"* `if let` puede ser m√°s conciso que `match`, por ejemplo, cuando solo un "
"caso es interesante. Por el contrario, `match` requiere que se cubran todas "
"las ramas.\n"
"    * Para el caso de uso similar, considere demostrar una funci√≥n [`let "
"else`](https://github.com/rust-lang/rust/pull/93628) recientemente "
"estabilizada.\n"
"* Un uso com√∫n es manejar valores `Algunos` cuando se trabaja con `Opci√≥n`.\n"
"* A diferencia de `match`, `if let` no admite cl√°usulas de protecci√≥n para "
"la coincidencia de patrones."

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "# `while` expressions"
msgstr "# Expresiones `while`"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid "The `while` keyword works very similar to other languages:"
msgstr "La palabra clave `while` funciona de manera muy similar a otros idiomas:"

#: src/control-flow/while-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut x = 10;\n"
"    mientras que x != 1 {\n"
"        x = si x % 2 == 0 {\n"
"            x / 2\n"
"        } m√°s {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"X final: {x}\");\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "# `while let` expressions"
msgstr "# expresiones `while let`"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a "
"value\n"
"against a pattern:"
msgstr ""
"Al igual que con `if`, hay una variante `while let` que prueba repetidamente "
"un valor\n"
"contra un patr√≥n:"

#: src/control-flow/while-let-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"

#: src/control-flow/while-let-expressions.md:11
#, fuzzy
msgid ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    while let Some(x) = iter.next() {\n"
"        imprimir!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on "
"every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it "
"will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Aqu√≠ el iterador devuelto por `v.iter()` devolver√° una `Option<i32>` en "
"cada\n"
"llamar a `siguiente()`. Devuelve `Algunos (x)` hasta que se hace, despu√©s de "
"lo cual se\n"
"devuelve `Ninguno`. El `while let` nos permite seguir iterando a trav√©s de "
"todos los elementos."

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"* Point out that the `while let` loop will keep going as long as the value "
"matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario.\n"
"    \n"
"</details>"
msgstr ""
"* Se√±ale que el bucle `while let` continuar√° mientras el valor coincida con "
"el patr√≥n.\n"
"* Podr√≠a reescribir el bucle `while let` como un bucle infinito con una "
"declaraci√≥n if que se rompe cuando no hay ning√∫n valor para desenvolver para "
"`iter.next()`. El `while let` proporciona az√∫car sint√°ctico para el "
"escenario anterior.\n"
"    \n"
"</detalles>"

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "# `for` expressions"
msgstr "# Expresiones `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The `for` expression is closely related to the `while let` expression. It "
"will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"La expresi√≥n `for` est√° estrechamente relacionada con la expresi√≥n `while "
"let`. Va a\n"
"llama autom√°ticamente a `into_iter()` en la expresi√≥n y luego itera sobre "
"ella:"

#: src/control-flow/for-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea v = vec![10, 20, 30];"

#: src/control-flow/for-expressions.md:10
#, fuzzy
msgid ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    para x en v {\n"
"        imprimir!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    para i en (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/for-expressions.md:20
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Puede usar `break` y `continue` aqu√≠ como de costumbre."

#: src/control-flow/for-expressions.md:22
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every "
"other element. \n"
"    \n"
"</details>"
msgstr ""
"<detalles>\n"
"    \n"
"* La iteraci√≥n de √≠ndice no es una sintaxis especial en Rust solo para ese "
"caso.\n"
"* `(0..10)` es un rango que implementa un rasgo `Iterator`.\n"
"* `step_by` es un m√©todo que devuelve otro `Iterator` que salta todos los "
"dem√°s elementos.\n"
"    \n"
"</detalles>"

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "# `loop` expressions"
msgstr "# Expresiones `bucle`"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you "
"must\n"
"either `break` or `return` to stop the loop:"
msgstr ""
"Finalmente, hay una palabra clave `loop` que crea un bucle sin fin. Aqu√≠ "
"debes\n"
"ya sea `break` o `return` para detener el bucle:"

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut x = 10;\n"
"    c√≠rculo {\n"
"        x = si x % 2 == 0 {\n"
"            x / 2\n"
"        } m√°s {\n"
"            3 * x + 1\n"
"        };\n"
"        si x == 1 {\n"
"            descanso;\n"
"        }\n"
"    }\n"
"    println!(\"X final: {x}\");\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "# `match` expressions"
msgstr "# expresiones `match`"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The `match` keyword is used to match a value against one or more patterns. "
"In\n"
"that sense, it works like a series of `if let` expressions:"
msgstr ""
"La palabra clave `match` se utiliza para hacer coincidir un valor con uno o "
"m√°s patrones. En\n"
"En ese sentido, funciona como una serie de expresiones `if let`:"

#: src/control-flow/match-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    coincide con std::env::args().next().as_deref() {\n"
"        Some(\"gato\") => println!(\"Har√° cosas de gato\"),\n"
"        Some(\"ls\") => println!(\"Se buscar√°n algunos archivos\"),\n"
"        Some(\"mv\") => println!(\"Movamos algunos archivos\"),\n"
"        Some(\"rm\") => println!(\"Uh, ¬°peligroso!\"),\n"
"        Ninguno => println!(\"Hmm, ¬øno hay nombre de programa?\"),\n"
"        _ => println!(\"¬°Nombre de programa desconocido!\"),\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:19
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Al igual que `if let`, cada brazo de coincidencia debe tener el mismo tipo. "
"El tipo es el √∫ltimo.\n"
"expresi√≥n del bloque, si lo hubiere. En el ejemplo anterior, el tipo es `()`."

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "# `break` and `continue`"
msgstr "# `romper` y `continuar`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately "
"start\n"
"the next iteration use `continue`. Both `continue` and `break` can "
"optionally\n"
"take a label argument which is used to break out of nested loops:"
msgstr ""
"Si desea salir de un bucle antes de tiempo, use `break`, si desea comenzar "
"de inmediato\n"
"la siguiente iteraci√≥n usa `continuar`. Tanto `continue` como `break` pueden "
"opcionalmente\n"
"tome un argumento de etiqueta que se usa para salir de los bucles anidados:"

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'exterior: while let Some(x) = iter.next() {\n"
"        imprimir!(\"x: {x}\");\n"
"        sea mut i = 0;\n"
"        mientras que yo < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            yo += 1;\n"
"            si yo == 3 {\n"
"                romper 'exterior;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/break-continue.md:25
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"En este caso, rompemos el ciclo externo despu√©s de 3 iteraciones del ciclo "
"interno."

#: src/std.md:1
#, fuzzy
msgid "# Standard Library"
msgstr "# Biblioteca est√°ndar"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types\n"
"used by Rust library and programs. This way, two libraries can work "
"together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust viene con una biblioteca est√°ndar que ayuda a establecer un conjunto de "
"tipos comunes\n"
"utilizado por la biblioteca y los programas de Rust. De esta manera, dos "
"bibliotecas pueden trabajar juntas.\n"
"sin problemas porque ambos usan el mismo tipo `String`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "Los tipos de vocabulario comunes incluyen:"

#: src/std.md:9
#, fuzzy
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional "
"values\n"
"  and [error handling](error-handling.md)."
msgstr ""
"* Tipos [`Option` y `Result`](std/option-result.md): usados para valores "
"opcionales\n"
"  y [manejo de errores](manejo de errores.md)."

#: src/std.md:12
#, fuzzy
msgid "* [`String`](std/string.md): the default string type used for owned data."
msgstr ""
"* [`String`](std/string.md): el tipo de cadena predeterminado que se usa "
"para los datos propios."

#: src/std.md:14
#, fuzzy
msgid "* [`Vec`](std/vec.md): a standard extensible vector."
msgstr "* [`Vec`](std/vec.md): un vector extensible est√°ndar."

#: src/std.md:16
#, fuzzy
msgid ""
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm."
msgstr ""
"* [`HashMap`](std/hashmap.md): un tipo de mapa hash con un hashing "
"configurable\n"
"  algoritmo."

#: src/std.md:19
#, fuzzy
msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr ""
"* [`Box`](std/box.md): un puntero propio para datos asignados al "
"almacenamiento din√°mico."

#: src/std.md:21
#, fuzzy
msgid ""
"* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"* [`Rc`](std/rc.md): un puntero de conteo de referencia compartido para "
"datos asignados al almacenamiento din√°mico."

#: src/std.md:23
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"  * In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as "
"`Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"<detalles>\n"
"  \n"
"  * De hecho, Rust contiene varias capas de la biblioteca est√°ndar: `core`, "
"`alloc` y `std`.\n"
"  * `core` incluye los tipos y funciones m√°s b√°sicos que no dependen de "
"`libc`, allocator o\n"
"    incluso la presencia de un sistema operativo.\n"
"  * `alloc` incluye tipos que requieren un asignador de mont√≥n global, como "
"`Vec`, `Box` y `Arc`.\n"
"  * Las aplicaciones integradas de Rust a menudo solo usan `core` y, a "
"veces, `alloc`."

#: src/std/option-result.md:1
#, fuzzy
msgid "# `Option` and `Result`"
msgstr "# `Opci√≥n` y `Resultado`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "Los tipos representan datos opcionales:"

#: src/std/option-result.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let numeros = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numeros.primero();\n"
"    println!(\"primero: {primero:?}\");"

#: src/std/option-result.md:11
#, fuzzy
msgid ""
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""
"    let idx: Result<usar tama√±o, usar tama√±o> = n√∫meros.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"

#: src/std/option-result.md:18
#, fuzzy
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see "
"on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should "
"be inserted."
msgstr ""
"* `Opci√≥n` y `Resultado` son ampliamente utilizados no solo en la biblioteca "
"est√°ndar.\n"
"* `Option<&T>` tiene una sobrecarga de espacio cero en comparaci√≥n con "
"`&T`.\n"
"* `Resultado` es el tipo est√°ndar para implementar el manejo de errores como "
"veremos en el d√≠a 3.\n"
"* `binary_search` devuelve `Resultado<usar tama√±o, usar tama√±o>`.\n"
"  * Si se encuentra, `Resultado::Ok` contiene el √≠ndice donde se encuentra "
"el elemento.\n"
"  * De lo contrario, `Result::Err` contiene el √≠ndice donde se debe insertar "
"dicho elemento."

#: src/std/string.md:1
#, fuzzy
msgid "# String"
msgstr "# Cuerda"

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`][1] es el b√∫fer de cadenas UTF-8 est√°ndar asignado al "
"almacenamiento din√°mico:"

#: src/std/string.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hola\");\n"
"    println!(\"s1: len = {}, capacidad = {}\", s1.len(), s1.capacidad());"

#: src/std/string.md:11
#, fuzzy
msgid ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
msgstr ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacidad = {}\", s2.len(), s2.capacidad());"

#: src/std/string.md:16
#, fuzzy
msgid ""
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, n√∫mero de caracteres = {}\", s3.len(),\n"
"             s3.caracteres().cuenta());\n"
"}\n"
"```"

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can "
"call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementa [`Deref<Target = str>`][2], lo que significa que puede "
"llamar a todos\n"
"M√©todos `str` en una `String`."

#: src/std/string.md:25
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: "
"https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
msgstr ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: "
"https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"

#: src/std/string.md:30
#, fuzzy
msgid ""
"* `len` returns the size of the `String` in bytes, not its length in "
"characters.\n"
"* `chars` returns an iterator over the actual characters.\n"
"* `String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"* `len` devuelve el tama√±o de `String` en bytes, no su longitud en "
"caracteres.\n"
"* `chars` devuelve un iterador sobre los caracteres reales.\n"
"* `String` implementa `Deref<Target = str>` que le da acceso transparente a "
"los m√©todos de `str`."

#: src/std/vec.md:1
#, fuzzy
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] es el b√∫fer est√°ndar asignado al mont√≥n de tama√±o variable:"

#: src/std/vec.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacidad = {}\", v1.len(), v1.capacidad());"

#: src/std/vec.md:11
#, fuzzy
msgid ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"}\n"
"```"
msgstr ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extender(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacidad = {}\", v2.len(), v2.capacidad());\n"
"}\n"
"```"

#: src/std/vec.md:18
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call "
"slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`][2], lo que significa que puede "
"llamar a slice\n"
"m√©todos en un `Vec`."

#: src/std/vec.md:21
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
msgstr ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"

#: src/std/vec.md:24
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at "
"compile time. It can grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify "
"`T` explicitly. As always\n"
"  with Rust type inference, the `T` was established during the first `push` "
"call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial\n"
"  elements to the vector. \n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last "
"element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""
"<detalles>\n"
"    \n"
"* `Vec` es un tipo de colecci√≥n, junto con `String` y `HashMap`. Los datos "
"que contiene se almacenan\n"
"  en el mont√≥n Esto significa que no es necesario conocer la cantidad de "
"datos en el momento de la compilaci√≥n. puede crecer\n"
"  o reducir en tiempo de ejecuci√≥n.\n"
"* Observe c√≥mo `Vec<T>` tambi√©n es un tipo gen√©rico, pero no tiene que "
"especificar `T` expl√≠citamente. Como siempre\n"
"  con la inferencia de tipo Rust, la `T` se estableci√≥ durante la primera "
"llamada `push`.\n"
"* `vec![...]` es una macro can√≥nica para usar en lugar de `Vec::new()` y "
"admite agregar inicial\n"
"  elementos al vector.\n"
"* Para indexar el vector, usa `[` `]`, pero entrar√°n en p√°nico si est√°n "
"fuera de los l√≠mites. Alternativamente, usando\n"
"  `get` devolver√° una `Opci√≥n`. La funci√≥n `pop` eliminar√° el √∫ltimo "
"elemento.\n"
"* Muestra la iteraci√≥n sobre un vector y la mutaci√≥n del valor:\n"
"  `para e en &mut v { *e += 50; }`"

#: src/std/hashmap.md:1
#, fuzzy
msgid "# `HashMap`"
msgstr "# `Mapa hash`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Mapa hash est√°ndar con protecci√≥n contra ataques HashDoS:"

#: src/std/hashmap.md:5
#, fuzzy
msgid "```rust,editable\nuse std::collections::HashMap;"
msgstr "```herrumbre, editable\nuse std::colecciones::HashMap;"

#: src/std/hashmap.md:8
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
msgstr ""
"fn principal() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Las aventuras de Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Cuentos de hadas de Grimms\".to_string(), 751);\n"
"    page_counts.insert(\"Orgullo y prejuicio\".to_string(), 303);"

#: src/std/hashmap.md:14
#, fuzzy
msgid ""
"    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"We've know about {} books, but not Les Mis√©rables.\",\n"
"                 page_counts.len());\n"
"    }"
msgstr ""
"    if !page_counts.contains_key(\"Los Miserables\") {\n"
"        println!(\"Conocemos {} libros, pero no Los Miserables.\",\n"
"                 pagina_cuenta.len());\n"
"    }"

#: src/std/hashmap.md:19
#, fuzzy
msgid ""
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    para libro en [\"Orgullo y prejuicio\", \"La aventura de Alicia en el "
"pa√≠s de las maravillas\"] {\n"
"        coincidencia page_counts.get(libro) {\n"
"            Algunos(contar) => println!(\"{libro}: {contar} p√°ginas\"),\n"
"            Ninguno => println!(\"{libro} es desconocido\").\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/std/box.md:1
#, fuzzy
msgid "# `Box`"
msgstr "# `Caja`"

#: src/std/box.md:3
#, fuzzy
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] es un puntero propio a los datos en el mont√≥n:"

#: src/std/box.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let cinco = Caja::nuevo(5);\n"
"    println!(\"cinco: {}\", *cinco);\n"
"}\n"
"```"

#: src/std/box.md:13
#, fuzzy
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - -. .- - - - - - -.\n"
": : : :\n"
":    cinco     :     :             :\n"
": +-----+ : : +-----+ :\n"
": | o---|---+-----+-->| 5 | :\n"
": +-----+ : : +-----+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - -' `- - - - - - -'\n"
"```"

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, lo que significa que puedes [llamar "
"a m√©todos\n"
"desde `T` directamente en un `Box<T>`][2]."

#: src/std/box.md:29
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: "
"https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: "
"https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"

#: src/std/box.md:34
#, fuzzy
msgid ""
"* `Box` is like `std::unique_ptr` in C++.\n"
"* In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`."
msgstr ""
"* `Box` es como `std::unique_ptr` en C++.\n"
"* En el ejemplo anterior, incluso puede omitir el `*` en la instrucci√≥n "
"`println!` gracias a `Deref`."

#: src/std/box-recursive.md:1
#, fuzzy
msgid "# Box with Recursive Data Structures"
msgstr "# Caja con estructuras de datos recursivas"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"Los tipos de datos recursivos o los tipos de datos con tama√±os din√°micos "
"necesitan usar un `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"lista de enumeraci√≥n<T> {\n"
"    Contras(T, Caja<Lista<T>>),\n"
"    Nulo,\n"
"}"

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
#, fuzzy
msgid ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, "
"Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, "
"Box::new(List::Nil))));\n"
"    println!(\"{lista:?}\");\n"
"}\n"
"```"

#: src/std/box-recursive.md:18
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                            "
"   :\n"
":    list                 :     :                                            "
"   :\n"
":   +--------+-------+    :     :    +--------+--------+    "
"+--------+------+   :\n"
":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  "
"|   :\n"
":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// "
"|   :\n"
":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// "
"|   :\n"
":   +--------+-------+    :     :    +--------+--------+    "
"+--------+------+   :\n"
":                         :     :                                            "
"   :\n"
":                         :     :                                            "
"   :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
": : : :\n"
":    lista                 :     :                                           "
"    :\n"
": +--------+-------+ : : +--------+--------+ +--------+ ------+ :\n"
": | Etiqueta | Contras | : : .->| Etiqueta | Contras | .->| Etiqueta | cero "
"| :\n"
": | 0 | 1 | : : | | 0 | 2 | | | ////// | //// | :\n"
": | 1 | o-----+----+-----+-' | 1 | o------+-' | ////// | //// | :\n"
": +--------+-------+ : : +--------+--------+ +--------+ ------+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"If the `Box` was not used here and we attempted to embed a `List` directly "
"into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it "
"would look infinite.\n"
"    \n"
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next\n"
"element of the `List` in the heap.    \n"
"    \n"
"</details>"
msgstr ""
"<detalles>\n"
"    \n"
"Si el 'Cuadro' no se us√≥ aqu√≠ e intentamos incrustar una 'Lista' "
"directamente en la 'Lista',\n"
"el compilador no calcular√≠a un tama√±o fijo de la estructura en la memoria, "
"parecer√≠a infinito.\n"
"    \n"
"`Box` resuelve este problema ya que tiene el mismo tama√±o que un puntero "
"normal y solo apunta al siguiente\n"
"elemento de la 'Lista' en el mont√≥n.\n"
"    \n"
"</detalles>"

#: src/std/box-niche.md:1
#, fuzzy
msgid "# Niche Optimization"
msgstr "# Optimizaci√≥n de nicho"

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. "
"This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"Un `Box` no puede estar vac√≠o, por lo que el puntero siempre es v√°lido y no "
"`null`. Esto\n"
"permite al compilador optimizar el dise√±o de la memoria:"

#: src/std/box-niche.md:19
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                            "
"   :\n"
":    list                 :     :                                            "
"   :\n"
":   +--------+-------+    :     :    +--------+--------+    "
"+--------+------+   :\n"
":   | 0      | 1     |    :     : .->| 0      |  2     | .->| ////// | //// "
"|   :\n"
":   | \"1/Tag\"| o-----+----+-----+-'  | \"1/Tag\"|  o-----+-'  | \"1/Tag\"| "
"null |   :\n"
":   +--------+-------+    :     :    +--------+--------+    "
"+--------+------+   :\n"
":                         :     :                                            "
"   :\n"
":                         :     :                                            "
"   :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
": : : :\n"
":    lista                 :     :                                           "
"    :\n"
": +--------+-------+ : : +--------+--------+ +--------+ ------+ :\n"
": | 0 | 1 | : : .->| 0 | 2 | .->| ////// | //// | :\n"
": | \"1/Etiqueta\"| o-----+----+-----+-' | \"1/Etiqueta\"| o-----+-' | "
"\"1/Etiqueta\"| nulo | :\n"
": +--------+-------+ : : +--------+--------+ +--------+ ------+ :\n"
": : : :\n"
": : : :\n"
"`- - - - - - - - - - - - - -' '- - - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/std/rc.md:1
#, fuzzy
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to "
"refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] es un puntero compartido contado por referencia. Use esto cuando "
"necesite hacer referencia\n"
"a los mismos datos desde varios lugares:"

#: src/std/rc.md:6
#, fuzzy
msgid "```rust,editable\nuse std::rc::Rc;"
msgstr "```herrumbre, editable\nuso std::rc::Rc;"

#: src/std/rc.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"
msgstr ""
"fn principal() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"

#: src/std/rc.md:18
#, fuzzy
msgid ""
"If you need to mutate the data inside an `Rc`, you will need to wrap the "
"data in\n"
"a type such as [`Cell` or `RefCell`][2]. See [`Arc`][3] if you are in a "
"multi-threaded\n"
"context."
msgstr ""
"Si necesita mutar los datos dentro de un `Rc`, deber√° envolver los datos en\n"
"un tipo como [`Cell` o `RefCell`][2]. Consulte [`Arc`][3] si se encuentra en "
"un entorno multiproceso.\n"
"contexto."

#: src/std/rc.md:22
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md"
msgstr ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md"

#: src/std/rc.md:28
#, fuzzy
msgid ""
"* Like C++'s `std::shared_ptr`.\n"
"* `clone` is cheap: creates a pointer to the same allocation and increases "
"the reference count.\n"
"* `make_mut` actually clones the inner value if necessary "
"(\"clone-on-write\") and returns a mutable reference."
msgstr ""
"* Como `std::shared_ptr` de C++.\n"
"* `clonar` es barato: crea un puntero a la misma asignaci√≥n y aumenta el "
"n√∫mero de referencias.\n"
"* `make_mut` en realidad clona el valor interno si es necesario "
"(\"clone-on-write\") y devuelve una referencia mutable."

#: src/modules.md:1
#, fuzzy
msgid "# Modules"
msgstr "# M√≥dulos"

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Hemos visto c√≥mo los bloques `impl` nos permiten funciones de espacio de "
"nombres a un tipo."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"De manera similar, `mod` nos permite tipos de espacios de nombres y "
"funciones:"

#: src/modules.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"mod foo {\n"
"    pub fn hacer_algo() {\n"
"        println!(\"En el m√≥dulo foo\");\n"
"    }\n"
"}"

#: src/modules.md:14
#, fuzzy
msgid ""
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}"
msgstr ""
"barra de mods {\n"
"    pub fn hacer_algo() {\n"
"        println!(\"En el modulo de la barra\");\n"
"    }\n"
"}"

#: src/modules.md:20
#, fuzzy
msgid ""
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    foo::hacer_algo();\n"
"    barra::hacer_algo();\n"
"}\n"
"```"

#: src/modules/visibility.md:1
#, fuzzy
msgid "# Visibility"
msgstr "# Visibilidad"

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "Los m√≥dulos son un l√≠mite de privacidad:"

#: src/modules/visibility.md:5
#, fuzzy
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible."
msgstr ""
"* Los elementos del m√≥dulo son privados de forma predeterminada (oculta los "
"detalles de implementaci√≥n).\n"
"* Los elementos de padres y hermanos siempre est√°n visibles."

#: src/modules/visibility.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"
msgstr ""
"```herrumbre, editable\n"
"mod exterior {\n"
"    fn privado() {\n"
"        println!(\"exterior::privado\");\n"
"    }"

#: src/modules/visibility.md:14
#, fuzzy
msgid ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"
msgstr ""
"    pub fn p√∫blico () {\n"
"        println!(\"exterior::publico\");\n"
"    }"

#: src/modules/visibility.md:18
#, fuzzy
msgid ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"
msgstr ""
"    mod interno {\n"
"        fn privado() {\n"
"            println!(\"exterior::interior::privado\");\n"
"        }"

#: src/modules/visibility.md:23
#, fuzzy
msgid ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"        pub fn p√∫blico () {\n"
"            println!(\"exterior::interior::publico\");\n"
"            super::privado();\n"
"        }\n"
"    }\n"
"}"

#: src/modules/visibility.md:30
#, fuzzy
msgid ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    exterior::p√∫blico();\n"
"}\n"
"```"

#: src/modules/paths.md:1
#, fuzzy
msgid "# Paths"
msgstr "# Caminos"

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "Las rutas se resuelven de la siguiente manera:"

#: src/modules/paths.md:5
#, fuzzy
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module."
msgstr ""
"1. Como ruta relativa:\n"
"   * `foo` o `self::foo` se refiere a `foo` en el m√≥dulo actual,\n"
"   * `super::foo` se refiere a `foo` en el m√≥dulo principal."

#: src/modules/paths.md:9
#, fuzzy
msgid ""
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"2. Como ruta absoluta:\n"
"   * `crate::foo` se refiere a `foo` en la ra√≠z de la caja actual,\n"
"   * `bar::foo` se refiere a `foo` en la caja `bar`."

#: src/modules/filesystem.md:1
#, fuzzy
msgid "# Filesystem Hierarchy"
msgstr "# Jerarqu√≠a del sistema de archivos"

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "El contenido del m√≥dulo se puede omitir:"

#: src/modules/filesystem.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"jard√≠n moderno;\n"
"```"

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "El contenido del m√≥dulo `jard√≠n` se encuentra en:"

#: src/modules/filesystem.md:11
#, fuzzy
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden.rs` (estilo moderno Rust 2018)\n"
"* `src/garden/mod.rs` (estilo antiguo de Rust 2015)"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Del mismo modo, se puede encontrar un m√≥dulo `jard√≠n::vegetales` en:"

#: src/modules/filesystem.md:16
#, fuzzy
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden/vegetables.rs` (estilo moderno Rust 2018)\n"
"* `src/garden/vegetables/mod.rs` (estilo antiguo de Rust 2015)"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "La ra√≠z `crate` est√° en:"

#: src/modules/filesystem.md:21
#, fuzzy
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (para una caja de biblioteca)\n"
"* `src/main.rs` (para una caja binaria)"

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "# Day 2: Afternoon Exercises"
msgstr "# D√≠a 2: Ejercicios por la tarde"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "Los ejercicios de esta tarde se centrar√°n en cadenas e iteradores."

#: src/exercises/day-2/luhn.md:1
#, fuzzy
msgid "# Luhn Algorithm"
msgstr "# Algoritmo de Luhn"

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to\n"
"validate credit card numbers. The algorithm takes a string as input and does "
"the\n"
"following to validate the credit card number:"
msgstr ""
"El [algoritmo de Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) se "
"utiliza para\n"
"validar n√∫meros de tarjetas de cr√©dito. El algoritmo toma una cadena como "
"entrada y hace lo\n"
"siguiente para validar el n√∫mero de tarjeta de cr√©dito:"

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid "* Ignore all spaces. Reject number with less than two digits."
msgstr ""
"* Ignorar todos los espacios. N√∫mero de rechazo con menos de dos d√≠gitos."

#: src/exercises/day-2/luhn.md:9
#, fuzzy
msgid ""
"* Moving from right to left, double every second digit: for the number "
"`1234`,\n"
"  we double `3` and `1`."
msgstr ""
"* Movi√©ndose de derecha a izquierda, doble cada segundo d√≠gito: para el "
"n√∫mero `1234`,\n"
"  doblamos `3` y `1`."

#: src/exercises/day-2/luhn.md:12
#, fuzzy
msgid ""
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` "
"which\n"
"  becomes `5`."
msgstr ""
"* Despu√©s de duplicar un d√≠gito, suma los d√≠gitos. As√≠ que duplicar `7` se "
"convierte en `14` que\n"
"  se convierte en `5`."

#: src/exercises/day-2/luhn.md:15
#, fuzzy
msgid "* Sum all the undoubled and doubled digits."
msgstr "* Suma todos los d√≠gitos no duplicados y duplicados."

#: src/exercises/day-2/luhn.md:17
#, fuzzy
msgid "* The credit card number is valid if the sum ends with `0`."
msgstr "* El n√∫mero de tarjeta de cr√©dito es v√°lido si la suma termina en `0`."

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Copie el siguiente c√≥digo en <https://play.rust-lang.org/> e implemente el\n"
"funci√≥n:"

#: src/exercises/day-2/luhn.md:27
#, fuzzy
msgid ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    sin implementar!()\n"
"}"

#: src/exercises/day-2/luhn.md:31
#, fuzzy
msgid ""
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_non_digit_cc_number() {\n"
"    afirmar!(!luhn(\"foo\"));\n"
"}"

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
#, fuzzy
msgid ""
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_empty_cc_number() {\n"
"    afirmar!(!luhn(\"\"));\n"
"    afirmar!(!luhn(\" \"));\n"
"    afirmar!(!luhn(\" \"));\n"
"    afirmar!(!luhn(\" \"));\n"
"}"

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
#, fuzzy
msgid ""
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_single_digit_cc_number() {\n"
"    afirmar!(!luhn(\"0\"));\n"
"}"

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
#, fuzzy
msgid ""
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn prueba_dos_d√≠gitos_cc_n√∫mero() {\n"
"    afirmar!(luhn(\" 0 0 \"));\n"
"}"

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
#, fuzzy
msgid ""
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_valid_cc_number() {\n"
"    afirmar!(luhn(\"4263 9826 4026 9299\"));\n"
"    afirmar!(luhn(\"4539 3195 0343 6467\"));\n"
"    afirmar!(luhn(\"7992 7398 713\"));\n"
"}"

#: src/exercises/day-2/luhn.md:61
#, fuzzy
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_invalid_cc_number() {\n"
"    afirmar!(!luhn(\"4223 9826 4026 9299\"));\n"
"    afirmar!(!luhn(\"4539 3195 0343 6476\"));\n"
"    afirmar!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"

#: src/exercises/day-2/strings-iterators.md:1
#, fuzzy
msgid "# Strings and Iterators"
msgstr "# Cadenas e iteradores"

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The\n"
"server is configured with a number of _path prefixes_ which are matched "
"against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"En este ejercicio, implementar√° un componente de enrutamiento de un servidor "
"web. √âl\n"
"El servidor est√° configurado con una serie de _prefijos de ruta_ que se "
"comparan con\n"
"_solicitar rutas_. Los prefijos de ruta pueden contener un car√°cter comod√≠n "
"que\n"
"coincide con un segmento completo. Consulte las pruebas unitarias a "
"continuaci√≥n."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copia el siguiente c√≥digo a <https://play.rust-lang.org/> y haz las pruebas\n"
"pasar. Intente evitar asignar un `Vec` para sus resultados intermedios:"

#: src/exercises/day-2/strings-iterators.md:16
#, fuzzy
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn prefix_matches(prefijo: &str, request_path: &str) -> bool {\n"
"    sin implementar!()\n"
"}"

#: src/exercises/day-2/strings-iterators.md:20
#, fuzzy
msgid ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"
msgstr ""
"#[prueba]\n"
"fn prueba_coincidencias_sin_comod√≠n() {\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores\"));\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores/abc-123\"));\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores/abc/libros\"));"

#: src/exercises/day-2/strings-iterators.md:26
#: src/exercises/day-2/solutions-afternoon.md:146
#, fuzzy
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", "
"\"/v1/parent/publishers\"));\n"
"}"
msgstr ""
"    aseverar!(!prefix_matches(\"/v1/editores\", \"/v1\"));\n"
"    afirmar!(!prefix_matches(\"/v1/editores\", \"/v1/editoresLibros\"));\n"
"    aseverar!(!prefix_matches(\"/v1/editores\", "
"\"/v1/principal/editores\"));\n"
"}"

#: src/exercises/day-2/strings-iterators.md:31
#: src/exercises/day-2/solutions-afternoon.md:151
#, fuzzy
msgid ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"
msgstr ""
"#[prueba]\n"
"fn prueba_coincidencias_con_comod√≠n() {\n"
"    afirmar! (prefijo_coincidencias (\n"
"        \"/v1/editores/*/libros\",\n"
"        \"/v1/editores/foo/libros\"\n"
"    ));\n"
"    afirmar! (prefijo_coincidencias (\n"
"        \"/v1/editores/*/libros\",\n"
"        \"/v1/editores/bar/libros\"\n"
"    ));\n"
"    afirmar! (prefijo_coincidencias (\n"
"        \"/v1/editores/*/libros\",\n"
"        \"/v1/editores/foo/libros/libro1\"\n"
"    ));"

#: src/exercises/day-2/strings-iterators.md:46
#, fuzzy
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"    afirmar!(!prefix_matches(\"/v1/editores/*/libros\", \"/v1/editores\"));\n"
"    afirmar!(!prefix_matches(\n"
"        \"/v1/editores/*/libros\",\n"
"        \"/v1/editores/foo/librosPorAutor\"\n"
"    ));\n"
"}\n"
"```"

#: src/welcome-day-3.md:1
#, fuzzy
msgid "# Welcome to Day 3"
msgstr "# Bienvenido al D√≠a 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Hoy, cubriremos algunos temas m√°s avanzados de Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits."
msgstr ""
"* Rasgos: derivaci√≥n de rasgos, m√©todos predeterminados y biblioteca "
"est√°ndar importante\n"
"  rasgos."

#: src/welcome-day-3.md:8
#, fuzzy
msgid ""
"* Generics: generic data types, generic methods, monomorphization, and "
"trait\n"
"  objects."
msgstr ""
"* Gen√©ricos: tipos de datos gen√©ricos, m√©todos gen√©ricos, monomorfizaci√≥n y "
"rasgo\n"
"  objetos."

#: src/welcome-day-3.md:11
#, fuzzy
msgid "* Error handling: panics, `Result`, and the try operator `?`."
msgstr "* Manejo de errores: panics, `Result` y el operador try `?`."

#: src/welcome-day-3.md:13
#, fuzzy
msgid "* Testing: unit tests, documentation tests, and integration tests."
msgstr ""
"* Pruebas: pruebas unitarias, pruebas de documentaci√≥n y pruebas de "
"integraci√≥n."

#: src/welcome-day-3.md:15
#, fuzzy
msgid ""
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* Unsafe Rust: punteros sin procesar, variables est√°ticas, funciones no "
"seguras y extern\n"
"  funciones"

#: src/traits.md:1
#, fuzzy
msgid "# Traits"
msgstr "# Rasgos"

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust te permite abstraer sobre tipos con rasgos. Son similares a las "
"interfaces:"

#: src/traits.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"rasgo Saludo {\n"
"    fn decir_hola(&self);\n"
"}"

#: src/traits.md:10
#, fuzzy
msgid ""
"struct Dog {\n"
"    name: String,\n"
"}"
msgstr ""
"estructura Perro {\n"
"    nombre: cadena,\n"
"}"

#: src/traits.md:14
#, fuzzy
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr ""
"estructura Gato; // Sin nombre, los gatos no responder√°n a √©l de todos modos."

#: src/traits.md:16
#, fuzzy
msgid ""
"impl Greet for Dog {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Wuf, my name is {}!\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Saludo para perro {\n"
"    fn decir_hola(&self) {\n"
"        println!(\"¬°Vaya, mi nombre es {}!\", self.nombre);\n"
"    }\n"
"}"

#: src/traits.md:22
#, fuzzy
msgid ""
"impl Greet for Cat {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"
msgstr ""
"impl Saludo para gato {\n"
"    fn decir_hola(&self) {\n"
"        println!(\"¬°Miau!\");\n"
"    }\n"
"}"

#: src/traits.md:28
#, fuzzy
msgid ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"        Box::new(Cat),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.say_hello();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    dejar mascotas: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Perro { nombre: String::from(\"Fido\") }),\n"
"        Caja::nueva(Gato),\n"
"    ];\n"
"    para mascota en mascotas {\n"
"        mascota.di_hola();\n"
"    }\n"
"}\n"
"```"

#: src/traits.md:41
#, fuzzy
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that "
"users are required to implement themselves. Methods with default "
"implementations can rely on required methods.\n"
"* Types that implement a given trait may be of different sizes. This makes "
"it impossible to have things like `Vec<Greet>` in the example above.\n"
"* `dyn Greet` is a way to tell the compiler about a dynamically sized type "
"that implements `Greet`.\n"
"* In the example, `pets` holds Fat Pointers to objects that implement "
"`Greet`. The Fat Pointer consists of two components, a pointer to the actual "
"object and a pointer to the virtual method table for the `Greet` "
"implementation of that particular object."
msgstr ""
"* Los rasgos pueden especificar m√©todos preimplementados (predeterminados) y "
"m√©todos que los usuarios deben implementar por s√≠ mismos. Los m√©todos con "
"implementaciones predeterminadas pueden confiar en los m√©todos requeridos.\n"
"* Los tipos que implementan un rasgo dado pueden ser de diferentes tama√±os. "
"Esto hace que sea imposible tener cosas como `Vec<Greet>` en el ejemplo "
"anterior.\n"
"* `dyn Greet` es una forma de decirle al compilador sobre un tipo de tama√±o "
"din√°mico que implementa `Greet`.\n"
"* En el ejemplo, `mascotas` contiene Fat Pointers a objetos que implementan "
"`Greet`. Fat Pointer consta de dos componentes, un puntero al objeto real y "
"un puntero a la tabla de m√©todos virtuales para la implementaci√≥n `Greet` de "
"ese objeto en particular."

#: src/traits.md:46
#, fuzzy
msgid ""
"Compare these outputs in the above example:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), "
"std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), "
"std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""
"Compare estas salidas en el ejemplo anterior:\n"
"```oxidar, ignorar\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), "
"std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), "
"std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"

#: src/traits/deriving-traits.md:1
#, fuzzy
msgid "# Deriving Traits"
msgstr "# Rasgos derivados"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "Puede dejar que el compilador obtenga una serie de caracter√≠sticas:"

#: src/traits/deriving-traits.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"jugador de estructura {\n"
"    nombre: cadena,\n"
"    fuerza: u8,\n"
"    hit_points: u8,\n"
"}"

#: src/traits/deriving-traits.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\n"
"equal to {:?}?\\n"
"The answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let p1 = Jugador::predeterminado();\n"
"    sea p2 = p1.clon();\n"
"    println!(\"¬øEs {:?}\\igual a {:?}?\\n"
"La respuesta es {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"si\" } else { \"no\" });\n"
"}\n"
"```"

#: src/traits/default-methods.md:1
#, fuzzy
msgid "# Default Methods"
msgstr "# M√©todos predeterminados"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr ""
"Los rasgos pueden implementar el comportamiento en t√©rminos de otros m√©todos "
"de rasgos:"

#: src/traits/default-methods.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"rasgo es igual a {\n"
"    fn equal(&self, otro: &Self) -> bool;\n"
"    fn not_equal(&self, otro: &Self) -> bool {\n"
"        !self.igual(otro)\n"
"    }\n"
"}"

#: src/traits/default-methods.md:13
#, fuzzy
msgid "#[derive(Debug)]\nstruct Centimeter(i16);"
msgstr "#[derivar(Depurar)]\nestructura Cent√≠metro(i16);"

#: src/traits/default-methods.md:16
#, fuzzy
msgid ""
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}"
msgstr ""
"impl es igual a cent√≠metro {\n"
"    fn igual(&self, otro: &Cent√≠metro) -> bool {\n"
"        uno mismo.0 == otro.0\n"
"    }\n"
"}"

#: src/traits/default-methods.md:22
#, fuzzy
msgid ""
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea a = Cent√≠metro(10);\n"
"    sea b = Cent√≠metro(20);\n"
"    println!(\"{a:?} es igual a {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"

#: src/traits/important-traits.md:1
#, fuzzy
msgid "# Important Traits"
msgstr "# Rasgos importantes"

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Ahora veremos algunas de las caracter√≠sticas m√°s comunes de la biblioteca "
"est√°ndar de Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"* `Iterator` and `IntoIterator` used in `for` loops,\n"
"* `From` and `Into` used to convert values,\n"
"* `Read` and `Write` used for IO,\n"
"* `Add`, `Mul`, ... used for operator overloading, and\n"
"* `Drop` used for defining destructors."
msgstr ""
"* `Iterator` e `IntoIterator` usados en bucles `for`,\n"
"* `From` y `Into` usados para convertir valores,\n"
"* `Read` y `Write` utilizados para IO,\n"
"* `Add`, `Mul`, ... utilizado para la sobrecarga de operadores, y\n"
"* `Drop` usado para definir destructores."

#: src/traits/iterator.md:1
#, fuzzy
msgid "# Iterators"
msgstr "# Iteradores"

#: src/traits/iterator.md:3
#, fuzzy
msgid "You can implement the `Iterator` trait on your own types:"
msgstr "Puede implementar el rasgo `Iterator` en sus propios tipos:"

#: src/traits/iterator.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"estructura de Fibonacci {\n"
"    corriente: u32,\n"
"    siguiente: u32,\n"
"}"

#: src/traits/iterator.md:11
#, fuzzy
msgid "impl Iterator for Fibonacci {\n    type Item = u32;"
msgstr "iterador impl para Fibonacci {\n    tipo Art√≠culo = u32;"

#: src/traits/iterator.md:14
#, fuzzy
msgid ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}"
msgstr ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let nuevo_siguiente = self.actual + self.siguiente;\n"
"        self.actual = self.siguiente;\n"
"        self.siguiente = nuevo_siguiente;\n"
"        Algunos(self.curr)\n"
"    }\n"
"}"

#: src/traits/iterator.md:22
#, fuzzy
msgid ""
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    para (i, n) en fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"* `IntoIterator` is the trait that makes for loops work. It is implemented "
"by collection types such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also "
"implement it.\n"
"* The `Iterator` trait implements many common functional programming "
"operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can "
"find all the documentation\n"
"  about them. In Rust these functions should produce the code as efficient "
"as equivalent imperative\n"
"  implementations.\n"
"    \n"
"</details>"
msgstr ""
"* `IntoIterator` es el rasgo que hace que los bucles funcionen. Se "
"implementa mediante tipos de colecci√≥n como\n"
"  `Vec<T>` y referencias a ellos como `&Vec<T>` y `&[T]`. Los rangos tambi√©n "
"lo implementan.\n"
"* El rasgo `Iterador` implementa muchas operaciones comunes de programaci√≥n "
"funcional sobre colecciones\n"
"  (por ejemplo, `map`, `filter`, `reduce`, etc.). Esta es la caracter√≠stica "
"donde se puede encontrar toda la documentaci√≥n.\n"
"  a cerca de ellos. En Rust, estas funciones deber√≠an producir el c√≥digo tan "
"eficiente como el imperativo equivalente\n"
"  implementaciones.\n"
"    \n"
"</detalles>"

#: src/traits/from-iterator.md:1
#, fuzzy
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
#, fuzzy
msgid "`FromIterator` lets you build a collection from an `Iterator`."
msgstr "`FromIterator` te permite crear una colecci√≥n a partir de un `Iterator`."

#: src/traits/from-iterator.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes.into_iter().map(|prime| prime * "
"prime).collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sean primos = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes.into_iter().map(|prime| prime * "
"prime).collect::<Vec<_>>();\n"
"}\n"
"```"

#: src/traits/from-iterator.md:14
#, fuzzy
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"Implementos `Iterador`\n"
"`fn recopilar<B>(uno mismo) -> B\n"
"donde\n"
"    B: FromIterator<Self::Elemento>,\n"
"    Uno mismo: Tama√±o`"

#: src/traits/from-iterator.md:20
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Tambi√©n hay implementaciones que le permiten hacer cosas geniales como "
"convertir un\n"
"`Iterator<Item = Result<V, E>>` en `Result<Vec<V>, E>`."

#: src/traits/from-into.md:1
#, fuzzy
msgid "# `From` and `Into`"
msgstr "# `Desde` y `Hacia`"

#: src/traits/from-into.md:3
#, fuzzy
msgid "Types implement `From` and `Into` to facilitate type conversions:"
msgstr ""
"Los tipos implementan `From` y `Into` para facilitar las conversiones de "
"tipo:"

#: src/traits/from-into.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s = String::from(\"hola\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    sea uno = i16::desde(verdadero);\n"
"    dejar mas grande = i32::from(123i16);\n"
"    println!(\"{s}, {direcci√≥n}, {uno}, {m√°s grande}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:15
#, fuzzy
msgid "`Into` is automatically implemented when `From` is implemented:"
msgstr "`Into` se implementa autom√°ticamente cuando se implementa `From`:"

#: src/traits/from-into.md:17
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let s: String = \"hola\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    sea uno: i16 = true.into();\n"
"    sea m√°s grande: i32 = 123i16.into();\n"
"    println!(\"{s}, {direcci√≥n}, {uno}, {m√°s grande}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:27
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"* That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too.\n"
"* When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that "
"_only_ implement `Into`.\n"
"    \n"
"</details>"
msgstr ""
"<detalles>\n"
"  \n"
"* Es por eso que es com√∫n implementar solo `From`, ya que su tipo obtendr√° "
"la implementaci√≥n `Into` tambi√©n.\n"
"* Al declarar un tipo de entrada de argumento de funci√≥n como \"cualquier "
"cosa que se pueda convertir en una 'Cadena'\", la regla es opuesta, debe "
"usar 'En'.\n"
"  Tu funci√≥n aceptar√° tipos que implementen `From` y aquellos que _only_ "
"implementen `Into`.\n"
"    \n"
"</detalles>"

#: src/traits/read-write.md:1
#, fuzzy
msgid "# `Read` and `Write`"
msgstr "# `Leer` y `Escribir`"

#: src/traits/read-write.md:3
#, fuzzy
msgid "Using `Read` and `BufRead`, you can abstract over `u8` sources:"
msgstr "Usando `Read` y `BufRead`, puede abstraer sobre las fuentes `u8`:"

#: src/traits/read-write.md:5
#, fuzzy
msgid "```rust,editable\nuse std::io::{BufRead, BufReader, Read, Result};"
msgstr "```herrumbre, editable\nuse std::io::{BufRead, BufReader, Read, Result};"

#: src/traits/read-write.md:8
#, fuzzy
msgid ""
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"
msgstr ""
"fn count_lines<R: Leer>(lector: R) -> usar {\n"
"    let buf_reader = BufReader::new(lector);\n"
"    buf_reader.l√≠neas().cuenta()\n"
"}"

#: src/traits/read-write.md:13
#, fuzzy
msgid ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\n"
"bar\\n"
"baz\\n"
"\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""
"fn principal() -> Resultado<()> {\n"
"    let slice: &[u8] = b\"foo\\n"
"bar\\n"
"baz\\n"
"\";\n"
"    println!(\"l√≠neas en segmento: {}\", count_lines(segmento));"

#: src/traits/read-write.md:17
#, fuzzy
msgid ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"l√≠neas en el archivo: {}\", count_lines(archivo));\n"
"    OK(())\n"
"}\n"
"```"

#: src/traits/read-write.md:23
#, fuzzy
msgid "Similarly, `Write` lets you abstract over `u8` sinks:"
msgstr "De manera similar, `Write` te permite abstraer sobre los sumideros `u8`:"

#: src/traits/read-write.md:25
#, fuzzy
msgid "```rust,editable\nuse std::io::{Result, Write};"
msgstr "```herrumbre, editable\nuse std::io::{Resultado, Escribir};"

#: src/traits/read-write.md:28
#, fuzzy
msgid ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n"
"\".as_bytes())\n"
"}"
msgstr ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    escritor.write_all(msg.as_bytes())?;\n"
"    escritor.write_all(\"\\n"
"\".as_bytes())\n"
"}"

#: src/traits/read-write.md:33
#, fuzzy
msgid ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn principal() -> Resultado<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hola\"?;\n"
"    log(&mut buffer, \"Mundo\")?;\n"
"    println!(\"Registrado: {:?}\", b√∫fer);\n"
"    OK(())\n"
"}\n"
"```"

#: src/traits/operators.md:1
#, fuzzy
msgid "# `Add`, `Mul`, ..."
msgstr "# `A√±adir`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid "Operator overloading is implemented via traits in `std::ops`:"
msgstr "La sobrecarga de operadores se implementa mediante rasgos en `std::ops`:"

#: src/traits/operators.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar, Copiar, Clonar)]\n"
"Punto de estructura { x: i32, y: i32 }"

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
#, fuzzy
msgid "impl std::ops::Add for Point {\n    type Output = Self;"
msgstr "impl std::ops::Add for Point {\n    escriba Salida = Auto;"

#: src/traits/operators.md:12
#, fuzzy
msgid ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"
msgstr ""
"    fn add(self, otro: Self) -> Self {\n"
"        Uno mismo {x: uno mismo.x + otro.x, y: uno mismo.y + otro.y}\n"
"    }\n"
"}"

#: src/traits/operators.md:17
#, fuzzy
msgid ""
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p1 = Punto { x: 10, y: 20 };\n"
"    sea p2 = Punto { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"

#: src/traits/operators.md:26 src/traits/drop.md:34
#, fuzzy
msgid "Discussion points:"
msgstr "Puntos de discusi√≥n:"

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that "
"useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider "
"overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on "
"the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor "
"of a\n"
"        trait."
msgstr ""
"* Podr√≠as implementar `Add` para `&Point`. ¬øEn qu√© situaciones es √∫til?\n"
"    * Respuesta: `Add:add` consume `self`. Si escribe `T` para el que est√°\n"
"        sobrecargar el operador no es `Copiar`, debe considerar sobrecargar\n"
"        el operador para `&T` tambi√©n. Esto evita la clonaci√≥n innecesaria "
"en el\n"
"        sitio de llamadas\n"
"* ¬øPor qu√© `Salida` es un tipo asociado? ¬øPodr√≠a convertirse en un par√°metro "
"de tipo?\n"
"    * Respuesta corta: los par√°metros de tipo son controlados por la persona "
"que llama, pero\n"
"        los tipos asociados (como `Salida`) son controlados por el "
"implementador de un\n"
"        rasgo."

#: src/traits/drop.md:1
#, fuzzy
msgid "# The `Drop` Trait"
msgstr "# El rasgo `Gota`"

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement `Drop` can specify code to run when they go out of "
"scope:"
msgstr ""
"Los valores que implementan `Drop` pueden especificar el c√≥digo para "
"ejecutar cuando quedan fuera del alcance:"

#: src/traits/drop.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"estructura desplegable {\n"
"    nombre: &'cadena est√°tica,\n"
"}"

#: src/traits/drop.md:10
#, fuzzy
msgid ""
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Drop para Droppable {\n"
"    fn drop(&mut auto) {\n"
"        println!(\"Dejando {}\", self.name);\n"
"    }\n"
"}"

#: src/traits/drop.md:16
#, fuzzy
msgid ""
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let a = Droppable { nombre: \"a\" };\n"
"    {\n"
"        let b = Droppable { nombre: \"b\" };\n"
"        {\n"
"            let c = Soltable { nombre: \"c\" };\n"
"            let d = Droppable { nombre: \"d\" };\n"
"            println!(\"Saliendo del bloque B\");\n"
"        }\n"
"        println!(\"Saliendo del bloque A\");\n"
"    }\n"
"    soltar (a);\n"
"    println!(\"Saliendo de principal\");\n"
"}\n"
"```"

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why does not `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end "
"of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* ¬øPor qu√© `Drop::drop` no toma `self`?\n"
"    * Respuesta corta: si lo hiciera, `std::mem::drop` se llamar√≠a al final "
"de\n"
"        el bloque, dando como resultado otra llamada a `Drop::drop`, y una "
"pila\n"
"        ¬°Desbordamiento!\n"
"* Intente reemplazar `drop(a)` con `a.drop()`."

#: src/generics.md:1
#, fuzzy
msgid "# Generics"
msgstr "# Gen√©ricos"

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as "
"sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust admite gen√©ricos, lo que le permite abstraer un algoritmo (como la "
"clasificaci√≥n)\n"
"sobre los tipos utilizados en el algoritmo."

#: src/generics/data-types.md:1
#, fuzzy
msgid "# Generic Data Types"
msgstr "# Tipos de datos gen√©ricos"

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Puede usar gen√©ricos para abstraer sobre el tipo de campo concreto:"

#: src/generics/data-types.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"estructura Punto<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"

#: src/generics/data-types.md:12
#, fuzzy
msgid ""
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let entero = Punto { x: 5, y: 10 };\n"
"    let float = Punto { x: 1.0, y: 4.0 };\n"
"    println!(\"{entero:?} y {flotante:?}\");\n"
"}\n"
"```"

#: src/generics/methods.md:1
#, fuzzy
msgid "# Generic Methods"
msgstr "# M√©todos gen√©ricos"

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Puedes declarar un tipo gen√©rico en tu bloque `impl`:"

#: src/generics/methods.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);"
msgstr ""
"```herrumbre, editable\n"
"#[derivar(Depurar)]\n"
"struct Punto<T>(T, T);"

#: src/generics/methods.md:9
#, fuzzy
msgid ""
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }"
msgstr ""
"impl<T> Punto<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0 // + 10\n"
"    }"

#: src/generics/methods.md:14
#, fuzzy
msgid "    // fn set_x(&mut self, x: T)\n}"
msgstr "    // fn set_x(&mut auto, x: T)\n}"

#: src/generics/methods.md:17
#, fuzzy
msgid ""
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea p = Punto(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?\n"
"    * This is because it is a generic implementation section for generic "
"type. They are independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods "
"in this block will only be available for `Point<u32>`."
msgstr ""
"* *P:* ¬øPor qu√© `T` se especifica dos veces en `impl<T> Point<T> {}`? ¬øNo es "
"eso redundante?\n"
"    * Esto se debe a que es una secci√≥n de implementaci√≥n gen√©rica para el "
"tipo gen√©rico. Son gen√©ricos de forma independiente.\n"
"    * Significa que estos m√©todos est√°n definidos para cualquier `T`.\n"
"    * Es posible escribir `impl Point<u32> { .. }`.\n"
"      * `Point` sigue siendo gen√©rico y puede usar `Point<f64>`, pero los "
"m√©todos en este bloque solo estar√°n disponibles para `Point<u32>`."

#: src/generics/trait-bounds.md:1
#, fuzzy
msgid "# Trait Bounds"
msgstr "# L√≠mites de rasgos"

#: src/generics/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to limit the types. You can do "
"this\n"
"with `T: Trait` or `impl Trait`:"
msgstr ""
"Cuando trabaja con gen√©ricos, a menudo desea limitar los tipos. Puedes "
"hacerlo\n"
"con `T: Rasgo` o `impl Rasgo`:"

#: src/generics/trait-bounds.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn duplicar<T: Clonar>(a: T) -> (T, T) {\n"
"    (a.clon(), a.clone())\n"
"}"

#: src/generics/trait-bounds.md:11
#, fuzzy
msgid "// struct NotClonable;"
msgstr "// estructura No Clonable;"

#: src/generics/trait-bounds.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let foo = String::from(\"foo\");\n"
"    dejar par = duplicar (foo);\n"
"    println!(\"{par:?}\");\n"
"}\n"
"```"

#: src/generics/trait-bounds.md:22
#, fuzzy
msgid ""
"Show a `where` clause, students will encounter it when reading code.\n"
"    \n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""
"Muestre una cl√°usula `where`, los estudiantes la encontrar√°n al leer el "
"c√≥digo.\n"
"    \n"
"```oxidar, ignorar\n"
"fn duplicar<T>(a: T) -> (T, T)\n"
"donde\n"
"    T: clon,\n"
"{\n"
"    (a.clon(), a.clone())\n"
"}\n"
"```"

#: src/generics/trait-bounds.md:33
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of "
"\":\" can be arbitrary, like `Option<T>`.\n"
"    \n"
"</details>"
msgstr ""
"* Ordena la firma de la funci√≥n si tiene muchos par√°metros.\n"
"* Tiene caracter√≠sticas adicionales que lo hacen m√°s potente.\n"
"    * Si alguien pregunta, la caracter√≠stica adicional es que el tipo a la "
"izquierda de \":\" puede ser arbitrario, como `Option<T>`.\n"
"    \n"
"</detalles>"

#: src/generics/impl-trait.md:1
#, fuzzy
msgid "# `impl Trait`"
msgstr "# `Rasgo impl`"

#: src/generics/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Similar a los l√≠mites de rasgos, se puede usar una sintaxis `impl Trait` en "
"la funci√≥n\n"
"argumentos y valores de retorno:"

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5
#: src/generics/trait-objects.md:28
#, fuzzy
msgid "```rust,editable\nuse std::fmt::Display;"
msgstr "```herrumbre, editable\nuse std::fmt::Display;"

#: src/generics/impl-trait.md:9
#, fuzzy
msgid ""
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}"
msgstr ""
"fn get_x(nombre: Pantalla impl) -> Pantalla impl {\n"
"    formato!(\"Hola {nombre}\")\n"
"}"

#: src/generics/impl-trait.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea x = get_x(\"foo\");\n"
"    imprimir!(\"{x}\");\n"
"}\n"
"```"

#: src/generics/impl-trait.md:19
#, fuzzy
msgid ""
"* `impl Trait` cannot be used with the `::<>` turbo fish syntax.\n"
"* `impl Trait` allows you to work with types which you cannot name."
msgstr ""
"* `impl Trait` no se puede usar con la sintaxis de turbo fish `::<>`.\n"
"* `impl Trait` te permite trabajar con tipos que no puedes nombrar."

#: src/generics/impl-trait.md:24
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"El significado de `Rasgo impl` es un poco diferente en las diferentes "
"posiciones."

#: src/generics/impl-trait.md:26
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with "
"a trait bound.\n"
"* For a return type, it means that the return type is some concrete type "
"that implements the trait,\n"
"  without naming the type. This can be useful when you don't want to expose "
"the concrete type in a\n"
"  public API."
msgstr ""
"* Para un par√°metro, `impl Rasgo` es como un par√°metro gen√©rico an√≥nimo con "
"un l√≠mite de rasgo.\n"
"* Para un tipo de retorno, significa que el tipo de retorno es un tipo "
"concreto que implementa el rasgo,\n"
"  sin nombrar el tipo. Esto puede ser √∫til cuando no desea exponer el tipo "
"concreto en un\n"
"  API p√∫blica."

#: src/generics/impl-trait.md:31
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used "
"a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` "
"type are the same type.\n"
"It would not work for this particular function, as the type we expect as "
"input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, "
"we'd need two\n"
"independent generic parameters.\n"
"    \n"
"</details>"
msgstr ""
"Este ejemplo es genial, porque usa `impl Display` dos veces. Ayuda a "
"explicar que\n"
"nada aqu√≠ obliga a que sea _el mismo_ tipo `impl Display`. Si usamos un "
"solo\n"
"`T: Display`, aplicar√≠a la restricci√≥n de que la entrada `T` y el tipo de "
"retorno `T` son del mismo tipo.\n"
"No funcionar√≠a para esta funci√≥n en particular, ya que el tipo que esperamos "
"como entrada probablemente no sea\n"
"qu√© `formato!` devuelve. Si quisi√©ramos hacer lo mismo a trav√©s de la "
"sintaxis `: Display`, necesitar√≠amos dos\n"
"par√°metros gen√©ricos independientes.\n"
"    \n"
"</detalles>"

#: src/generics/closures.md:1
#, fuzzy
msgid "# Closures"
msgstr "# Cierres"

#: src/generics/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Los cierres o expresiones lambda tienen tipos que no se pueden nombrar. Sin "
"embargo, ellos\n"
"implementar especial "
"[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), y\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) rasgos:"

#: src/generics/closures.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn apply_with_log(funci√≥n: impl FnOnce(i32) -> i32, entrada: i32) -> i32 {\n"
"    println!(\"Llamando a la funci√≥n en {entrada}\");\n"
"    funci√≥n (entrada)\n"
"}"

#: src/generics/closures.md:14
#, fuzzy
msgid ""
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;"
msgstr ""
"fn principal() {\n"
"    sea sumar_3 = |x| x + 3;\n"
"    sea mul_5 = |x| x * 5;"

#: src/generics/closures.md:18
#, fuzzy
msgid ""
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""
"    println!(\"agregar_3: {}\", apply_with_log(agregar_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"

#: src/generics/closures.md:25
#, fuzzy
msgid ""
"If you have an `FnOnce`, you may only call it once. It might consume "
"captured values."
msgstr ""
"Si tiene un `FnOnce`, solo puede llamarlo una vez. Podr√≠a consumir valores "
"capturados."

#: src/generics/closures.md:27
#, fuzzy
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times "
"but not concurrently."
msgstr ""
"Un `FnMut` podr√≠a mutar los valores capturados, por lo que puede llamarlo "
"varias veces pero no al mismo tiempo."

#: src/generics/closures.md:29
#, fuzzy
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures "
"nothing at all, so it can\n"
"be called multiple times concurrently."
msgstr ""
"Una `Fn` ni consume ni muta los valores capturados, o tal vez no captura "
"nada en absoluto, por lo que puede\n"
"ser llamado varias veces al mismo tiempo."

#: src/generics/closures.md:32
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever "
"an `FnMut` or `FnOnce`\n"
"is called for."
msgstr ""
"`FnMut` es un subtipo de `FnOnce`. `Fn` es un subtipo de `FnMut` y `FnOnce`. "
"Es decir. puedes usar un\n"
"`FnMut` dondequiera que se solicite `FnOnce`, y puede usar `Fn` donde quiera "
"que `FnMut` o `FnOnce`\n"
"se pide."

#: src/generics/closures.md:36
#, fuzzy
msgid "`move` closures only implement `FnOnce`."
msgstr "Los cierres `mover` solo implementan `FnOnce`."

#: src/generics/monomorphization.md:1
#, fuzzy
msgid "# Monomorphization"
msgstr "# Monomorfizaci√≥n"

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"El c√≥digo gen√©rico se convierte en c√≥digo no gen√©rico seg√∫n los sitios de "
"llamadas:"

#: src/generics/monomorphization.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let entero = Algunos (5);\n"
"    dejar flotar = Algunos (5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "se comporta como si escribiera"

#: src/generics/monomorphization.md:14
#, fuzzy
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"enum Option_i32 {\n"
"    algunos (i32),\n"
"    Ninguno,\n"
"}"

#: src/generics/monomorphization.md:20
#, fuzzy
msgid ""
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}"
msgstr ""
"enumerar Option_f64 {\n"
"    Algunos (f64),\n"
"    Ninguno,\n"
"}"

#: src/generics/monomorphization.md:25
#, fuzzy
msgid ""
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let entero = Option_i32::Algunos(5);\n"
"    let float = Option_f64::Algunos(5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Esta es una abstracci√≥n de costo cero: obtienes exactamente el mismo "
"resultado que si tuvieras\n"
"codific√≥ a mano las estructuras de datos sin la abstracci√≥n."

#: src/generics/trait-objects.md:1
#, fuzzy
msgid "# Trait Objects"
msgstr "# Objetos de caracter√≠sticas"

#: src/generics/trait-objects.md:3
#, fuzzy
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr ""
"Hemos visto c√≥mo una funci√≥n puede tomar argumentos que implementan un rasgo:"

#: src/generics/trait-objects.md:8
#, fuzzy
msgid ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Your value: {}\", x);\n"
"}"
msgstr ""
"fn imprimir<T: Pantalla>(x: T) {\n"
"    println!(\"Su valor: {}\", x);\n"
"}"

#: src/generics/trait-objects.md:12
#, fuzzy
msgid ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    imprimir (123);\n"
"    imprimir(\"Hola\");\n"
"}\n"
"```"

#: src/generics/trait-objects.md:18
#, fuzzy
msgid ""
"However, how can we store a collection of mixed types which implement "
"`Display`?"
msgstr ""
"Sin embargo, ¬øc√≥mo podemos almacenar una colecci√≥n de tipos mixtos que "
"implementan `Display`?"

#: src/generics/trait-objects.md:20
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"fn principal() {\n"
"    sea xs = vec![123, \"Hola\"];\n"
"}\n"
"```"

#: src/generics/trait-objects.md:26
#, fuzzy
msgid "For this, we need _trait objects_:"
msgstr "Para esto, necesitamos _objetos de rasgos_:"

#: src/generics/trait-objects.md:31
#, fuzzy
msgid ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), "
"Box::new(\"Hello\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), "
"Box::new(\"Hello\")];\n"
"    para x en xs {\n"
"        imprimir!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"

#: src/generics/trait-objects.md:39
#, fuzzy
msgid "Memory layout after allocating `xs`:"
msgstr "Dise√±o de memoria despu√©s de asignar `xs`:"

#: src/generics/trait-objects.md:41
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- - -.\n"
":                           :     :                                          "
"     :\n"
":    xs                     :     :                                          "
"     :\n"
":   +-----------+-------+   :     :   +-----+-----+                          "
"     :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                          "
"     :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                          "
"     :\n"
":   | capacity  |     2 |   :     :     | |   | |   "
"+----+----+----+----+----+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  "
"|    :\n"
":                           :     :     | |   |     "
"+----+----+----+----+----+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                              "
"     :\n"
"                                  :     | |   |     "
"+-------------------------+   :\n"
"                                  :     | |   '---->| \"<str as "
"Display>::fmt\" |   :\n"
"                                  :     | |         "
"+-------------------------+   :\n"
"                                  :     | |                                  "
"     :\n"
"                                  :     | |   +----+----+----+----+          "
"     :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |          "
"     :\n"
"                                  :     |     +----+----+----+----+          "
"     :\n"
"                                  :     |                                    "
"     :\n"
"                                  :     |     +-------------------------+    "
"     :\n"
"                                  :     '---->| \"<i32 as Display>::fmt\" |  "
"       :\n"
"                                  :           +-------------------------+    "
"     :\n"
"                                  :                                          "
"     :\n"
"                                  :                                          "
"     :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- - -'\n"
"```"
msgstr ""
"``` bob\n"
" Mont√≥n de pila\n"
".- - - - - - - - - - - - - - -. .- - - - - - - - - - - - - - - - - - - - - - "
"- - -.\n"
": : : :\n"
": xs : : :\n"
": +-----------+-------+ : : +-----+-----+ :\n"
": | ptr | o---+---+-----+-->| oo | oo | :\n"
": | Len | 2 | : : +-|-|-+-|-|-+ :\n"
": | capacidad | 2 | : : | | | | +----+----+----+----+----+ :\n"
": +-----------+-------+ : : | | | '-->| H | mi | yo | yo | o | :\n"
": : : | | | +----+----+----+----+----+ :\n"
"`- - - - - - - - - - - - - - -' : | | | :\n"
"                                  : | | | "
"+---------------------------------------+ :\n"
"                                  : | | '---->| \"<str como pantalla>::fmt\" "
"| :\n"
"                                  : | | "
"+---------------------------------------+ :\n"
"                                  : | | :\n"
"                                  : | | +----+----+----+----+ :\n"
"                                  : | '-->| 7b | 00 | 00 | 00 | :\n"
"                                  : | +----+----+----+----+ :\n"
"                                  : | :\n"
"                                  : | "
"+---------------------------------------+ :\n"
"                                  : '---->| \"<i32 como "
"visualizaci√≥n>::fmt\" | :\n"
"                                  : +--------------------------+:\n"
"                                  : :\n"
"                                  : :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- - - -'\n"
"```"

#: src/generics/trait-objects.md:69
#, fuzzy
msgid ""
"Similarly, you need a trait object if you want to return different values\n"
"implementing a trait:"
msgstr ""
"Del mismo modo, necesita un objeto de rasgo si desea devolver valores "
"diferentes\n"
"implementando un rasgo:"

#: src/generics/trait-objects.md:72
#, fuzzy
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn n√∫meros (n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    si n > 0 {\n"
"        Caja::nuevo(0..n)\n"
"    } m√°s {\n"
"        Cuadro::nuevo((n..0).rev())\n"
"    }\n"
"}"

#: src/generics/trait-objects.md:81
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
"}"
msgstr ""
"fn principal() {\n"
"    println!(\"{:?}\", numeros(-5).recoger::<Vec<_>>());\n"
"    println!(\"{:?}\", numeros(5).recoger::<Vec<_>>());\n"
"}"

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "# Day 3: Morning Exercises"
msgstr "# D√≠a 3: Ejercicios Matutinos"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Dise√±aremos una biblioteca GUI cl√°sica de rasgos y objetos de rasgos."

#: src/exercises/day-3/simple-gui.md:1
#, fuzzy
msgid "# A Simple GUI Library"
msgstr "# Una biblioteca GUI simple"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Dise√±emos una biblioteca GUI cl√°sica usando nuestro nuevo conocimiento de "
"rasgos y\n"
"objetos de rasgos."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "Tendremos una serie de widgets en nuestra biblioteca:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Ventana`: tiene un `t√≠tulo` y contiene otros widgets.\n"
"* `Bot√≥n`: tiene una `etiqueta` y una funci√≥n de devoluci√≥n de llamada que "
"se invoca cuando el\n"
"  se presiona el bot√≥n.\n"
"* `Etiqueta`: tiene una `etiqueta`."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Los widgets implementar√°n un rasgo `Widget`, ver m√°s abajo."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copie el c√≥digo de abajo a <https://play.rust-lang.org/>, rellene lo que "
"falta\n"
"M√©todos `draw_into` para que implementes el rasgo `Widget`:"

#: src/exercises/day-3/simple-gui.md:18
#: src/exercises/day-3/safe-ffi-wrapper.md:25
#, fuzzy
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"
msgstr ""
"```herrumbre, deber√≠a_p√°nico\n"
"// TODO: elimine esto cuando haya terminado con su implementaci√≥n.\n"
"#![permitir(importaciones_no_usadas, variables_no_usadas, c√≥digo_muerto)]"

#: src/exercises/day-3/simple-gui.md:22
#, fuzzy
msgid ""
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"Widget de rasgo de pub {\n"
"    /// Ancho natural de `self`.\n"
"    ancho fn(&self) -> tama√±o de uso;"

#: src/exercises/day-3/simple-gui.md:26
#: src/exercises/day-3/solutions-morning.md:27
#, fuzzy
msgid ""
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
msgstr ""
"    /// Dibuja el widget en un b√∫fer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"

#: src/exercises/day-3/simple-gui.md:29
#: src/exercises/day-3/solutions-morning.md:30
#, fuzzy
msgid ""
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{}\", &buffer);\n"
"    }\n"
"}"
msgstr ""
"    /// Dibujar el widget en la salida est√°ndar.\n"
"    fn dibujar(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{}\", &buffer);\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:37
#: src/exercises/day-3/solutions-morning.md:38
#, fuzzy
msgid ""
"pub struct Label {\n"
"    label: String,\n"
"}"
msgstr ""
"Etiqueta de estructura de publicaci√≥n {\n"
"    etiqueta: Cadena,\n"
"}"

#: src/exercises/day-3/simple-gui.md:41
#: src/exercises/day-3/solutions-morning.md:42
#, fuzzy
msgid ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"Etiqueta impl {\n"
"    fn nuevo(etiqueta: &str) -> Etiqueta {\n"
"        Etiqueta {\n"
"            etiqueta: etiqueta.a_propiedad(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:49
#: src/exercises/day-3/solutions-morning.md:50
#, fuzzy
msgid ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"
msgstr ""
"Bot√≥n de estructura de publicaci√≥n {\n"
"    etiqueta: etiqueta,\n"
"    devoluci√≥n de llamada: Box<dyn FnMut()>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:54
#: src/exercises/day-3/solutions-morning.md:55
#, fuzzy
msgid ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"Bot√≥n impl {\n"
"    fn nuevo (etiqueta: &str, devoluci√≥n de llamada: Box<dyn FnMut()>) -> "
"Bot√≥n {\n"
"        Bot√≥n {\n"
"            etiqueta: Etiqueta::nuevo(etiqueta),\n"
"            llamar de vuelta,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:63
#: src/exercises/day-3/solutions-morning.md:64
#, fuzzy
msgid ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"
msgstr ""
"ventana de estructura pub {\n"
"    t√≠tulo: Cadena,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:68
#: src/exercises/day-3/solutions-morning.md:69
#, fuzzy
msgid ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"
msgstr ""
"ventana impl {\n"
"    fn nuevo(t√≠tulo: &str) -> Ventana {\n"
"        Ventana {\n"
"            t√≠tulo: t√≠tulo.a_propiedad(),\n"
"            widgets: Vec::nuevo(),\n"
"        }\n"
"    }"

#: src/exercises/day-3/simple-gui.md:76
#: src/exercises/day-3/solutions-morning.md:77
#, fuzzy
msgid ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"
msgstr ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:82
#, fuzzy
msgid ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"Widget impl para etiqueta {\n"
"    fn ancho(&self) -> usar {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97
#: src/exercises/day-3/simple-gui.md:107
#, fuzzy
msgid ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        sin implementar!()\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:92
#, fuzzy
msgid ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"Widget impl para bot√≥n {\n"
"    fn ancho(&self) -> usar {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:102
#, fuzzy
msgid ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"Widget impl para ventana {\n"
"    fn ancho(&self) -> usar {\n"
"        sin implementar!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:112
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI "
"demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Esta es una peque√±a demostraci√≥n "
"de GUI de texto.\")));\n"
"    ventana.add_widget(Cuadro::nuevo(Bot√≥n::nuevo(\n"
"        \"¬°Haz click en mi!\",\n"
"        Box::new(|| println!(\"¬°Hiciste clic en el bot√≥n!\")),\n"
"    )));\n"
"    ventana.dibujar();\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:123
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr "La salida del programa anterior puede ser algo simple como esto:"

#: src/exercises/day-3/simple-gui.md:125
#, fuzzy
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========"
msgstr ""
"```texto\n"
"========\n"
"Rust GUI Demostraci√≥n 1.23\n"
"========"

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "This is a small text GUI demo."
msgstr "Esta es una peque√±a demostraci√≥n de GUI de texto."

#: src/exercises/day-3/simple-gui.md:132
#, fuzzy
msgid "| Click me! |\n```"
msgstr "| ¬°Haz click en mi! |\n```"

#: src/exercises/day-3/simple-gui.md:135
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Si desea dibujar texto alineado, puede utilizar el\n"
"[rellenar/alinear](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"operadores de formato. En particular, observe c√≥mo puede rellenar con "
"diferentes\n"
"caracteres (aqu√≠ un `'/'`) y c√≥mo puede controlar la alineaci√≥n:"

#: src/exercises/day-3/simple-gui.md:140
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea ancho = 10;\n"
"    println!(\"alineado a la izquierda: |{:/<ancho$}|\", \"foo\");\n"
"    println!(\"centrado: |{:/^ancho$}|\", \"foo\");\n"
"    println!(\"alineado a la derecha: |{:/>ancho$}|\", \"foo\");\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:149
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Usando tales trucos de alineaci√≥n, puede, por ejemplo, producir resultados "
"como este:"

#: src/exercises/day-3/simple-gui.md:151
#, fuzzy
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""
"```texto\n"
"+--------------------------------+\n"
"| Rust GUI Demostraci√≥n 1.23 |\n"
"+================================+\n"
"| Esta es una peque√±a demostraci√≥n de GUI de texto. |\n"
"| +-----------+ |\n"
"| | ¬°Haz click en mi! | |\n"
"| +-----------+ |\n"
"+--------------------------------+\n"
"```"

#: src/error-handling.md:1
#, fuzzy
msgid "# Error Handling"
msgstr "# Manejo de errores"

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"El manejo de errores en Rust se realiza mediante un flujo de control "
"expl√≠cito:"

#: src/error-handling.md:5
#, fuzzy
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* Las funciones que pueden tener errores enumeran esto en su tipo de "
"retorno,\n"
"* No hay excepciones."

#: src/error-handling/panics.md:1
#, fuzzy
msgid "# Panics"
msgstr "# P√°nicos"

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Rust activar√° un p√°nico si ocurre un error fatal en el tiempo de ejecuci√≥n:"

#: src/error-handling/panics.md:5
#, fuzzy
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```oxidado,editable,should_panic\n"
"fn principal() {\n"
"    sea v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
#, fuzzy
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* Los p√°nicos son para errores inesperados e irrecuperables.\n"
"  * Los p√°nicos son s√≠ntomas de errores en el programa.\n"
"* Use API que no generen p√°nico (como `Vec::get`) si no se aceptan bloqueos."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "# Catching the Stack Unwinding"
msgstr "# Atrapando la pila desenroll√°ndose"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"De forma predeterminada, un p√°nico har√° que la pila se relaje. El "
"desenrollado se puede capturar:"

#: src/error-handling/panic-unwind.md:5
#, fuzzy
msgid "```rust\nuse std::panic;"
msgstr "```herrumbre\nusar std::panic;"

#: src/error-handling/panic-unwind.md:8
#, fuzzy
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hola!\");\n"
"});\n"
"afirmar!(resultado.is_ok());"

#: src/error-handling/panic-unwind.md:13
#, fuzzy
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    ¬°p√°nico! (\"¬°Oh, no!\");\n"
"});\n"
"afirmar!(resultado.is_err());\n"
"```"

#: src/error-handling/panic-unwind.md:19
#, fuzzy
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Esto puede ser √∫til en servidores que deber√≠an seguir ejecut√°ndose incluso "
"si un solo\n"
"  la solicitud falla.\n"
"* Esto no funciona si `panic = 'abort'` est√° configurado en su `Cargo.toml`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "# Structured Error Handling with `Result`"
msgstr "# Manejo estructurado de errores con `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are\n"
"expected as part of normal operation:"
msgstr ""
"Ya hemos visto la enumeraci√≥n 'Resultado'. Esto se usa de forma generalizada "
"cuando los errores son\n"
"esperado como parte de la operaci√≥n normal:"

#: src/error-handling/result.md:6
#, fuzzy
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"
msgstr ""
"```herrumbre\n"
"uso std::fs::Archivo;\n"
"usar std::io::Read;"

#: src/error-handling/result.md:10
#, fuzzy
msgid ""
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let archivo = Archivo::open(\"diario.txt\");\n"
"    archivo de coincidencia {\n"
"        Ok (archivo mut) => {\n"
"            let mut contenidos = String::new();\n"
"            file.read_to_string(&mut contenidos);\n"
"            println!(\"Querido diario: {contenido}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"No se pudo abrir el diario: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing "
"the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where "
"an error should never happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the "
"developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but "
"it is worth mentioning. \n"
"    It contains a lot of convenience methods and functions that help "
"functional-style programming. \n"
"    \n"
"</details>"
msgstr ""
"  * Al igual que con `Opci√≥n`, el valor exitoso se encuentra dentro de "
"`Resultado`, lo que obliga al desarrollador a\n"
"    extraerlo expl√≠citamente. Esto fomenta la comprobaci√≥n de errores. En el "
"caso en que nunca deber√≠a ocurrir un error,\n"
"    Se puede llamar a `unwrap()` o `expect()`, y esto tambi√©n es una se√±al "
"de la intenci√≥n del desarrollador.\n"
"  * La documentaci√≥n `Resultado` es una lectura recomendada. No durante el "
"curso, pero vale la pena mencionarlo.\n"
"    Contiene muchos m√©todos y funciones de conveniencia que ayudan a la "
"programaci√≥n de estilo funcional.\n"
"    \n"
"</detalles>"

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "# Propagating Errors with `?`"
msgstr "# Propagando errores con `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn\n"
"the common"
msgstr ""
"El operador de prueba `?` se utiliza para devolver errores a la persona que "
"llama. Te permite girar\n"
"lo com√∫n"

#: src/error-handling/try-operator.md:6
#, fuzzy
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""
"```oxidar, ignorar\n"
"coincide con alguna_expresi√≥n {\n"
"    Ok(valor) => valor,\n"
"    Err(err) => volver Err(err),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "en el mucho m√°s simple"

#: src/error-handling/try-operator.md:15
#, fuzzy
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""
"```oxidar, ignorar\n"
"alguna_expresi√≥n?\n"
"```"

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handing code:"
msgstr "Podemos usar esto para simplificar nuestro c√≥digo de manejo de errores:"

#: src/error-handling/try-operator.md:21
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"
msgstr ""
"```herrumbre, editable\n"
"usar std::fs;\n"
"use std::io::{self, Leer};"

#: src/error-handling/try-operator.md:25
#, fuzzy
msgid ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"
msgstr ""
"fn read_username(ruta: &str) -> Result<String, io::Error> {\n"
"    let nombre_usuario_archivo_resultado = fs::Archivo::abrir(ruta);"

#: src/error-handling/try-operator.md:28
#, fuzzy
msgid ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"
msgstr ""
"    let mut nombre_archivo_usuario = coincidencia nombre_archivo_resultado "
"{\n"
"        Ok(archivo) => archivo,\n"
"        Err(e) => devolver Err(e),\n"
"    };"

#: src/error-handling/try-operator.md:33
#, fuzzy
msgid "    let mut username = String::new();"
msgstr "    let mut nombre de usuario = String::new();"

#: src/error-handling/try-operator.md:35
#, fuzzy
msgid ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"
msgstr ""
"    coincidir con nombre_de_usuario.leer_en_cadena(&mutar nombre de usuario) "
"{\n"
"        Ok(_) => Ok(nombre de usuario),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"

#: src/error-handling/try-operator.md:41
#, fuzzy
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let nombreusuario = read_nombreusuario(\"config.dat\");\n"
"    println!(\"nombre de usuario o error: {nombre de usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:52
#: src/error-handling/converting-error-types.md:70
#, fuzzy
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, "
"empty file, file with username."
msgstr ""
"* La variable `nombre de usuario` puede ser `Ok(cadena)` o `Err(error)`.\n"
"* Use la llamada `fs::write` para probar los diferentes escenarios: sin "
"archivo, archivo vac√≠o, archivo con nombre de usuario."

#: src/error-handling/converting-error-types.md:1
#, fuzzy
msgid "# Converting Error Types"
msgstr "# Conversi√≥n de tipos de error"

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"La expansi√≥n efectiva de `?` es un poco m√°s complicada de lo indicado "
"anteriormente:"

#: src/error-handling/converting-error-types.md:5
#, fuzzy
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""
"```oxidar, ignorar\n"
"¬øexpresi√≥n?\n"
"```"

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "funciona igual que"

#: src/error-handling/converting-error-types.md:11
#, fuzzy
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""
"```oxidar, ignorar\n"
"expresi√≥n de coincidencia {\n"
"    Ok(valor) => valor,\n"
"    Err(err) => return Err(De::de(err)),\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to "
"the\n"
"type returned by the function:"
msgstr ""
"La llamada `From::from` aqu√≠ significa que intentamos convertir el tipo de "
"error al\n"
"tipo devuelto por la funci√≥n:"

#: src/error-handling/converting-error-types.md:21
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use std::fmt::{self, Display, Formatter};"
msgstr ""
"```herrumbre, editable\n"
"use std::error::Error;\n"
"usar std::{fs, io};\n"
"usar std::io::Read;\n"
"use std::fmt::{self, Display, Formatter};"

#: src/error-handling/converting-error-types.md:27
#, fuzzy
msgid ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derivar(Depurar)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    Nombre de usuario vac√≠o (cadena),\n"
"}"

#: src/error-handling/converting-error-types.md:33
#, fuzzy
msgid "impl Error for ReadUsernameError {}"
msgstr "Error impl para ReadUsernameError {}"

#: src/error-handling/converting-error-types.md:35
#, fuzzy
msgid ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {}\", filename),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"Pantalla impl para ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formateador) -> fmt::Resultado {\n"
"        coincidir con uno mismo {\n"
"            Self::IoError(e) => escribir!(f, \"Error de E/S: {}\", e),\n"
"            Self::EmptyUsername(nombre de archivo) => escribir!(f, \"No se "
"encontr√≥ ning√∫n nombre de usuario en {}\", nombre de archivo),\n"
"        }\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types.md:44
#, fuzzy
msgid ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"
msgstr ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types.md:50
#: src/error-handling/deriving-error-enums.md:19
#, fuzzy
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn read_username(ruta: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut nombre de usuario = String::with_capacity(100);\n"
"    fs::File::open(ruta)?.read_to_string(&mut nombre de usuario)?;\n"
"    si nombredeusuario.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Bien (nombre de usuario)\n"
"}"

#: src/error-handling/converting-error-types.md:59
#, fuzzy
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let nombreusuario = read_nombreusuario(\"config.dat\");\n"
"    println!(\"nombre de usuario o error: {nombre de usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:73
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, "
"which requires `Debug` and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too "
"where possible, to make\n"
"life easier for tests and consumers of your library. In this case we can't "
"easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"Es una buena pr√°ctica para todos los tipos de error implementar "
"`std::error::Error`, que requiere `Debug` y\n"
"`Pantalla`. En general, es √∫til para ellos implementar `Clone` y `Eq` "
"tambi√©n donde sea posible, para hacer\n"
"la vida m√°s f√°cil para las pruebas y los consumidores de su biblioteca. En "
"este caso no podemos hacerlo f√°cilmente, porque\n"
"`io::Error` no los implementa."

#: src/error-handling/deriving-error-enums.md:1
#, fuzzy
msgid "# Deriving Error Enums"
msgstr "# Derivaci√≥n de enumeraciones de errores"

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an\n"
"error enum like we did on the previous page:"
msgstr ""
"La caja [thiserror](https://docs.rs/thiserror/) es una forma popular de "
"crear un\n"
"enumeraci√≥n de error como hicimos en la p√°gina anterior:"

#: src/error-handling/deriving-error-enums.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"usar std::{fs, io};\n"
"usar std::io::Read;\n"
"usa este error::Error;"

#: src/error-handling/deriving-error-enums.md:11
#, fuzzy
msgid ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derivar(Depuraci√≥n, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"No se pudo leer: {0}\")]\n"
"    IoError(#[de] io::Error),\n"
"    #[error(\"No se encontr√≥ ning√∫n nombre de usuario en {0}\")]\n"
"    Nombre de usuario vac√≠o (cadena),\n"
"}"

#: src/error-handling/deriving-error-enums.md:28
#: src/error-handling/dynamic-errors.md:25
#, fuzzy
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    coincide con read_username(\"config.dat\") {\n"
"        Ok(nombre de usuario) => println!(\"Nombre de usuario: {nombre de "
"usuario}\"),\n"
"        Err(err) => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the "
"`#[from]` attribute is added).\n"
"It also works for structs."
msgstr ""
"La macro derivada de `thiserror` implementa autom√°ticamente "
"`std::error::Error`, y opcionalmente `Display`\n"
"(si se proporcionan los atributos `#[error(...)]`) y `From` (si se a√±ade el "
"atributo `#[from]`).\n"
"Tambi√©n funciona para estructuras."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "No afecta su API p√∫blica, lo que lo hace bueno para las bibliotecas."

#: src/error-handling/dynamic-errors.md:1
#, fuzzy
msgid "# Dynamic Error Types"
msgstr "# Tipos de errores din√°micos"

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"A veces queremos permitir que se devuelva cualquier tipo de error sin "
"escribir nuestra propia enumeraci√≥n que cubra\n"
"todas las diferentes posibilidades. `std::error::Error` lo hace f√°cil."

#: src/error-handling/dynamic-errors.md:6
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"use std::fs::{self, Archivo};\n"
"usar std::io::Read;\n"
"usa este error::Error;\n"
"use std::error::Error;"

#: src/error-handling/dynamic-errors.md:12
#, fuzzy
msgid ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);"
msgstr ""
"#[derivar(Clonar, Depurar, Equilibrar, Error, Equivalente parcial)]\n"
"#[error(\"No se encontr√≥ ning√∫n nombre de usuario en {0}\")]\n"
"struct EmptyUsernameError(String);"

#: src/error-handling/dynamic-errors.md:16
#, fuzzy
msgid ""
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn read_username(ruta: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut nombre de usuario = String::with_capacity(100);\n"
"    Archivo::abrir(ruta)?.read_to_string(&mut nombre de usuario)?;\n"
"    si nombredeusuario.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Bien (nombre de usuario)\n"
"}"

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` "
"in the public API of a\n"
"library, but it can be a good option in a program where you just want to "
"display the error message\n"
"somewhere."
msgstr ""
"Esto ahorra c√≥digo, pero renuncia a la capacidad de manejar limpiamente "
"diferentes casos de error de manera diferente en\n"
"el programa. Como tal, generalmente no es una buena idea usar `Box<dyn "
"Error>` en la API p√∫blica de un\n"
"biblioteca, pero puede ser una buena opci√≥n en un programa en el que solo "
"desea mostrar el mensaje de error\n"
"algun lado."

#: src/error-handling/error-contexts.md:1
#, fuzzy
msgid "# Adding Context to Errors"
msgstr "# Agregar contexto a los errores"

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"La caja ampliamente utilizada [de todos modos] (https://docs.rs/anyhow/) "
"puede ayudarlo a agregar\n"
"informaci√≥n contextual a sus errores y le permite tener menos\n"
"tipos de errores personalizados:"

#: src/error-handling/error-contexts.md:7
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"usar std::{fs, io};\n"
"usar std::io::Read;\n"
"usar de todos modos::{Contexto, Resultado, libertad bajo fianza};"

#: src/error-handling/error-contexts.md:12
#, fuzzy
msgid ""
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .context(format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn read_username(ruta: &str) -> Result<String> {\n"
"    let mut nombre de usuario = String::with_capacity(100);\n"
"    fs::Archivo::abrir(ruta)\n"
"        .context(formato!(\"Error al abrir {ruta}\"))?\n"
"        .read_to_string(&mut nombre de usuario)\n"
"        .context(\"Error al leer\"?);\n"
"    si nombredeusuario.is_empty() {\n"
"        bail!(\"No se encontr√≥ ning√∫n nombre de usuario en {ruta}\");\n"
"    }\n"
"    Bien (nombre de usuario)\n"
"}"

#: src/error-handling/error-contexts.md:24
#, fuzzy
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    coincide con read_username(\"config.dat\") {\n"
"        Ok(nombre de usuario) => println!(\"Nombre de usuario: {nombre de "
"usuario}\"),\n"
"        Err(err) => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not\n"
"  a good choice for the public API of a library, but is widely used in "
"applications.\n"
"* Actual error type inside of it can be extracted for examination if "
"necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `de todos modos::Resultado<V>` es un alias de tipo para `Resultado<V, de "
"todos modos::Error>`.\n"
"* `de todos modos::Error` es esencialmente un envoltorio alrededor de "
"`Box<dyn Error>`. Como tal, generalmente no es\n"
"  una buena opci√≥n para la API p√∫blica de una biblioteca, pero se usa mucho "
"en las aplicaciones.\n"
"* El tipo de error real dentro de √©l se puede extraer para examinarlo si es "
"necesario.\n"
"* La funcionalidad proporcionada por `anyhow::Result<T>` puede ser familiar "
"para los desarrolladores de Go, ya que proporciona\n"
"  patrones de uso y ergonom√≠a similares a `(T, error)` de Go."

#: src/testing.md:1
#, fuzzy
msgid "# Testing"
msgstr "# Pruebas"

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust y Cargo vienen con un marco de prueba de unidad simple:"

#: src/testing.md:5
#, fuzzy
msgid "* Unit tests are supported throughout your code."
msgstr "* Las pruebas unitarias se admiten en todo el c√≥digo."

#: src/testing.md:7
#, fuzzy
msgid "* Integration tests are supported via the `tests/` directory."
msgstr ""
"* Las pruebas de integraci√≥n son compatibles a trav√©s del directorio "
"`tests/`."

#: src/testing/unit-tests.md:1
#, fuzzy
msgid "# Unit Tests"
msgstr "# Pruebas unitarias"

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Marque las pruebas unitarias con `#[test]`:"

#: src/testing/unit-tests.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn primera_palabra(texto: &str) -> &str {\n"
"    coincidir con texto.find(' ') {\n"
"        Algunos(idx) => &texto[..idx],\n"
"        Ninguno => &texto,\n"
"    }\n"
"}"

#: src/testing/unit-tests.md:13
#, fuzzy
msgid ""
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}"
msgstr ""
"#[prueba]\n"
"fn prueba_vac√≠o() {\n"
"    afirmar_eq!(primera_palabra(\"\"), \"\");\n"
"}"

#: src/testing/unit-tests.md:18
#, fuzzy
msgid ""
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}"
msgstr ""
"#[prueba]\n"
"fn test_single_word() {\n"
"    afirmar_eq!(primera_palabra(\"Hola\"), \"Hola\");\n"
"}"

#: src/testing/unit-tests.md:23
#, fuzzy
msgid ""
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""
"#[prueba]\n"
"fn prueba_m√∫ltiples_palabras() {\n"
"    afirmar_eq!(primera_palabra(\"Hola Mundo\"), \"Hola\");\n"
"}\n"
"```"

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Use `cargo test` para encontrar y ejecutar las pruebas unitarias."

#: src/testing/test-modules.md:1
#, fuzzy
msgid "# Test Modules"
msgstr "# M√≥dulos de prueba"

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"Las pruebas unitarias a menudo se colocan en un m√≥dulo anidado (ejecutar "
"pruebas en el\n"
"[Patio de juegos](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"fn ayudante(a: &str, b: &str) -> Cadena {\n"
"    formato!(\"{a} {b}\")\n"
"}"

#: src/testing/test-modules.md:11
#, fuzzy
msgid ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}"
msgstr ""
"publicaci√≥n fn principal () {\n"
"    println!(\"{}\", ayudante(\"Hola\", \"Mundo\"));\n"
"}"

#: src/testing/test-modules.md:19
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    #[prueba]\n"
"    fn test_helper() {\n"
"        asert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"

#: src/testing/test-modules.md:26
#, fuzzy
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* Esto le permite realizar pruebas unitarias de ayudantes privados.\n"
"* El atributo `#[cfg(test)]` solo est√° activo cuando ejecuta `cargo test`."

#: src/testing/doc-tests.md:1
#, fuzzy
msgid "# Documentation Tests"
msgstr "# Pruebas de documentaci√≥n"

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust tiene soporte incorporado para pruebas de documentaci√≥n:"

#: src/testing/doc-tests.md:5
#, fuzzy
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""
"```herrumbre\n"
"/// Acorta una cadena a la longitud dada.\n"
"///\n"
"/// ```\n"
"/// usar parque infantil::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hola Mundo\", 5), \"Hola\");\n"
"/// assert_eq!(shorten_string(\"Hola Mundo\", 20), \"Hola Mundo\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, longitud: usar) -> &str {\n"
"    &s[..std::cmp::min(longitud, s.len())]\n"
"}\n"
"```"

#: src/testing/doc-tests.md:18
#, fuzzy
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust "
"Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* Los bloques de c√≥digo en los comentarios `///` se ven autom√°ticamente como "
"c√≥digo Rust.\n"
"* El c√≥digo ser√° compilado y ejecutado como parte de `cargo test`.\n"
"* Pruebe el c√≥digo anterior en [Rust "
"Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
#, fuzzy
msgid "# Integration Tests"
msgstr "# Pruebas de Integraci√≥n"

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Si desea probar su biblioteca como cliente, use una prueba de integraci√≥n."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Cree un archivo `.rs` en `tests/`:"

#: src/testing/integration-tests.md:7
#, fuzzy
msgid "```rust,ignore\nuse my_library::init;"
msgstr "```oxidar, ignorar\nuse mi_biblioteca::init;"

#: src/testing/integration-tests.md:10
#, fuzzy
msgid ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""
"#[prueba]\n"
"fn test_init() {\n"
"    afirmar!(init().is_ok());\n"
"}\n"
"```"

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Estas pruebas solo tienen acceso a la API p√∫blica de su caja."

#: src/unsafe.md:1
#, fuzzy
msgid "# Unsafe Rust"
msgstr "# √ìxido inseguro"

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "El lenguaje Rust tiene dos partes:"

#: src/unsafe.md:5
#, fuzzy
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"* **Safe Rust:** memoria segura, no es posible un comportamiento "
"indefinido.\n"
"* **Unsafe Rust:** puede desencadenar un comportamiento indefinido si se "
"violan las condiciones previas."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know\n"
"what Unsafe Rust is."
msgstr ""
"Veremos Rust mayormente seguro en este curso, pero es importante saber\n"
"qu√© es el √≥xido inseguro."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"El c√≥digo inseguro suele ser peque√±o y aislado, y su correcci√≥n debe ser "
"cuidadosamente\n"
"documentado. Por lo general, est√° envuelto en una capa de abstracci√≥n segura."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust le da acceso a cinco nuevas capacidades:"

#: src/unsafe.md:16
#, fuzzy
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Desreferenciar punteros sin procesar.\n"
"* Acceder o modificar variables est√°ticas mutables.\n"
"* Acceder a los campos `sindicatos`.\n"
"* Llame a funciones \"no seguras\", incluidas las funciones \"externas\".\n"
"* Implementar caracter√≠sticas \"inseguras\"."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please "
"see\n"
"[Chapter 19.1 in the Rust "
"Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"A continuaci√≥n, cubriremos brevemente las capacidades inseguras. Para "
"obtener detalles completos, consulte\n"
"[Cap√≠tulo 19.1 en Rust "
"Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"y el [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Unsafe Rust no significa que el c√≥digo sea incorrecto. Significa que los "
"desarrolladores tienen\n"
"apag√≥ las caracter√≠sticas de seguridad del compilador y tiene que escribir "
"el c√≥digo correcto por\n"
"ellos mismos. Significa que el compilador ya no aplica las reglas de "
"seguridad de memoria de Rust."

#: src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "# Dereferencing Raw Pointers"
msgstr "# Eliminaci√≥n de referencias de punteros sin procesar"

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "Crear punteros es seguro, pero desreferenciarlos requiere `no seguro`:"

#: src/unsafe/raw-pointers.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    sea mut num = 5;"

#: src/unsafe/raw-pointers.md:9
#, fuzzy
msgid "    let r1 = &mut num as *mut i32;\n    let r2 = &num as *const i32;"
msgstr "    sea r1 = &mut num como *mut i32;\n    sea r2 = &num como *const i32;"

#: src/unsafe/raw-pointers.md:12
#, fuzzy
msgid ""
"    // Safe because r1 and r2 were obtained from references and so are "
"guaranteed to be non-null and\n"
"    // properly aligned, the objects underlying the references from which "
"they were obtained are\n"
"    // live throughout the whole unsafe block, and they are not accessed "
"either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    // Seguro porque r1 y r2 se obtuvieron de las referencias y, por lo "
"tanto, se garantiza que no son nulos y\n"
"    // correctamente alineados, los objetos subyacentes a las referencias de "
"las que se obtuvieron son\n"
"    // viven a lo largo de todo el bloque inseguro, y tampoco se accede a "
"ellos a trav√©s del\n"
"    // referencias o simult√°neamente a trav√©s de cualquier otro puntero.\n"
"    inseguro {\n"
"        println!(\"r1 es: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 es: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/raw-pointers.md:26
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety "
"requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"Es una buena pr√°ctica (y requerido por la gu√≠a de estilo de Android Rust) "
"escribir un comentario para cada\n"
"bloque `inseguro` que explica c√≥mo el c√≥digo que contiene satisface los "
"requisitos de seguridad del inseguro\n"
"operaciones que est√° haciendo."

#: src/unsafe/raw-pointers.md:30
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"En el caso de desreferencias de punteros, esto significa que los punteros "
"deben ser\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), es decir:"

#: src/unsafe/raw-pointers.md:33
#, fuzzy
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object "
"must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * El puntero debe ser no nulo.\n"
" * El puntero debe ser _desreferenciable_ (dentro de los l√≠mites de un √∫nico "
"objeto asignado).\n"
" * El objeto no debe haber sido desasignado.\n"
" * No debe haber accesos concurrentes a la misma ubicaci√≥n.\n"
" * Si el puntero se obtuvo emitiendo una referencia, el objeto subyacente "
"debe estar activo y no\n"
"   la referencia se puede utilizar para acceder a la memoria."

#: src/unsafe/raw-pointers.md:40
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"En la mayor√≠a de los casos, el puntero tambi√©n debe estar correctamente "
"alineado."

#: src/unsafe/mutable-static-variables.md:1
#, fuzzy
msgid "# Mutable Static Variables"
msgstr "# Variables est√°ticas mutables"

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Es seguro leer una variable est√°tica inmutable:"

#: src/unsafe/mutable-static-variables.md:5
#, fuzzy
msgid "```rust,editable\nstatic HELLO_WORLD: &str = \"Hello, world!\";"
msgstr "```herrumbre, editable\nstatic HELLO_WORLD: &str = \"¬°Hola, mundo!\";"

#: src/unsafe/mutable-static-variables.md:8
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"HELLO_WORLD: {}\", HELLO_WORLD);\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    println!(\"HOLA_MUNDO: {}\", HOLA_MUNDO);\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"Sin embargo, dado que pueden ocurrir carreras de datos, no es seguro leer y "
"escribir datos mutables.\n"
"variables est√°ticas:"

#: src/unsafe/mutable-static-variables.md:16
#, fuzzy
msgid "```rust,editable\nstatic mut COUNTER: u32 = 0;"
msgstr "```herrumbre, editable\nCONTADOR mut est√°tico: u32 = 0;"

#: src/unsafe/mutable-static-variables.md:19
#, fuzzy
msgid ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}"
msgstr ""
"fn agregar_a_contador(inc: u32) {\n"
"    inseguro { CONTADOR += inc; } // ¬°Posible carrera de datos!\n"
"}"

#: src/unsafe/mutable-static-variables.md:23
#, fuzzy
msgid "fn main() {\n    add_to_counter(42);"
msgstr "fn principal() {\n    agregar_a_contador(42);"

#: src/unsafe/mutable-static-variables.md:26
#, fuzzy
msgid ""
"    unsafe { println!(\"COUNTER: {}\", COUNTER); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""
"    inseguro { println!(\"CONTADOR: {}\", CONTADOR); } // ¬°Posible carrera "
"de datos!\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working "
"with some C APIs."
msgstr ""
"Usar una est√°tica mutable es generalmente una mala idea, pero hay algunos "
"casos en los que podr√≠a tener sentido\n"
"en c√≥digo `no_std` de bajo nivel, como implementar un asignador de "
"almacenamiento din√°mico o trabajar con algunas API de C."

#: src/unsafe/unions.md:1
#, fuzzy
msgid "# Unions"
msgstr "# Sindicatos"

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Las uniones son como enumeraciones, pero debe realizar un seguimiento del "
"campo activo usted mismo:"

#: src/unsafe/unions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"#[repr(C)]\n"
"uni√≥n MiUni√≥n {\n"
"    yo: u8,\n"
"    b: bool,\n"
"}"

#: src/unsafe/unions.md:12
#, fuzzy
msgid ""
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea u = MiUni√≥n { i: 42 };\n"
"    println!(\"int: {}\", inseguro { u.i });\n"
"    println!(\"bool: {}\", inseguro { u.b }); // ¬°Comportamiento "
"indefinido!\n"
"}\n"
"```"

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed\n"
"for interacting with C library APIs."
msgstr ""
"Las uniones rara vez se necesitan en Rust, ya que generalmente puede usar "
"una enumeraci√≥n. Ocasionalmente se necesitan\n"
"para interactuar con las API de la biblioteca C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably "
"want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) "
"or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Si solo desea reinterpretar los bytes como un tipo diferente, probablemente "
"desee\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) "
"o una caja fuerte\n"
"envoltorio como el caj√≥n [`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
#, fuzzy
msgid "# Calling Unsafe Functions"
msgstr "# Llamar a funciones no seguras"

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Una funci√≥n o m√©todo se puede marcar como \"inseguro\" si tiene condiciones "
"previas adicionales que usted\n"
"debe mantener para evitar un comportamiento indefinido:"

#: src/unsafe/calling-unsafe-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";"
msgstr ""
"```herrumbre, editable\n"
"fn principal() {\n"
"    let emojis = \"üóª‚ààüåè\";"

#: src/unsafe/calling-unsafe-functions.md:10
#, fuzzy
msgid ""
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"{}\", emojis.get_unchecked(0..4));\n"
"        println!(\"{}\", emojis.get_unchecked(4..7));\n"
"        println!(\"{}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    // Seguro porque los √≠ndices est√°n en el orden correcto, dentro de los "
"l√≠mites de\n"
"    // el segmento de cadena y se encuentra en los l√≠mites de secuencia "
"UTF-8.\n"
"    inseguro {\n"
"        println!(\"{}\", emojis.get_unchecked(0..4));\n"
"        println!(\"{}\", emojis.get_unchecked(4..7));\n"
"        println!(\"{}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:1
#, fuzzy
msgid "# Writing Unsafe Functions"
msgstr "# Escribir funciones no seguras"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined\n"
"behaviour."
msgstr ""
"Puede marcar sus propias funciones como `inseguras` si requieren condiciones "
"particulares para evitar indefinidas\n"
"conducta."

#: src/unsafe/writing-unsafe-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"/// Intercambia los valores apuntados por los punteros dados.\n"
"///\n"
"/// # Seguridad\n"
"///\n"
"/// Los punteros deben ser v√°lidos y estar correctamente alineados.\n"
"intercambio inseguro de fn (a: *mut u8, b: *mut u8) {\n"
"    sea temp = *a;\n"
"    *a = *b;\n"
"    *b = temperatura;\n"
"}"

#: src/unsafe/writing-unsafe-functions.md:18
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"
msgstr ""
"fn principal() {\n"
"    sea mut a = 42;\n"
"    sea mut b = 66;"

#: src/unsafe/writing-unsafe-functions.md:22
#, fuzzy
msgid ""
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }"
msgstr ""
"    // Seguro porque...\n"
"    inseguro {\n"
"        intercambiar(&mut a, &mut b);\n"
"    }"

#: src/unsafe/writing-unsafe-functions.md:27
#, fuzzy
msgid ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"En realidad, no usar√≠amos punteros para esto porque se puede hacer de manera "
"segura con referencias."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see "
"what happens."
msgstr ""
"Tenga en cuenta que el c√≥digo inseguro est√° permitido dentro de una funci√≥n "
"insegura sin un bloque \"inseguro\". Podemos\n"
"proh√≠ba esto con `#[deny(unsafe_op_in_unsafe_fn)]`. Intente agregarlo y vea "
"qu√© sucede."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "# Calling External Code"
msgstr "# C√≥digo externo de llamada"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. "
"Calling\n"
"them is thus unsafe:"
msgstr ""
"Las funciones de otros lenguajes pueden violar las garant√≠as de Rust. "
"Vocaci√≥n\n"
"ellos es por lo tanto inseguro:"

#: src/unsafe/extern-functions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}"
msgstr ""
"```herrumbre, editable\n"
"externo \"C\" {\n"
"    fn abs(entrada: i32) -> i32;\n"
"}"

#: src/unsafe/extern-functions.md:11
#, fuzzy
msgid ""
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    inseguro {\n"
"        // Comportamiento indefinido si abs se porta mal.\n"
"        println!(\"Valor absoluto de -3 seg√∫n C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might\n"
"violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any\n"
"arbitrary circumstances."
msgstr ""
"Por lo general, esto es solo un problema para las funciones externas que "
"hacen cosas con punteros que podr√≠an\n"
"viola el modelo de memoria de Rust, pero en general cualquier funci√≥n C "
"puede tener un comportamiento indefinido bajo cualquier\n"
"circunstancias arbitrarias."

#: src/unsafe/extern-functions.md:25
#, fuzzy
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available "
"too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"La `\"C\"` en este ejemplo es el ABI;\n"
"[otras ABI tambi√©n est√°n disponibles] "
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "# Implementing Unsafe Traits"
msgstr "# Implementaci√≥n de rasgos inseguros"

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Al igual que con las funciones, puede marcar un rasgo como `inseguro` si la "
"implementaci√≥n debe garantizar\n"
"condiciones particulares para evitar un comportamiento indefinido."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like "
"this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Por ejemplo, la caja `zerocopy` tiene un rasgo inseguro que parece\n"
"[algo como esto] "
"(https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"
msgstr ""
"```herrumbre, editable\n"
"use std::mem::size_of_val;\n"
"usar std::slice;"

#: src/unsafe/unsafe-traits.md:13
#, fuzzy
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"/// ...\n"
"/// # Seguridad\n"
"/// El tipo debe tener una representaci√≥n definida y sin relleno.\n"
"pub rasgo inseguro AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        inseguro {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}"

#: src/unsafe/unsafe-traits.md:24
#, fuzzy
msgid ""
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""
"// Seguro porque u32 tiene una representaci√≥n definida y sin relleno.\n"
"AsBytes impl inseguros para u32 {}\n"
"```"

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Debe haber una secci√≥n `#Seguridad` en el Rustdoc para el rasgo que explique "
"los requisitos para\n"
"el rasgo que se implementar√° de forma segura."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"La secci√≥n de seguridad real para `AsBytes` es bastante m√°s larga y "
"complicada."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Las caracter√≠sticas integradas `Enviar` y `Sincronizar` no son seguras."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "# Day 3: Afternoon Exercises"
msgstr "# D√≠a 3: Ejercicios por la tarde"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr ""
"¬°Construyamos un envoltorio seguro para leer el contenido del directorio!"

#: src/exercises/day-3/afternoon.md:7
#, fuzzy
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "Despu√©s de ver el ejercicio, puede ver la [soluci√≥n] provista."

#: src/exercises/day-3/afternoon.md:9
#, fuzzy
msgid "[solution]: solutions-afternoon.md"
msgstr "[soluci√≥n]: soluciones-tarde.md"

#: src/exercises/day-3/safe-ffi-wrapper.md:1
#, fuzzy
msgid "# Safe FFI Wrapper"
msgstr "# Envoltura FFI segura"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust tiene un gran soporte para llamar a funciones a trav√©s de una funci√≥n "
"_foreign\n"
"interfaz_ (FFI). Usaremos esto para construir un envoltorio seguro para "
"`libc`\n"
"funciones que usar√≠a de C para leer los nombres de archivo de un directorio."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Querr√°s consultar las p√°ginas del manual:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`] module, particular for "
"[`CStr`]\n"
"and [`CString`] types which are used to hold NUL-terminated strings coming "
"from\n"
"C. The [Nomicon] also has a very useful chapter about FFI."
msgstr ""
"Tambi√©n querr√° explorar el m√≥dulo [`std::ffi`], en particular para [`CStr`]\n"
"y [`CString`] que se utilizan para contener cadenas terminadas en NUL "
"provenientes de\n"
"C. El [Nomicon] tambi√©n tiene un cap√≠tulo muy √∫til sobre FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:17
#, fuzzy
msgid ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
msgstr ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"functions and methods:"
msgstr ""
"Copie el c√≥digo a continuaci√≥n a <https://play.rust-lang.org/> y rellene lo "
"que falta\n"
"funciones y m√©todos:"

#: src/exercises/day-3/safe-ffi-wrapper.md:29
#, fuzzy
msgid ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""
"mod fi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#: src/exercises/day-3/safe-ffi-wrapper.md:32
#: src/exercises/day-3/solutions-afternoon.md:26
#, fuzzy
msgid ""
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, "
"core::marker::PhantomPinned)>,\n"
"    }"
msgstr ""
"    // Tipo opaco. Consulte https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _datos: [u8; 0],\n"
"        _marcador: n√∫cleo::marcador::PhantomData<(*mut u8, "
"n√∫cleo::marcador::PhantomPinned)>,\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:39
#: src/exercises/day-3/solutions-afternoon.md:33
#, fuzzy
msgid ""
"    // Layout as per readdir(3) and definitions in "
"/usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"
msgstr ""
"    // Dise√±o seg√∫n readdir(3) y definiciones en "
"/usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    direcci√≥n de estructura de pub {\n"
"        pub d_ino: c_largo,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_tipo: c_char,\n"
"        pub d_nombre: [c_char; 256],\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:49
#: src/exercises/day-3/solutions-afternoon.md:43
#, fuzzy
msgid ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"
msgstr ""
"    externo \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fnclosedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:56
#: src/exercises/day-3/solutions-afternoon.md:50
#, fuzzy
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"
msgstr ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"

#: src/exercises/day-3/safe-ffi-wrapper.md:59
#, fuzzy
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"
msgstr ""
"#[derivar(Depurar)]\n"
"struct DirectorioIterador {\n"
"    ruta: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:65
#, fuzzy
msgid ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl DirectoryIterator {\n"
"    fn new(ruta: &str) -> Result<DirectoryIterator, String> {\n"
"        // Llame a opendir y devuelva un valor Ok si funcion√≥,\n"
"        // de lo contrario, devuelve Err con un mensaje.\n"
"        sin implementar!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:73
#, fuzzy
msgid ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"Iterador impl para DirectoryIterator {\n"
"    escriba Elemento = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Contin√∫e llamando a readdir hasta que obtengamos un puntero NULL "
"de regreso.\n"
"        sin implementar!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:81
#, fuzzy
msgid ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl Drop para DirectoryIterator {\n"
"    fn drop(&mut auto) {\n"
"        // Llame a closedir seg√∫n sea necesario.\n"
"        sin implementar!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:88
#, fuzzy
msgid ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn principal() -> Resultado<(), Cadena> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"archivos: {:#?}\", iter.collect::<Vec<_>>());\n"
"    OK(())\n"
"}\n"
"```"

#: src/welcome-day-4.md:1
#, fuzzy
msgid "# Welcome to Day 4"
msgstr "# Bienvenido al D√≠a 4"

#: src/welcome-day-4.md:3
#, fuzzy
msgid "Today we will look at two main topics:"
msgstr "Hoy veremos dos temas principales:"

#: src/welcome-day-4.md:5
#, fuzzy
msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr ""
"* Concurrencia: subprocesos, canales, estado compartido, 'Enviar' y "
"'Sincronizar'."

#: src/welcome-day-4.md:7
#, fuzzy
msgid ""
"* Android: building binaries and libraries, using AIDL, logging, and\n"
"  interoperability with C, C++, and Java."
msgstr ""
"* Android: creaci√≥n de archivos binarios y bibliotecas, uso de AIDL, "
"registro y\n"
"  interoperabilidad con C, C++ y Java."

#: src/welcome-day-4.md:10
#, fuzzy
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try "
"to\n"
"> find a little corner of your code base where we can move some lines of "
"code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Intentaremos llamar a Rust desde uno de sus propios proyectos hoy. As√≠ que "
"trata de\n"
"> encuentre un peque√±o rinc√≥n de su base de c√≥digo donde podamos mover "
"algunas l√≠neas de c√≥digo a\n"
"> √ìxido. Cuantas menos dependencias y tipos \"ex√≥ticos\", mejor. Algo que\n"
"> analiza algunos bytes crudos ser√≠a ideal."

#: src/concurrency.md:1
#, fuzzy
msgid "# Fearless Concurrency"
msgstr "# Concurrencia sin miedo"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust tiene soporte completo para la concurrencia usando subprocesos del "
"sistema operativo con mutexes y\n"
"canales"

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency "
"bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"El sistema de tipos Rust juega un papel importante en la creaci√≥n de muchos "
"errores de concurrencia.\n"
"Errores de tiempo de compilaci√≥n. Esto a menudo se conoce como _concurrencia "
"intr√©pida_ ya que usted\n"
"puede confiar en el compilador para garantizar la correcci√≥n en tiempo de "
"ejecuci√≥n."

#: src/concurrency/threads.md:1
#, fuzzy
msgid "# Threads"
msgstr "# Hilos"

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr ""
"Los subprocesos de Rust funcionan de manera similar a los subprocesos en "
"otros idiomas:"

#: src/concurrency/threads.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```herrumbre, editable\n"
"usar est√°ndar::hilo;\n"
"use std::time::Duration;"

#: src/concurrency/threads.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"
msgstr ""
"fn principal() {\n"
"    hilo::spawn(|| {\n"
"        para i en 1..10 {\n"
"            println!(\"Cuenta en hilo: {i}!\");\n"
"            thread::sleep(Duraci√≥n::from_millis(5));\n"
"        }\n"
"    });"

#: src/concurrency/threads.md:17
#, fuzzy
msgid ""
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    para i en 1..5 {\n"
"        println!(\"Hilo principal: {i}\");\n"
"        thread::sleep(Duraci√≥n::from_millis(5));\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/threads.md:24
#, fuzzy
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* Los subprocesos son todos subprocesos daemon, el subproceso principal no "
"los espera.\n"
"* Los p√°nicos de subprocesos son independientes entre s√≠.\n"
"  * Los p√°nicos pueden llevar una carga √∫til, que se puede desempaquetar con "
"`downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"* Notice that the thread is stopped before it reaches 10 ‚Äî the main thread "
"is\n"
"  not waiting."
msgstr ""
"* Observe que el subproceso se detiene antes de llegar a 10: el subproceso "
"principal es\n"
"  sin esperar"

#: src/concurrency/threads.md:35
#, fuzzy
msgid ""
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait "
"for\n"
"  the thread to finish."
msgstr ""
"* Use `let handle = thread::spawn(...)` y luego `handle.join()` para "
"esperar\n"
"  el hilo para terminar."

#: src/concurrency/threads.md:38
#, fuzzy
msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "* Desencadena p√°nico en el hilo, observa c√≥mo esto no afecta a `main`."

#: src/concurrency/threads.md:40
#, fuzzy
msgid ""
"* Use the `Result` return value from `handle.join()` to get access to the "
"panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* Use el valor de retorno `Resultado` de `handle.join()` para obtener acceso "
"al p√°nico\n"
"  carga √∫til. Este es un buen momento para hablar sobre [`Any`]."

#: src/concurrency/threads.md:43
#, fuzzy
msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
msgstr "[`Cualquiera`]: https://doc.rust-lang.org/std/any/index.html"

#: src/concurrency/scoped-threads.md:1
#, fuzzy
msgid "# Scoped Threads"
msgstr "# subprocesos con alcance"

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Los subprocesos normales no pueden tomar prestado de su entorno:"

#: src/concurrency/scoped-threads.md:5
#, fuzzy
msgid "```rust,editable,compile_fail\nuse std::thread;"
msgstr "```herrumbre, editable, falla_compilaci√≥n\nusar est√°ndar::hilo;"

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
#, fuzzy
msgid "fn main() {\n    let s = String::from(\"Hello\");"
msgstr "fn principal() {\n    let s = String::from(\"Hola\");"

#: src/concurrency/scoped-threads.md:11
#, fuzzy
msgid ""
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""
"    hilo::spawn(|| {\n"
"        println!(\"Longitud: {}\", s.len());\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "Sin embargo, puede usar un [subproceso con √°mbito][1] para esto:"

#: src/concurrency/scoped-threads.md:19
#, fuzzy
msgid "```rust,editable\nuse std::thread;"
msgstr "```herrumbre, editable\nusar est√°ndar::hilo;"

#: src/concurrency/scoped-threads.md:25
#, fuzzy
msgid ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""
"    subproceso::alcance(|alcance| {\n"
"        alcance.spawn(|| {\n"
"            println!(\"Longitud: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:33
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
msgstr "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"

#: src/concurrency/scoped-threads.md:35
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* The reason for that is that when the `thread::scope` function completes, "
"all the threads are guaranteed to be joined, so they can return borrowed "
"data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads.\n"
"    \n"
"</details>"
msgstr ""
"<detalles>\n"
"    \n"
"* La raz√≥n de esto es que cuando la funci√≥n `thread::scope` se completa, se "
"garantiza que todos los hilos se unir√°n, para que puedan devolver datos "
"prestados.\n"
"* Se aplican las reglas normales de pr√©stamo de Rust: puede pedir prestado "
"de forma mutable por un hilo o inmutable por cualquier cantidad de hilos.\n"
"    \n"
"</detalles>"

#: src/concurrency/channels.md:1
#, fuzzy
msgid "# Channels"
msgstr "# Canales"

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"Los canales de Rust tienen dos partes: un `Sender<T>` y un `Receiver<T>`. "
"las dos partes\n"
"est√°n conectados a trav√©s del canal, pero solo ves los puntos finales."

#: src/concurrency/channels.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"
msgstr ""
"```herrumbre, editable\n"
"usar std::sync::mpsc;\n"
"usar est√°ndar::hilo;"

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
#, fuzzy
msgid "fn main() {\n    let (tx, rx) = mpsc::channel();"
msgstr "fn principal() {\n    let (tx, rx) = mpsc::canal();"

#: src/concurrency/channels.md:13
#, fuzzy
msgid "    tx.send(10).unwrap();\n    tx.send(20).unwrap();"
msgstr "    tx.send(10).unwrap();\n    tx.send(20).unwrap();"

#: src/concurrency/channels.md:16
#, fuzzy
msgid ""
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());"
msgstr ""
"    println!(\"Recibido: {:?}\", rx.recv());\n"
"    println!(\"Recibido: {:?}\", rx.recv());"

#: src/concurrency/channels.md:19
#, fuzzy
msgid ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""
"    sea tx2 = tx.clone();\n"
"    tx2.send(30).desenvolver();\n"
"    println!(\"Recibido: {:?}\", rx.recv());\n"
"}\n"
"```"

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and "
"`SyncSender` implement `Clone` (so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` significa Multi-Productor, Single-Consumer. `Sender` y `SyncSender` "
"implementan `Clone` (as√≠ que\n"
"  puede crear varios productores), pero `Receiver` no.\n"
"* `send()` y `recv()` devuelven `Resultado`. Si devuelven 'Err', significa "
"la contraparte 'Remitente' o\n"
"  Se cae `Receiver` y se cierra el canal."

#: src/concurrency/channels/unbounded.md:1
#, fuzzy
msgid "# Unbounded Channels"
msgstr "# Canales Ilimitados"

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Obtienes un canal ilimitado y as√≠ncrono con `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
#: src/concurrency/channels/bounded.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```herrumbre, editable\n"
"usar std::sync::mpsc;\n"
"usar est√°ndar::hilo;\n"
"use std::time::Duration;"

#: src/concurrency/channels/unbounded.md:13
#: src/concurrency/channels/bounded.md:13
#, fuzzy
msgid ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"
msgstr ""
"    hilo::spawn(mover || {\n"
"        let hilo_id = hilo::actual().id();\n"
"        para i en 1..10 {\n"
"            tx.send(formato!(\"Mensaje {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: mensaje enviado {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: hecho\");\n"
"    });\n"
"    thread::sleep(Duraci√≥n::from_millis(100));"

#: src/concurrency/channels/unbounded.md:23
#: src/concurrency/channels/bounded.md:23
#, fuzzy
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    para mensaje en rx.iter() {\n"
"        println!(\"Principal: obtuve {}\", mensaje);\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "# Bounded Channels"
msgstr "# Canales delimitados"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr ""
"Los canales acotados y sincr√≥nicos hacen que `send` bloquee el hilo actual:"

#: src/concurrency/channels/bounded.md:10
#, fuzzy
msgid "fn main() {\n    let (tx, rx) = mpsc::sync_channel(3);"
msgstr "fn principal() {\n    let (tx, rx) = mpsc::sync_channel(3);"

#: src/concurrency/shared_state.md:1
#, fuzzy
msgid "# Shared State"
msgstr "# Estado compartido"

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This "
"is\n"
"primarily done via two types:"
msgstr ""
"Rust usa el sistema de tipos para hacer cumplir la sincronizaci√≥n de datos "
"compartidos. Este es\n"
"principalmente a trav√©s de dos tipos:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between "
"threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], referencia at√≥mica contada `T`: maneja compartir entre "
"hilos y\n"
"  se encarga de desasignar `T` cuando se elimina la √∫ltima referencia,\n"
"* [`Mutex<T>`][2]: garantiza acceso mutuamente exclusivo al valor `T`."

#: src/concurrency/shared_state.md:10
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "# `Arc`"
msgstr "# `Arco`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via its `clone` method:"
msgstr ""
"[`Arc<T>`][1] permite el acceso compartido de solo lectura a trav√©s de su "
"m√©todo `clone`:"

#: src/concurrency/shared_state/arc.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;"
msgstr ""
"```herrumbre, editable\n"
"usar est√°ndar::hilo;\n"
"usar std::sync::Arc;"

#: src/concurrency/shared_state/arc.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"
msgstr ""
"fn principal() {\n"
"    sea v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    para _ en 1..5 {\n"
"        sea v = v.clon();\n"
"        handles.push(hilo::spawn(mover || {\n"
"            let hilo_id = hilo::actual().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"

#: src/concurrency/shared_state/arc.md:20
#, fuzzy
msgid ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/arc.md:25
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of "
"`Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to "
"detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` significa \"Referencia at√≥mica contada\", una versi√≥n segura para "
"subprocesos de `Rc` que usa at√≥mica\n"
"  operaciones.\n"
"* `Arc<T>` implementa `Clone` ya sea que `T` lo haga o no. Implementa `Send` "
"y `Sync` iff `T`\n"
"  los implementa a ambos.\n"
"* `Arc::clone()` tiene el costo de las operaciones at√≥micas que se ejecutan, "
"pero despu√©s de eso, el uso del\n"
"  'T' es libre.\n"
"* Cuidado con los ciclos de referencia, `Arc` no utiliza un recolector de "
"basura para detectarlos.\n"
"    * `std::sync::Weak` puede ayudar."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] garantiza la exclusi√≥n mutua _y_ permite el acceso mutable a "
"`T`\n"
"detr√°s de una interfaz de solo lectura:"

#: src/concurrency/shared_state/mutex.md:6
#, fuzzy
msgid "```rust,editable\nuse std::sync::Mutex;"
msgstr "```herrumbre, editable\nusar std::sync::Mutex;"

#: src/concurrency/shared_state/mutex.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"
msgstr ""
"fn principal() {\n"
"    sea v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.bloquear().desenvolver());"

#: src/concurrency/shared_state/mutex.md:13
#, fuzzy
msgid ""
"    {\n"
"        let v: &Mutex<Vec<i32>> = &v;\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"
msgstr ""
"    {\n"
"        sea v: &Mutex<Vec<i32>> = &v;\n"
"        let mut guard = v.lock().unwrap();\n"
"        guardia.push(40);\n"
"    }"

#: src/concurrency/shared_state/mutex.md:19
#, fuzzy
msgid ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""
"    println!(\"v: {:?}\", v.bloquear().desenvolver());\n"
"}\n"
"```"

#: src/concurrency/shared_state/mutex.md:23
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"Observe c√≥mo tenemos una manta [`impl<T: Send> Sync for Mutex<T>`][2]\n"
"implementaci√≥n."

#: src/concurrency/shared_state/mutex.md:26
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: "
"https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: "
"https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/mutex.md:30
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* `Mutex` in Rust looks like a collection with just one element - the "
"protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the "
"protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that\n"
"      the data it protected might be in an inconsistent state. Calling "
"`lock()` on a poisoned mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error "
"to recover the data\n"
"      regardless."
msgstr ""
"<detalles>\n"
"    \n"
"* `Mutex` en Rust parece una colecci√≥n con un solo elemento: los datos "
"protegidos.\n"
"    * No es posible olvidar adquirir el mutex antes de acceder a los datos "
"protegidos.\n"
"* Puedes obtener un `&mut T` de un `&Mutex<T>` tomando el candado. El "
"`MutexGuard` asegura que el\n"
"  `&mut T` no sobrevive al bloqueo que se mantiene.\n"
"* `Mutex<T>` implementa `Send` y `Sync` iff `T` implementa `Send`.\n"
"* Una contrapartida de bloqueo de lectura y escritura - `RwLock`.\n"
"* ¬øPor qu√© `lock()` devuelve un `Resultado`?\n"
"    * Si el subproceso que conten√≠a el 'Mutex' entra en p√°nico, el 'Mutex' "
"se \"envenena\" para indicar que\n"
"      los datos que proteg√≠a podr√≠an estar en un estado inconsistente. "
"Llamar a `lock()` en un mutex envenenado\n"
"      falla con un [`PoisonError`]. Puede llamar a `into_inner()` en el "
"error para recuperar los datos\n"
"      a pesar de todo."

#: src/concurrency/shared_state/mutex.md:44
#, fuzzy
msgid ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  "
"\n"
"    \n"
"</details>"
msgstr ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html\n"
"    \n"
"</detalles>"

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Veamos `Arc` y `Mutex` en acci√≥n:"

#: src/concurrency/shared_state/example.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"
msgstr ""
"```herrumbre, editable, falla_compilaci√≥n\n"
"usar est√°ndar::hilo;\n"
"// usa std::sync::{Arc, Mutex};"

#: src/concurrency/shared_state/example.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"
msgstr ""
"fn principal() {\n"
"    sea mut v = vec![10, 20, 30];\n"
"    let handle = hilo::spawn(|| {\n"
"        v. empujar (10);\n"
"    });\n"
"    v.push(1000);"

#: src/concurrency/shared_state/example.md:16
#, fuzzy
msgid ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"    manejar.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/example.md:23
#, fuzzy
msgid ""
"Possible solution:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"
msgstr ""
"Soluci√≥n posible:\n"
"    \n"
"```herrumbre, editable\n"
"use std::sync::{Arc, Mutex};\n"
"usar est√°ndar::hilo;"

#: src/concurrency/shared_state/example.md:29
#, fuzzy
msgid "fn main() {\n    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
msgstr ""
"fn principal() {\n"
"    sea v = Arc::nuevo(Mutex::nuevo(vec![10, 20, 30]));"

#: src/concurrency/shared_state/example.md:32
#, fuzzy
msgid ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"
msgstr ""
"    let v2 = v.clon();\n"
"    let handle = thread::spawn(mover || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"

#: src/concurrency/shared_state/example.md:38
#, fuzzy
msgid ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"
msgstr ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"

#: src/concurrency/shared_state/example.md:43
#, fuzzy
msgid "    handle.join().unwrap();"
msgstr "    manejar.join().unwrap();"

#: src/concurrency/shared_state/example.md:45
#, fuzzy
msgid ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Notable parts:"
msgstr ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Partes notables:"

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable "
"state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible.\n"
"* We still need to acquire the `Mutex` to print our `Vec`."
msgstr ""
"* `v` est√° envuelto tanto en `Arc` como en `Mutex`, porque sus "
"preocupaciones son ortogonales.\n"
"  * Envolver un `Mutex` en un `Arco` es un patr√≥n com√∫n para compartir el "
"estado mutable entre subprocesos.\n"
"* `v: Arc<_>` debe clonarse como `v2` antes de poder moverlo a otro "
"subproceso. Nota `mover` se agreg√≥ a la firma lambda.\n"
"* Se introducen bloques para reducir el alcance de `LockGuard` tanto como "
"sea posible.\n"
"* Todav√≠a necesitamos adquirir el `Mutex` para imprimir nuestro `Vec`."

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "# `Send` and `Sync`"
msgstr "# `Enviar` y `Sincronizar`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"¬øC√≥mo sabe Rust que debe prohibir el acceso compartido entre subprocesos? La "
"respuesta est√° en dos rasgos:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a "
"thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a "
"thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: un tipo `T` es `Send` si es seguro mover una `T` a trav√©s de "
"un hilo\n"
"  Per√≠metro.\n"
"* [`Sync`][2]: un tipo `T` es `Sync` si es seguro mover un `&T` a trav√©s de "
"un hilo\n"
"  Per√≠metro."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically "
"derive them for your types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement "
"them manually when you\n"
"know it is valid."
msgstr ""
"`Enviar` y `Sincronizar` son [caracter√≠sticas inseguras][3]. El compilador "
"los derivar√° autom√°ticamente para sus tipos\n"
"siempre y cuando solo contengan los tipos `Enviar` y `Sincronizar`. Tambi√©n "
"puede implementarlos manualmente cuando\n"
"saber que es v√°lido."

#: src/concurrency/send-sync.md:14
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"
msgstr ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../inseguro/inseguro-traits.md"

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain "
"thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  \n"
"</details>"
msgstr ""
"* Uno puede pensar en estos rasgos como marcadores de que el tipo tiene "
"ciertas propiedades de seguridad para subprocesos.\n"
"* Se pueden utilizar en las restricciones gen√©ricas como rasgos normales.\n"
"  \n"
"</detalles>"

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "# `Send`"
msgstr "# `Enviar`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Send`][1] if it is safe to move a `T` value to another "
"thread."
msgstr ""
"> Un tipo `T` es [`Send`][1] si es seguro mover un valor `T` a otro hilo."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run\n"
"in that thread. So the question is when you can allocate a value in one "
"thread\n"
"and deallocate it in another."
msgstr ""
"El efecto de mover la propiedad a otro subproceso es que _destructors_ se "
"ejecutar√°\n"
"en ese hilo. Entonces, la pregunta es cu√°ndo puede asignar un valor en un "
"hilo\n"
"y desasignarlo en otro."

#: src/concurrency/send-sync/send.md:9
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "# `Sync`"
msgstr "# `Sincronizar`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from "
"multiple\n"
"> threads at the same time."
msgstr ""
"> Un tipo `T` es [`Sync`][1] si es seguro acceder a un valor `T` desde "
"m√∫ltiples\n"
"> hilos al mismo tiempo."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "M√°s precisamente, la definici√≥n es:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` es `Sync` si y solo si `&T` es `Send`"

#: src/concurrency/send-sync/sync.md:10
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Esta declaraci√≥n es esencialmente una forma abreviada de decir que si un "
"tipo es seguro para subprocesos para uso compartido, tambi√©n es seguro para "
"subprocesos pasar referencias de √©l entre subprocesos."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Esto se debe a que si un tipo es Sync, significa que se puede compartir en "
"varios subprocesos sin riesgo de carreras de datos u otros problemas de "
"sincronizaci√≥n, por lo que es seguro moverlo a otro subproceso. Tambi√©n es "
"seguro mover una referencia al tipo a otro subproceso, ya que se puede "
"acceder a los datos a los que hace referencia desde cualquier subproceso de "
"forma segura."

#: src/concurrency/send-sync/examples.md:1
#, fuzzy
msgid "# Examples"
msgstr "# Ejemplos"

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "## `Send + Sync`"
msgstr "## `Enviar + Sincronizar`"

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "La mayor√≠a de los tipos con los que te encuentras son `Send + Sync`:"

#: src/concurrency/send-sync/examples.md:7
#, fuzzy
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `estructura { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Expl√≠citamente seguro para subprocesos a trav√©s del recuento de "
"referencias at√≥micas.\n"
"* `Mutex<T>`: Expl√≠citamente seguro para subprocesos mediante bloqueo "
"interno.\n"
"* `AtomicBool`, `AtomicU8`, ...: Utiliza instrucciones at√≥micas especiales."

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"Los tipos gen√©ricos suelen ser `Send + Sync` cuando los par√°metros de tipo "
"son\n"
"`Enviar + Sincronizar`."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "## `Send + !Sync`"
msgstr "## `Enviar + !Sincronizar`"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Estos tipos se pueden mover a otros subprocesos, pero no son seguros para "
"subprocesos.\n"
"T√≠picamente debido a la mutabilidad interior:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Remitente<T>`\n"
"* `mpsc::Receptor<T>`\n"
"* `Celda<T>`\n"
"* `RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "## `!Send + Sync`"
msgstr "## `!Enviar + Sincronizar`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Estos tipos son seguros para subprocesos, pero no se pueden mover a otro "
"subproceso:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on "
"the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: utiliza primitivas de nivel de sistema operativo que se "
"deben desasignar en el\n"
"  hilo que los cre√≥."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "## `!Send + !Sync`"
msgstr "## `!Enviar + !Sincronizar`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Estos tipos no son seguros para subprocesos y no se pueden mover a otros "
"subprocesos:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: cada `Rc<T>` tiene una referencia a un `RcBox<T>`, que contiene "
"un\n"
"  cuenta de referencia no at√≥mica.\n"
"* `*const T`, `*mut T`: Rust asume que los punteros en bruto pueden tener\n"
"  consideraciones de concurrencia."

#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
#, fuzzy
msgid "# Exercises"
msgstr "# Ejercicios"

#: src/exercises/day-4/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Practiquemos nuestras nuevas habilidades de concurrencia con"

#: src/exercises/day-4/morning.md:5
#, fuzzy
msgid "* Dining philosophers: a classic problem in concurrency."
msgstr "* Comedor de fil√≥sofos: un problema cl√°sico en la concurrencia."

#: src/exercises/day-4/morning.md:7
#, fuzzy
msgid ""
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Comprobador de enlaces de subprocesos m√∫ltiples: un proyecto m√°s grande en "
"el que usar√° Cargo para\n"
"  descargue las dependencias y luego verifique los enlaces en paralelo."

#: src/exercises/day-4/dining-philosophers.md:1
#, fuzzy
msgid "# Dining Philosophers"
msgstr "# Fil√≥sofos Comedores"

#: src/exercises/day-4/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"El problema de los fil√≥sofos comedores es un problema cl√°sico de "
"concurrencia:"

#: src/exercises/day-4/dining-philosophers.md:5
#, fuzzy
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has "
"their\n"
"> own place at the table. There is a fork between each plate. The dish "
"served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher "
"can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat "
"their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will "
"only\n"
"> be available when their two nearest neighbors are thinking, not eating. "
"After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Cinco fil√≥sofos cenan juntos en la misma mesa. Cada fil√≥sofo tiene su\n"
"> lugar propio en la mesa. Hay un tenedor entre cada plato. El plato que se "
"sirve es\n"
"> una especie de espagueti que hay que comer con dos tenedores. Todo "
"fil√≥sofo puede\n"
"> S√≥lo pensar y comer alternativamente. Adem√°s, un fil√≥sofo s√≥lo puede "
"comerse sus\n"
"> espaguetis cuando tienen tenedor derecho e izquierdo. Por lo tanto, dos "
"tenedores solo\n"
"> estar disponible cuando sus dos vecinos m√°s cercanos est√©n pensando, no "
"comiendo. Despu√©s\n"
"> un fil√≥sofo individual termina de comer, dejar√° ambos tenedores."

#: src/exercises/day-4/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for\n"
"this exercise. Copy the code below to `src/main.rs` file, fill out the "
"blanks,\n"
"and test that `cargo run` does not deadlock:"
msgstr ""
"Necesitar√° una [instalaci√≥n de carga] local (../../cargo/running-locally.md) "
"para\n"
"este ejercicio. Copie el c√≥digo a continuaci√≥n en el archivo `src/main.rs`, "
"complete los espacios en blanco,\n"
"y prueba que `cargo run` no se interbloquea:"

#: src/exercises/day-4/dining-philosophers.md:17
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```herrumbre, falla_compilaci√≥n\n"
"usar std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"usar est√°ndar::hilo;\n"
"use std::time::Duration;"

#: src/exercises/day-4/dining-philosophers.md:23
#: src/exercises/day-4/solutions-morning.md:28
#, fuzzy
msgid "struct Fork;"
msgstr "horquilla de estructura;"

#: src/exercises/day-4/dining-philosophers.md:25
#, fuzzy
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}"
msgstr ""
"Fil√≥sofo de la estructura {\n"
"    nombre: cadena,\n"
"    // horquilla_izquierda: ...\n"
"    // bifurcaci√≥n_derecha: ...\n"
"    // pensamientos: ...\n"
"}"

#: src/exercises/day-4/dining-philosophers.md:32
#, fuzzy
msgid ""
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }"
msgstr ""
"Fil√≥sofo impl {\n"
"    fn piensa(&self) {\n"
"        pensamientos propios\n"
"            .send(format!(\"¬°Eureka! {} tiene una nueva idea!\", "
"&self.name))\n"
"            .desenvolver();\n"
"    }"

#: src/exercises/day-4/dining-philosophers.md:39
#, fuzzy
msgid ""
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""
"    fn comer(&yo) {\n"
"        // Recoger tenedores...\n"
"        println!(\"{} est√° comiendo...\", &self.name);\n"
"        thread::sleep(Duraci√≥n::from_millis(10));\n"
"    }\n"
"}"

#: src/exercises/day-4/dining-philosophers.md:46
#: src/exercises/day-4/solutions-morning.md:60
#, fuzzy
msgid ""
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
msgstr ""
"FIL√ìSOFOS est√°ticos: &[&str] =\n"
"    &[\"S√≥crates\", \"Plat√≥n\", \"Arist√≥teles\", \"Thales\", \"Pit√°goras\"];"

#: src/exercises/day-4/dining-philosophers.md:49
#, fuzzy
msgid "fn main() {\n    // Create forks"
msgstr "fn principal() {\n    // Crear bifurcaciones"

#: src/exercises/day-4/dining-philosophers.md:52
#, fuzzy
msgid "    // Create philosophers"
msgstr "    // Crear fil√≥sofos"

#: src/exercises/day-4/dining-philosophers.md:54
#, fuzzy
msgid "    // Make them think and eat"
msgstr "    // Hazlos pensar y comer"

#: src/exercises/day-4/dining-philosophers.md:56
#, fuzzy
msgid ""
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""
"    // Emitir sus pensamientos\n"
"}\n"
"```"

#: src/exercises/day-4/link-checker.md:1
#, fuzzy
msgid "# Multi-threaded Link Checker"
msgstr "# Comprobador de enlaces de subprocesos m√∫ltiples"

#: src/exercises/day-4/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until "
"all\n"
"pages have been validated."
msgstr ""
"Usemos nuestro nuevo conocimiento para crear un verificador de enlaces de "
"subprocesos m√∫ltiples. Deber√≠a\n"
"Comience en una p√°gina web y verifique que los enlaces en la p√°gina sean "
"v√°lidos. Deber√≠a\n"
"revise recursivamente otras p√°ginas en el mismo dominio y siga haciendo esto "
"hasta que todas\n"
"Las p√°ginas han sido validadas."

#: src/exercises/day-4/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Para ello, necesitar√° un cliente HTTP como [`reqwest`][1]. Crear un nuevo\n"
"Cargo project y `reqwest` como una dependencia con:"

#: src/exercises/day-4/link-checker.md:11
#, fuzzy
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""
"```concha\n"
"$ cargo nuevo verificador de enlaces\n"
"$ CD verificador de enlaces\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"

#: src/exercises/day-4/link-checker.md:17
#, fuzzy
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit "
"the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Si `cargo add` falla con `error: no such subcommand`, edite el\n"
"> Archivo `Cargo.toml` a mano. Agregue las dependencias que se enumeran a "
"continuaci√≥n."

#: src/exercises/day-4/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr ""
"Tambi√©n necesitar√° una forma de encontrar enlaces. Podemos usar "
"[`scraper`][2] para eso:"

#: src/exercises/day-4/link-checker.md:22
#, fuzzy
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""
"```concha\n"
"$ carga agregar raspador\n"
"```"

#: src/exercises/day-4/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] "
"for\n"
"that:"
msgstr ""
"Finalmente, necesitaremos alguna forma de manejar los errores. Usamos "
"[`thiserror`][3] para\n"
"eso:"

#: src/exercises/day-4/link-checker.md:29
#, fuzzy
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""
"```concha\n"
"$ cargo agrega este error\n"
"```"

#: src/exercises/day-4/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Las llamadas `cargo add` actualizar√°n el archivo `Cargo.toml` para que se "
"vea as√≠:"

#: src/exercises/day-4/link-checker.md:35
#, fuzzy
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] "
"}\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[dependencias]\n"
"reqwest = { versi√≥n = \"0.11.12\", caracter√≠sticas = [\"bloqueo\", "
"\"rustls-tls\"] }\n"
"raspador = \"0.13.0\"\n"
"este error = \"1.0.37\"\n"
"```"

#: src/exercises/day-4/link-checker.md:42
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Ahora puede descargar la p√°gina de inicio. Pruebe con un sitio peque√±o como\n"
"`https://www.google.org/`."

#: src/exercises/day-4/link-checker.md:45
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Su archivo `src/main.rs` deber√≠a verse as√≠:"

#: src/exercises/day-4/link-checker.md:47
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"
msgstr ""
"```herrumbre, falla_compilaci√≥n\n"
"use reqwest::blocking::{get, Response};\n"
"utilizar solicitud::Url;\n"
"usar scraper::{Html, Selector};\n"
"usa este error::Error;"

#: src/exercises/day-4/link-checker.md:53
#, fuzzy
msgid ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"
msgstr ""
"#[derivar(Error, Depurar)]\n"
"error de enumeraci√≥n {\n"
"    #[error(\"solicitud de error: {0}\")]\n"
"    ReqwestError(#[de] reqwest::Error),\n"
"}"

#: src/exercises/day-4/link-checker.md:59
#, fuzzy
msgid ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"
msgstr ""
"fn extract_links(respuesta: Respuesta) -> Resultado<Vec<Url>, Error> {\n"
"    let base_url = respuesta.url().a_propiedad();\n"
"    let documento = respuesta.texto(?);\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"

#: src/exercises/day-4/link-checker.md:65
#, fuzzy
msgid ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: "
"{err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"
msgstr ""
"    let mut valid_urls = Vec::new();\n"
"    para elemento en html.select(&selector) {\n"
"        if let Some(href) = elemento.valor().attr(\"href\") {\n"
"            coincide con base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"En {base_url}: no se pudo analizar {href:?}: "
"{err} (ignorado)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"

#: src/exercises/day-4/link-checker.md:77
#, fuzzy
msgid "    Ok(valid_urls)\n}"
msgstr "    Ok (URL_v√°lidas)\n}"

#: src/exercises/day-4/link-checker.md:80
#, fuzzy
msgid ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let respuesta = get(start_url).unwrap();\n"
"    coincidir con extract_links(respuesta) {\n"
"        Ok(enlaces) => println!(\"Enlaces: {enlaces:#?}\"),\n"
"        Err(err) => println!(\"No se pudieron extraer los enlaces: "
"{err:#}\"),\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-4/link-checker.md:90
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Ejecute el c√≥digo en `src/main.rs` con"

#: src/exercises/day-4/link-checker.md:92
#, fuzzy
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""
"```concha\n"
"$ carrera de carga\n"
"```"

#: src/exercises/day-4/link-checker.md:96
#, fuzzy
msgid "## Tasks"
msgstr "## Tareas"

#: src/exercises/day-4/link-checker.md:98
#, fuzzy
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to "
"a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that "
"you\n"
"  don't end up being blocked by the site."
msgstr ""
"* Use hilos para verificar los enlaces en paralelo: env√≠e las URL para "
"verificar a un\n"
"  channel y deje que algunos subprocesos verifiquen las URL en paralelo.\n"
"* Ampliar esto para extraer recursivamente enlaces de todas las p√°ginas en "
"el\n"
"  Dominio `www.google.org`. Ponga un l√≠mite superior de 100 p√°ginas m√°s o "
"menos para que pueda\n"
"  no termines siendo bloqueado por el sitio."

#: src/exercises/day-4/link-checker.md:104
#, fuzzy
msgid ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"
msgstr ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/esteerror/"

#: src/android.md:1
#, fuzzy
msgid "# Android"
msgstr "#android"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust es compatible con el desarrollo de plataformas nativas en Android. Esto "
"significa que\n"
"puede escribir nuevos servicios del sistema operativo en Rust, as√≠ como "
"ampliar\n"
"servicios existentes."

#: src/android/setup.md:1
#, fuzzy
msgid "# Setup"
msgstr "# Configuraci√≥n"

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have\n"
"access to one or create a new one with:"
msgstr ""
"Usaremos un dispositivo virtual de Android para probar nuestro c√≥digo. "
"Aseg√∫rate de tener\n"
"accede a uno o crea uno nuevo con:"

#: src/android/setup.md:6
#, fuzzy
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""
"```concha\n"
"$ compilaci√≥n fuente/envsetup.sh\n"
"$ almuerzo aosp_cf_x86_64_phone-userdebug\n"
"$ una nube crear\n"
"```"

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Consulte el [Desarrollador de Android\n"
"Codelab](https://source.android.com/docs/setup/start) para obtener m√°s "
"detalles."

#: src/android/build-rules.md:1
#, fuzzy
msgid "# Build Rules"
msgstr "# Reglas de construcci√≥n"

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"El sistema de compilaci√≥n de Android (Soong) es compatible con Rust a trav√©s "
"de varios m√≥dulos:"

#: src/android/build-rules.md:5
#, fuzzy
msgid ""
"| Module Type       | Description                                            "
"                                            |\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust binary.                                "
"                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and "
"`dylib` variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and "
"provides both static and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are "
"analogous to compiler plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard "
"Rust test harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging `libfuzzer`.    "
"                                            |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that "
"provides an interface for a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library "
"containing Rust bindings to C libraries.              |"
msgstr ""
"| Tipo de m√≥dulo | Descripci√≥n |\n"
"|----------------------------------|------------------------------------------- "
"-------------------------------------------------- ---------------------|\n"
"| `rust_binary` | Produce un binario Rust. |\n"
"| `rust_library` | Produce una biblioteca Rust y proporciona las variantes "
"`rlib` y `dylib`. |\n"
"| `rust_ffi` | Produce una biblioteca de Rust C utilizable por m√≥dulos `cc` "
"y proporciona variantes tanto est√°ticas como compartidas. |\n"
"| `rust_proc_macro` | Produce una biblioteca Rust `proc-macro`. Estos son "
"an√°logos a los complementos del compilador. |\n"
"| `prueba_de_√≥xido` | Produce un binario de prueba de Rust que utiliza el "
"arn√©s de prueba de Rust est√°ndar. |\n"
"| `rust_fuzz` | Produce un binario Rust fuzz aprovechando `libfuzzer`. |\n"
"| `rust_protobuf` | Genera fuente y produce una biblioteca de Rust que "
"proporciona una interfaz para un protobuf en particular. |\n"
"| `rust_bindgen` | Genera fuente y produce una biblioteca de Rust que "
"contiene enlaces de Rust a bibliotecas C. |"

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Veremos `rust_binary` y `rust_library` a continuaci√≥n."

#: src/android/build-rules/binary.md:1
#, fuzzy
msgid "# Rust Binaries"
msgstr "# Binarios de √≥xido"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create\n"
"the following files:"
msgstr ""
"Comencemos con una aplicaci√≥n simple. En la ra√≠z de un pago AOSP, cree\n"
"los siguientes archivos:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"hola_rust\",\n"
"    crate_name: \"hola_√≥xido\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
#, fuzzy
msgid "```rust\n//! Rust demo."
msgstr "```herrumbre\n//! Demostraci√≥n de √≥xido."

#: src/android/build-rules/binary.md:21
#, fuzzy
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""
"/// Imprime un saludo en la salida est√°ndar.\n"
"fn principal() {\n"
"    println!(\"¬°Hola desde Rust!\");\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Ahora puede compilar, enviar y ejecutar el binario:"

#: src/android/build-rules/binary.md:29
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""
"```concha\n"
"$ m hola_√≥xido\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"¬°Hola desde Rust!\n"
"```"

#: src/android/build-rules/library.md:1
#, fuzzy
msgid "# Rust Libraries"
msgstr "# Bibliotecas de √≥xido"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"Usas `rust_library` para crear una nueva biblioteca de Rust para Android."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Aqu√≠ declaramos una dependencia en dos bibliotecas:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, que definimos a continuaci√≥n,\n"
"* `libtextwrap`, que es una caja ya vendida en\n"
"  [`externo/√≥xido/cajas/`][cajas]."

#: src/android/build-rules/library.md:11
#, fuzzy
msgid ""
"[crates]: "
"https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
msgstr ""
"[cajas]: "
"https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"

#: src/android/build-rules/library.md:15
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"hola_rust_con_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libsaludos\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: cierto,\n"
"}"

#: src/android/build-rules/library.md:27
#, fuzzy
msgid ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""
"biblioteca_oxidada {\n"
"    nombre: \"libsaludos\",\n"
"    crate_name: \"saludos\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/library.md:36
#, fuzzy
msgid "```rust,ignore\n//! Rust demo."
msgstr "```oxidar, ignorar\n//! Demostraci√≥n de √≥xido."

#: src/android/build-rules/library.md:39
#, fuzzy
msgid "use greetings::greeting;\nuse textwrap::fill;"
msgstr "utilizar saludos::saludo;\nusar ajuste de texto::llenar;"

#: src/android/build-rules/library.md:42
#, fuzzy
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""
"/// Imprime un saludo en la salida est√°ndar.\n"
"fn principal() {\n"
"    println!(\"{}\", fill(&saludo(\"Bob\"), 24));\n"
"}\n"
"```"

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hola_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
#, fuzzy
msgid "```rust,ignore\n//! Greeting library."
msgstr "```oxidar, ignorar\n//! Biblioteca de saludos."

#: src/android/build-rules/library.md:53
#, fuzzy
msgid ""
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""
"/// Saludar `nombre`.\n"
"pub fn saludo(nombre: &str) -> Cadena {\n"
"    format!(\"Hola {nombre}, ¬°encantado de conocerte!\")\n"
"}\n"
"```"

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Construyes, empujas y ejecutas el binario como antes:"

#: src/android/build-rules/library.md:61
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""
"```concha\n"
"$ m hola_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hola Bob, es muy\n"
"¬°Encantada de conocerte!\n"
"```"

#: src/android/aidl.md:1
#, fuzzy
msgid "# AIDL"
msgstr "#AIDL"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in "
"Rust:"
msgstr ""
"El [Lenguaje de definici√≥n de la interfaz de Android\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) es compatible "
"con Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* El c√≥digo Rust puede llamar a los servidores AIDL existentes,\n"
"* Puedes crear nuevos servidores AIDL en Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "# AIDL Interfaces"
msgstr "# Interfaces AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Declaras la API de tu servicio usando una interfaz AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr ""
"*servicio_de_cumplea√±os/aidl/com/ejemplo/serviciodecumplea√±os/ServicioDeCumplea√±os.aidl*:"

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
#, fuzzy
msgid "```java\npackage com.example.birthdayservice;"
msgstr "```java\npaquete com.ejemplo.serviciodecumplea√±os;"

#: src/android/aidl/interface.md:10
#, fuzzy
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""
"/** Interfaz de servicio de cumplea√±os. */\n"
"interfaz ICumplea√±osServicio {\n"
"    /** Generar un mensaje de feliz cumplea√±os. */\n"
"    String deseoFelizCumplea√±os(String nombre, int a√±os);\n"
"}\n"
"```"

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*servicio_de_cumplea√±os/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
#, fuzzy
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"interfaz_aidl {\n"
"    nombre: \"com.ejemplo.serviciodecumplea√±os\",\n"
"    srcs: [\"com/ejemplo/serviciodecumplea√±os/*.aidl\"],\n"
"    inestable: cierto,\n"
"    back-end: {\n"
"        rust: { // Rust no est√° habilitado por defecto\n"
"            habilitado: verdadero,\n"
"        },\n"
"    },\n"
"}\n"
"```"

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor\n"
"partition."
msgstr ""
"Agregue `vendor_disponible: true` si su archivo AIDL es utilizado por un "
"binario en el proveedor\n"
"dividir."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "# Service Implementation"
msgstr "# Implementaci√≥n del servicio"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Ahora podemos implementar el servicio AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "*birthday_service/src/lib.rs*:"
msgstr "*servicio_de_cumplea√±os/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```oxidar, ignorar\n"
"//! Implementaci√≥n de la interfaz AIDL `IbirthdayService`.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IbirthdayService::IbirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/implementation.md:12
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\npub struct BirthdayService;"
msgstr ""
"/// La implementaci√≥n de `IbirthdayService`.\n"
"estructura pub BirthdayService;"

#: src/android/aidl/implementation.md:15
#, fuzzy
msgid "impl binder::Interface for BirthdayService {}"
msgstr "carpeta impl::Interfaz para BirthdayService {}"

#: src/android/aidl/implementation.md:17
#, fuzzy
msgid ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> "
"binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} "
"years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""
"impl ICumplea√±osServicio para Cumplea√±osServicio {\n"
"    fn deseoFelizCumplea√±os(&self, nombre: &str, a√±os: i32) -> "
"binder::Result<String> {\n"
"        Ok(formato!(\n"
"            \"¬°Feliz cumplea√±os {nombre}, felicidades por los {a√±os} "
"a√±os!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
#, fuzzy
msgid "*birthday_service/Android.bp*:"
msgstr "*servicio_de_cumplea√±os/Android.bp*:"

#: src/android/aidl/implementation.md:28
#, fuzzy
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"biblioteca_oxidada {\n"
"    nombre: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"servicio de cumplea√±os\",\n"
"    rustlibs: [\n"
"        \"com.ejemplo.servicio-de-cumplea√±os-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"

#: src/android/aidl/server.md:1
#, fuzzy
msgid "# AIDL Server"
msgstr "# Servidor AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "Finalmente, podemos crear un servidor que expone el servicio:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "*birthday_service/src/server.rs*:"
msgstr "*servicio_de_cumplea√±os/src/servidor.rs*:"

#: src/android/aidl/server.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```oxidar, ignorar\n"
"//! Servicio de cumplea√±os.\n"
"usar servicio de cumplea√±os:: Servicio de cumplea√±os;\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IbirthdayService::BnbirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
#, fuzzy
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr "const IDENTIFICADOR_SERVICIO: &str = \"serviciocumplea√±os\";"

#: src/android/aidl/server.md:15
#, fuzzy
msgid ""
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, "
"birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""
"/// Punto de entrada para el servicio de cumplea√±os.\n"
"fn principal() {\n"
"    let servicio_cumplea√±os = ServicioCumplea√±os;\n"
"    let birthday_service_binder = Bnbirthdayservice::new_binder(\n"
"        servicio_de_cumplea√±os,\n"
"        carpeta::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, "
"birthday_service_binder.as_binder())\n"
"        .expect(\"Error al registrar el servicio\");\n"
"    enlazador::ProcessState::join_thread_pool()\n"
"}\n"
"```"

#: src/android/aidl/server.md:30
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"servidor_de_cumplea√±os\",\n"
"    crate_name: \"servidor_de_cumplea√±os\",\n"
"    srcs: [\"src/servidor.rs\"],\n"
"    rustlibs: [\n"
"        \"com.ejemplo.servicio-de-cumplea√±os-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: cierto,\n"
"}\n"
"```"

#: src/android/aidl/deploy.md:1
#, fuzzy
msgid "# Deploy"
msgstr "# Desplegar"

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Ahora podemos compilar, impulsar e iniciar el servicio:"

#: src/android/aidl/deploy.md:5
#, fuzzy
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```concha\n"
"$ m cumplea√±os_servidor\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "En otra terminal, verifique que el servicio se ejecute:"

#: src/android/aidl/deploy.md:13
#, fuzzy
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""
"```concha\n"
"$ adb shell service comprobar servicio de cumplea√±os\n"
"Servicio servicio de cumplea√±os: encontrado\n"
"```"

#: src/android/aidl/deploy.md:18
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "Tambi√©n puede llamar al servicio con `llamada de servicio`:"

#: src/android/aidl/deploy.md:20
#, fuzzy
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""
"```concha\n"
"$ $ servicio de shell adb llamada servicio de cumplea√±os 1 s16 Bob i32 24\n"
"Resultado: Paquete(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6... H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .Beto.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'con .la.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .a√±o.'\n"
"  0x00000070: 00210073 00000000's.!.....')\n"
"```"

#: src/android/aidl/client.md:1
#, fuzzy
msgid "# AIDL Client"
msgstr "# Cliente AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "Finalmente, podemos crear un cliente Rust para nuestro nuevo servicio."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "*birthday_service/src/client.rs*:"
msgstr "*servicio_de_cumplea√±os/src/client.rs*:"

#: src/android/aidl/client.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```oxidar, ignorar\n"
"//! Servicio de cumplea√±os.\n"
"use "
"com_example_birthdayservice::aidl::com::example::birthdayservice::IbirthdayService::IbirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/client.md:14
#, fuzzy
msgid ""
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, "
"binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"
msgstr ""
"/// Con√©ctese al servicio de cumplea√±os.\n"
"pub fn connect() -> Result<binder::Strong<dyn IbirthService>, "
"binder::StatusCode> {\n"
"    carpeta::get_interface(SERVICIO_IDENTIFICADOR)\n"
"}"

#: src/android/aidl/client.md:19
#, fuzzy
msgid ""
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"
msgstr ""
"/// Llama al servicio de cumplea√±os.\n"
"fn main() -> Resultado<(), carpeta::Estado> {\n"
"    let nombre = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let a√±os = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"

#: src/android/aidl/client.md:29
#, fuzzy
msgid ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"    enlazador::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Error al conectarse a "
"BirthdayService\");\n"
"    let msg = servicio.deseoFelizCumplea√±os(&nombre, a√±os)?;\n"
"    println!(\"{mensaje}\");\n"
"    OK(())\n"
"}\n"
"```"

#: src/android/aidl/client.md:39
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"cumplea√±os_cliente\",\n"
"    crate_name: \"cumplea√±os_cliente\",\n"
"    srcs: [\"src/cliente.rs\"],\n"
"    rustlibs: [\n"
"        \"com.ejemplo.servicio-de-cumplea√±os-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: cierto,\n"
"}\n"
"```"

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Tenga en cuenta que el cliente no depende de `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Compile, env√≠e y ejecute el cliente en su dispositivo:"

#: src/android/aidl/client.md:56
#, fuzzy
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""
"```concha\n"
"$ m cumplea√±os_cliente\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"¬°Feliz cumplea√±os Charlie, felicidades por los 60 a√±os!\n"
"```"

#: src/android/aidl/changing.md:1
#, fuzzy
msgid "# Changing API"
msgstr "# Cambio de API"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Ampliemos la API con m√°s funciones: queremos permitir que los clientes "
"especifiquen un\n"
"lista de l√≠neas para la tarjeta de cumplea√±os:"

#: src/android/aidl/changing.md:9
#, fuzzy
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""
"/** Interfaz de servicio de cumplea√±os. */\n"
"interfaz ICumplea√±osServicio {\n"
"    /** Generar un mensaje de feliz cumplea√±os. */\n"
"    String deseoFelizCumplea√±os(String nombre, int a√±os, en String[] "
"texto);\n"
"}\n"
"```"

#: src/android/logging.md:1
#, fuzzy
msgid "# Logging"
msgstr "# Inicio sesi√≥n"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or\n"
"`stdout` (on-host):"
msgstr ""
"Debe usar la caja `log` para iniciar sesi√≥n autom√°ticamente en `logcat` (en "
"el dispositivo) o\n"
"`stdout` (en el host):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"hola_rust_logs\",\n"
"    crate_name: \"hola_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: cierto,\n"
"    host_supported: verdadero,\n"
"}\n"
"```"

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
#, fuzzy
msgid "```rust,ignore\n//! Rust logging demo."
msgstr "```oxidar, ignorar\n//! Demostraci√≥n de registro de √≥xido."

#: src/android/logging.md:27
#, fuzzy
msgid "use log::{debug, error, info};"
msgstr "use log::{depuraci√≥n, error, informaci√≥n};"

#: src/android/logging.md:29
#, fuzzy
msgid ""
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""
"/// Registra un saludo.\n"
"fn principal() {\n"
"    registrador::init(\n"
"        registrador::Config::predeterminado()\n"
"            .with_tag_on_device(\"√≥xido\")\n"
"            .with_min_level(registro::Nivel::Rastreo),\n"
"    );\n"
"    debug!(\"Iniciando programa.\");\n"
"    info!(\"Las cosas van bien.\");\n"
"    error!(\"¬°Algo sali√≥ mal!\");\n"
"}\n"
"```"

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Compile, env√≠e y ejecute el binario en su dispositivo:"

#: src/android/logging.md:44
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```concha\n"
"$ m hola_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Los registros aparecen en `adb logcat`:"

#: src/android/logging.md:52
#, fuzzy
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""
"```concha\n"
"$ adb logcat -s √≥xido\n"
"09-08 08:38:32.454 2420 2420 D rust: hello_rust_logs: programa de inicio.\n"
"09-08 08:38:32.454 2420 2420 I rust: hello_rust_logs: Las cosas van bien.\n"
"09-08 08:38:32.454 2420 2420 E rust: hello_rust_logs: ¬°Algo sali√≥ mal!\n"
"```"

#: src/android/interoperability.md:1
#, fuzzy
msgid "# Interoperability"
msgstr "# Interoperabilidad"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means\n"
"that you can:"
msgstr ""
"Rust tiene un excelente soporte para la interoperabilidad con otros "
"lenguajes. Esto significa\n"
"que tu puedes:"

#: src/android/interoperability.md:6
#, fuzzy
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Llamar a funciones de Rust desde otros idiomas.\n"
"* Funciones de llamada escritas en otros idiomas de Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Cuando llamas a funciones en un idioma extranjero, decimos que est√°s usando "
"un\n"
"_interfaz de funciones extranjeras_, tambi√©n conocida como FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "# Interoperability with C"
msgstr "# Interoperabilidad con C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust tiene soporte completo para vincular archivos de objetos con una "
"convenci√≥n de llamadas C.\n"
"Del mismo modo, puede exportar funciones de Rust y llamarlas desde C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Puedes hacerlo a mano si quieres:"

#: src/android/interoperability/with-c.md:8
#, fuzzy
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"
msgstr ""
"```herrumbre\n"
"externo \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"

#: src/android/interoperability/with-c.md:13
#, fuzzy
msgid ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    sea x = -42;\n"
"    let abs_x = inseguro { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"Ya vimos esto en el [Safe FFI Wrapper\n"
"ejercicio](../../exercises/day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Esto supone un conocimiento completo de la plataforma de destino. No "
"recomendado para\n"
"> producci√≥n."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "Veremos mejores opciones a continuaci√≥n."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "# Using Bindgen"
msgstr "# Uso de Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"La herramienta "
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)\n"
"puede generar enlaces autom√°ticamente a partir de un archivo de encabezado C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Primero cree una peque√±a biblioteca C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperabilidad/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
#, fuzzy
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"
msgstr ""
"```c\n"
"tarjeta de estructura typedef {\n"
"  const char* nombre;\n"
"  int a√±os;\n"
"} tarjeta;"

#: src/android/interoperability/with-c/bindgen.md:16
#, fuzzy
msgid "void print_card(const card* card);\n```"
msgstr "void imprimir_tarjeta(const tarjeta* tarjeta);\n```"

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperabilidad/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
#, fuzzy
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\""
msgstr ""
"```c\n"
"#incluir <stdio.h>\n"
"#include \"libbirthday.h\""

#: src/android/interoperability/with-c/bindgen.md:25
#, fuzzy
msgid ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n"
"\");\n"
"  printf(\"| Happy Birthday %s!\\n"
"\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n"
"\", card->years);\n"
"  printf(\"+--------------\\n"
"\");\n"
"}\n"
"```"
msgstr ""
"void imprimir_tarjeta(const tarjeta* tarjeta) {\n"
"  printf(\"+--------------\\n"
"\");\n"
"  printf(\"| ¬°Feliz cumplea√±os %s!\\n"
"\", tarjeta->nombre);\n"
"  printf(\"| ¬°Felicitaciones por los %i a√±os!\\n"
"\", tarjeta->a√±os);\n"
"  printf(\"+--------------\\n"
"\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Agregue esto a su archivo `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperabilidad/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
#, fuzzy
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"biblioteca_cc {\n"
"    nombre: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Cree un archivo de encabezado contenedor para la biblioteca (no es "
"estrictamente necesario en este\n"
"ejemplo):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperabilidad/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
#, fuzzy
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Ahora puede generar autom√°ticamente los enlaces:"

#: src/android/interoperability/with-c/bindgen.md:57
#, fuzzy
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_bindgen {\n"
"    nombre: \"libbirthday_bindgen\",\n"
"    crate_name: \"cumplea√±os_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"enlaces\",\n"
"    static_libs: [\"libcumplea√±os\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Finalmente, podemos usar los enlaces en nuestro programa Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"√≥xido_binario {\n"
"    nombre: \"imprimir_tarjeta_de_cumplea√±os\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperabilidad/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
#, fuzzy
msgid "```rust,compile_fail\n//! Bindgen demo."
msgstr "```herrumbre, falla_compilaci√≥n\n//! Demostraci√≥n de Bindgen."

#: src/android/interoperability/with-c/bindgen.md:84
#, fuzzy
msgid "use birthday_bindgen::{card, print_card};"
msgstr "use birthday_bindgen::{card, print_card};"

#: src/android/interoperability/with-c/bindgen.md:86
#, fuzzy
msgid ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn principal() {\n"
"    let nombre = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    dejar carta = carta {\n"
"        nombre: nombre.as_ptr(),\n"
"        a√±os: 42,\n"
"    };\n"
"    inseguro {\n"
"        imprimir_tarjeta(&tarjeta como *const tarjeta);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:100
#, fuzzy
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```concha\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card "
"/data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Finalmente, podemos ejecutar pruebas generadas autom√°ticamente para "
"garantizar que los enlaces funcionen:"

#: src/android/interoperability/with-c/bindgen.md:110
#, fuzzy
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"prueba_√≥xido {\n"
"    nombre: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"pruebas-generales\"],\n"
"    auto_gen_config: verdadero,\n"
"    clippy_lints: \"ninguno\", // Archivo generado, omitir pelusa\n"
"    pelusas: \"ninguna\",\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:122
#, fuzzy
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""
"```concha\n"
"$ atest libbirthday_bindgen_test\n"
"```"

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "# Calling Rust"
msgstr "# Llamando a √≥xido"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportar funciones y tipos de Rust a C es f√°cil:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperabilidad/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]"
msgstr ""
"```herrumbre, editable\n"
"//! Demostraci√≥n de Rust FFI.\n"
"#![negar(improper_ctypes_definitions)]"

#: src/android/interoperability/with-c/rust.md:11
#, fuzzy
msgid "use std::os::raw::c_int;"
msgstr "use std::os::raw::c_int;"

#: src/android/interoperability/with-c/rust.md:13
#, fuzzy
msgid ""
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"/// Analiza los n√∫meros.\n"
"#[no_mangle]\n"
"pub externo \"C\" fn analizar_n√∫meros (x: c_int, y: c_int) {\n"
"    si x < y {\n"
"        println!(\"x ({x}) es el menor!\");\n"
"    } m√°s {\n"
"        println!(\"y ({y}) es probablemente mayor que x ({x})\");\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperabilidad/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
#, fuzzy
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"
msgstr ""
"```c\n"
"#ifndef ANALIZAR_H\n"
"#definir ANALIZAR_H"

#: src/android/interoperability/with-c/rust.md:30
#, fuzzy
msgid ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"
msgstr ""
"externo \"C\" {\n"
"void analizar_numeros(int x, int y);\n"
"}"

#: src/android/interoperability/with-c/rust.md:34
#, fuzzy
msgid "#endif\n```"
msgstr "#terminara si\n```"

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperabilidad/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
#, fuzzy
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi {\n"
"    nombre: \"libanalyze_ffi\",\n"
"    crate_name: \"analizar_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    incluir_directorios: [\".\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Ahora podemos llamar a esto desde un binario C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperabilidad/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md:52
#, fuzzy
msgid "```c\n#include \"analyze.h\""
msgstr "```c\n#include \"analizar.h\""

#: src/android/interoperability/with-c/rust.md:55
#, fuzzy
msgid ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""
"int principal() {\n"
"  analizar_numeros(10, 20);\n"
"  analizar_numeros(123, 123);\n"
"  devolver 0;\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperabilidad/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
#, fuzzy
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_binario {\n"
"    nombre: \"analizar_n√∫meros\",\n"
"    srcs: [\"principal.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:75
#, fuzzy
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```concha\n"
"$ m analizar_n√∫meros\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify "
"whatever name you want."
msgstr ""
"`#[no_mangle]` deshabilita la manipulaci√≥n de nombres habitual de Rust, por "
"lo que el s√≠mbolo exportado ser√° solo el nombre de\n"
"la funci√≥n. Tambi√©n puedes usar `#[export_name = \"some_name\"]` para "
"especificar el nombre que quieras."

#: src/android/interoperability/cpp.md:1
#, fuzzy
msgid "# With C++"
msgstr "# Con C++"

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between "
"Rust\n"
"and C++."
msgstr ""
"La [caja CXX][1] hace posible la interoperabilidad segura entre Rust\n"
"y C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "El enfoque general se ve as√≠:"

#: src/android/interoperability/cpp.md:8
#, fuzzy
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/resumen.svg\">"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr ""
"Consulte el [tutorial de CXX][2] para ver un ejemplo completo del uso de "
"esto."

#: src/android/interoperability/cpp.md:12
#, fuzzy
msgid "[1]: https://cxx.rs/\n[2]: https://cxx.rs/tutorial.html"
msgstr "[1]: https://cxx.rs/\n[2]: https://cxx.rs/tutorial.html"

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "# Interoperability with Java"
msgstr "# Interoperabilidad con Java"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java puede cargar objetos compartidos a trav√©s de [Interfaz nativa de Java\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). El [`jni`\n"
"crate](https://docs.rs/jni/) le permite crear una biblioteca compatible."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Primero, creamos una funci√≥n de Rust para exportar a Java:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperabilidad/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
#, fuzzy
msgid "```rust,compile_fail\n//! Rust <-> Java FFI demo."
msgstr "```herrumbre, falla_compilaci√≥n\n//! Demostraci√≥n de Rust <-> Java FFI."

#: src/android/interoperability/java.md:14
#, fuzzy
msgid ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"
msgstr ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"

#: src/android/interoperability/java.md:18
#, fuzzy
msgid ""
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""
"/// Implementaci√≥n del m√©todo HelloWorld::hello.\n"
"#[no_mangle]\n"
"pub externo \"sistema\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _clase: Clase J,\n"
"    nombre: JString,\n"
") -> jcadena {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let saludo = formato!(\"¬°Hola, {entrada}!\");\n"
"    let output = env.new_string(saludo).unwrap();\n"
"    salida.into_inner()\n"
"}\n"
"```"

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperabilidad/java/Android.bp_:"

#: src/android/interoperability/java.md:34
#, fuzzy
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi_shared {\n"
"    nombre: \"libhello_jni\",\n"
"    crate_name: \"hola_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Finalmente, podemos llamar a esta funci√≥n desde Java:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperabilidad/java/HolaMundo.java_:"

#: src/android/interoperability/java.md:47
#, fuzzy
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);"
msgstr ""
"```java\n"
"clase holamundo {\n"
"    cadena nativa est√°tica privada hola (nombre de la cadena);"

#: src/android/interoperability/java.md:51
#, fuzzy
msgid ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"
msgstr ""
"    est√°tico {\n"
"        System.loadLibrary(\"hola_jni\");\n"
"    }"

#: src/android/interoperability/java.md:55
#, fuzzy
msgid ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    public static void main(String[] args) {\n"
"        Salida de cadena = HolaMundo.hola(\"Alicia\");\n"
"        System.out.println(salida);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/java.md:64
#, fuzzy
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"java_binario {\n"
"    nombre: \"holamundo_jni\",\n"
"    srcs: [\"HolaMundo.java\"],\n"
"    main_class: \"HolaMundo\",\n"
"    requerido: [\"libhello_jni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Finalmente, puede compilar, sincronizar y ejecutar el binario:"

#: src/android/interoperability/java.md:75
#, fuzzy
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""
"```concha\n"
"$ m holamundo_jni\n"
"$ adb sync # requiere adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"

#: src/exercises/day-4/afternoon.md:3
#, fuzzy
msgid ""
"For the last exercise, we will look at one of the projects you work with. "
"Let us\n"
"group up and do this together. Some suggestions:"
msgstr ""
"Para el √∫ltimo ejercicio, veremos uno de los proyectos con los que trabaja. "
"Nos deja\n"
"Agruparse y hacer esto juntos. Algunas sugerencias:"

#: src/exercises/day-4/afternoon.md:6
#, fuzzy
msgid "* Call your AIDL service with a client written in Rust."
msgstr "* Llame a su servicio AIDL con un cliente escrito en Rust."

#: src/exercises/day-4/afternoon.md:8
#, fuzzy
msgid "* Move a function from your project to Rust and call it."
msgstr "* Mueve una funci√≥n de tu proyecto a Rust y ll√°mala."

#: src/exercises/day-4/afternoon.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"No se proporciona ninguna soluci√≥n aqu√≠ ya que esto es abierto: depende de "
"alguien en\n"
"la clase tiene un fragmento de c√≥digo que puede entregar a Rust sobre la "
"marcha."

#: src/thanks.md:1
#, fuzzy
msgid "# Thanks!"
msgstr "# ¬°Gracias!"

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust ü¶Ä!_ We hope you enjoyed it and that "
"it\n"
"was useful."
msgstr ""
"_¬°Gracias por tomar Comprehensive Rust ü¶Ä!_ Esperamos que lo hayas disfrutado "
"y que\n"
"fue √∫til"

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get "
"in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would "
"love\n"
"to hear from you."
msgstr ""
"Nos hemos divertido mucho organizando el curso. El curso no es perfecto,\n"
"por lo tanto, si detecta alg√∫n error o tiene ideas para mejorar, ingrese\n"
"[contacta con nosotros en\n"
"GitHub](https://github.com/google/comprehensive-rust/discusiones). "
"Amar√≠amos\n"
"para saber de ti."

#: src/other-resources.md:1
#, fuzzy
msgid "# Other Rust Resources"
msgstr "# Otros recursos de √≥xido"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"La comunidad de Rust ha creado una gran cantidad de recursos gratuitos y de "
"alta calidad.\n"
"en l√≠nea."

#: src/other-resources.md:6
#, fuzzy
msgid "## Official Documentation"
msgstr "## Documentaci√≥n Oficial"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "El proyecto Rust alberga muchos recursos. Estos cubren Rust en general:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes "
"a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust\n"
"  syntax via a series of examples which showcase different constructs. "
"Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full "
"documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [El lenguaje de programaci√≥n Rust](https://doc.rust-lang.org/book/): el\n"
"  Libro can√≥nico gratuito sobre Rust. Cubre el lenguaje en detalle e incluye "
"una\n"
"  pocos proyectos para que la gente construya.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): cubre el "
"Rust\n"
"  sintaxis a trav√©s de una serie de ejemplos que muestran diferentes "
"construcciones. A veces\n"
"  incluye peque√±os ejercicios en los que se le pide que ampl√≠e el c√≥digo en "
"el\n"
"  ejemplos\n"
"* [Biblioteca est√°ndar de Rust](https://doc.rust-lang.org/std/): "
"documentaci√≥n completa de\n"
"  la biblioteca est√°ndar para Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): un libro "
"incompleto\n"
"  que describe la gram√°tica y el modelo de memoria de Rust."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr "M√°s gu√≠as especializadas alojadas en el sitio oficial de Rust:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe "
"Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in "
"Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after "
"the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): cubre Rust "
"inseguro,\n"
"  incluido el trabajo con punteros en bruto y la interfaz con otros idiomas\n"
"  (FFI).\n"
"* [Programaci√≥n as√≠ncrona en "
"Rust](https://rust-lang.github.io/async-book/):\n"
"  cubre el nuevo modelo de programaci√≥n asincr√≥nica que se introdujo despu√©s "
"de la\n"
"  Rust Book fue escrito.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"un\n"
"  introducci√≥n al uso de Rust en dispositivos integrados sin un sistema "
"operativo."

#: src/other-resources.md:33
#, fuzzy
msgid "## Unofficial Learning Material"
msgstr "## Material de aprendizaje no oficial"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Una peque√±a selecci√≥n de otras gu√≠as y tutoriales para Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers "
"Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust "
"from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other "
"languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to "
"help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): "
"a\n"
"  series of small presentations covering both basic and advanced part of "
"the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) "
"and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and "
"the\n"
"  second is a set of 11 modules which covers Rust syntax and basic "
"constructs."
msgstr ""
"* [Learn Rust the Dangerous Way] (http://cliffle.com/p/dangerust/): cubre "
"Rust\n"
"  desde la perspectiva de los programadores de C de bajo nivel.\n"
"* [√ìxido para C incrustado\n"
"  Programadores](https://docs.opentitan.org/doc/ug/rust_for_c/): cubre Rust "
"de\n"
"  la perspectiva de los desarrolladores que escriben firmware en C.\n"
"* [Rust para profesionales](https://overexact.com/rust-for-professionals/):\n"
"  cubre la sintaxis de Rust usando comparaciones lado a lado con otros "
"lenguajes\n"
"  como C, C++, Java, JavaScript y Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): m√°s de 100 "
"ejercicios para ayudar\n"
"  aprendes √≥xido.\n"
"* [Ense√±anza ferrosa\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): "
"un\n"
"  serie de peque√±as presentaciones que cubren tanto la parte b√°sica como la "
"avanzada del\n"
"  Lenguaje oxidado. Tambi√©n se incluyen otros temas, como WebAssembly y "
"async/await.\n"
"  cubierto.\n"
"* [Serie de principiantes a\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) y\n"
"  [Da tus primeros pasos con\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"dos\n"
"  Rust gu√≠as dirigidas a nuevos desarrolladores. El primero es un conjunto "
"de 35 videos y el\n"
"  el segundo es un conjunto de 11 m√≥dulos que cubre la sintaxis de Rust y "
"las construcciones b√°sicas."

#: src/other-resources.md:59
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for\n"
"even more Rust books."
msgstr ""
"Consulte el [Little Book of Rust Books] (https://lborb.github.io/book/) "
"para\n"
"a√∫n m√°s libros de Rust."

#: src/credits.md:1
#, fuzzy
msgid "# Credits"
msgstr "# Cr√©ditos"

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of "
"useful\n"
"resources."
msgstr ""
"El material aqu√≠ se basa en las muchas fuentes excelentes de documentaci√≥n "
"de Rust.\n"
"Consulte la p√°gina en [otros recursos](other-resources.md) para obtener una "
"lista completa de recursos √∫tiles.\n"
"recursos."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"El material de Comprehensive Rust tiene licencia bajo los t√©rminos de Apache "
"2.0\n"
"licencia, consulte [`LICENSE`](../LICENSE) para obtener m√°s informaci√≥n."

#: src/credits.md:10
#, fuzzy
msgid "## Rust by Example"
msgstr "## Rust por ejemplo"

#: src/credits.md:12
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Algunos ejemplos y ejercicios han sido copiados y adaptados de [Rust by\n"
"Ejemplo](https://doc.rust-lang.org/rust-by-example/). Por favor vea el\n"
"directorio `third_party/rust-by-example/` para obtener detalles, incluida la "
"licencia\n"
"t√©rminos."

#: src/credits.md:17
#, fuzzy
msgid "## Rust on Exercism"
msgstr "## Rust en el ejercicio"

#: src/credits.md:19
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the "
"license\n"
"terms."
msgstr ""
"Algunos ejercicios han sido copiados y adaptados de [Rust on\n"
"Ejercicio](https://exercism.org/tracks/rust). Por favor vea el\n"
"directorio `third_party/rust-on-exercism/` para obtener detalles, incluida "
"la licencia\n"
"t√©rminos."

#: src/credits.md:24
#, fuzzy
msgid "## CXX"
msgstr "##CXX"

#: src/credits.md:26
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory\n"
"for details, including the license terms."
msgstr ""
"La secci√≥n [Interoperabilidad con C++](android/interoperability/cpp.md) "
"utiliza un\n"
"imagen de [CXX](https://cxx.rs/). Consulte el directorio `third_party/cxx/`\n"
"para m√°s detalles, incluidos los t√©rminos de la licencia."

#: src/exercises/solutions.md:1
#, fuzzy
msgid "# Solutions"
msgstr "# Soluciones"

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Encontrar√° las soluciones a los ejercicios en las siguientes p√°ginas."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us "
"know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"No dude en hacer preguntas sobre las soluciones [en\n"
"GitHub](https://github.com/google/comprehensive-rust/discusiones). Haznos "
"saber\n"
"si tiene una soluci√≥n diferente o mejor que la que se presenta aqu√≠."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Nota:** Ignore `// ANCHOR: label` y `// ANCHOR_END: label`\n"
"> comentarios que ves en las soluciones. Est√°n ah√≠ para hacer posible\n"
"> reutilizar partes de las soluciones como ejercicios."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "# Day 1 Morning Exercises"
msgstr "# D√≠a 1 Ejercicios matutinos"

#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "## Arrays and `for` Loops"
msgstr "## Matrices y bucles `for`"

#: src/exercises/day-1/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](for-loops.md))"
msgstr "([volver al ejercicio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
#: src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7
#: src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102
#: src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7
#: src/exercises/day-4/solutions-morning.md:7
#, fuzzy
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."
msgstr ""
"```herrumbre\n"
"// Derechos de autor 2022¬†Google LLC\n"
"//\n"
"// Con licencia de Apache License, Versi√≥n 2.0 (la \"Licencia\");\n"
"// no puede usar este archivo excepto de conformidad con la Licencia.\n"
"// Puede obtener una copia de la Licencia en\n"
"//\n"
"// http://www.apache.org/licenses/LICENCIA-2.0\n"
"//\n"
"// A menos que lo exija la ley aplicable o se acuerde por escrito, el "
"software\n"
"// distribuido bajo la Licencia se distribuye \"TAL CUAL\",\n"
"// SIN GARANT√çAS NI CONDICIONES DE NING√öN TIPO, ya sean expresas o "
"impl√≠citas.\n"
"// Ver la Licencia para el idioma espec√≠fico que rige los permisos y\n"
"// limitaciones bajo la Licencia."

#: src/exercises/day-1/solutions-morning.md:22
#, fuzzy
msgid ""
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"// ANCLA: transponer\n"
"fn transpose(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transponer\n"
"    let mut resultado = [[0; 3]; 3];\n"
"    para i en 0..3 {\n"
"        para j en 0..3 {\n"
"            resultado[j][i] = matriz[i][j];\n"
"        }\n"
"    }\n"
"    resultado devuelto;\n"
"}"

#: src/exercises/day-1/solutions-morning.md:34
#, fuzzy
msgid ""
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}"
msgstr ""
"// ANCLA: pretty_print\n"
"fn pretty_print(matriz: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: bonita_impresi√≥n\n"
"    para fila en matriz {\n"
"        println!(\"{fila:?}\");\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-morning.md:42
#, fuzzy
msgid ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"
msgstr ""
"// ANCLA: pruebas\n"
"#[prueba]\n"
"fn prueba_transponer() {\n"
"    sea matriz = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transpuesto = transponer (matriz);\n"
"    afirmar_eq!(\n"
"        transpuesto,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: pruebas"

#: src/exercises/day-1/solutions-morning.md:62
#, fuzzy
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""
"// ANCLA: principal\n"
"fn principal() {\n"
"    sea matriz = [\n"
"        [101, 102, 103], // <-- el comentario hace que rustfmt agregue una "
"nueva l√≠nea\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"

#: src/exercises/day-1/solutions-morning.md:73
#, fuzzy
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"### Bonus question"
msgstr ""
"    let transpuesto = transponer (matriz);\n"
"    println!(\"transpuesto:\");\n"
"    pretty_print(&transpuesto);\n"
"}\n"
"```\n"
"### Pregunta extra"

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It honestly doesn't work so well. It might seem that we could use a "
"slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus make "
"our function handle any size of matrix. However, this quickly breaks down: "
"the return type cannot be `&[&[i32]]` since it needs to own the data you "
"return."
msgstr ""
"Sinceramente, no funciona tan bien. Podr√≠a parecer que podr√≠amos usar una "
"rebanada de rebanadas (`&[&[i32]]`) como el tipo de entrada para transponer "
"y as√≠ hacer que nuestra funci√≥n maneje cualquier tama√±o de matriz. Sin "
"embargo, esto falla r√°pidamente: el tipo de devoluci√≥n no puede ser "
"`&[&[i32]]` ya que necesita poseer los datos que devuelve."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"very well either: it's hard to convert from `Vec<Vec<i32>>` to `&[&[i32]]` "
"so now you cannot easily use `pretty_print` either."
msgstr ""
"Puedes intentar usar algo como `Vec<Vec<i32>>`, pero esto tampoco funciona "
"muy bien: es dif√≠cil convertir de `Vec<Vec<i32>>` a `&[&[i32]] ` as√≠ que "
"ahora tampoco puedes usar `pretty_print` f√°cilmente."

#: src/exercises/day-1/solutions-morning.md:84
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Adem√°s, el tipo en s√≠ no exigir√≠a que los segmentos secundarios tengan la "
"misma longitud, por lo que dicha variable podr√≠a contener una matriz no "
"v√°lida."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 1 Afternoon Exercises"
msgstr "# D√≠a 1 Ejercicios por la tarde"

#: src/exercises/day-1/solutions-afternoon.md:3
#, fuzzy
msgid "## Designing a Library"
msgstr "## Dise√±o de una biblioteca"

#: src/exercises/day-1/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](book-library.md))"
msgstr "([volver al ejercicio](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:22
#, fuzzy
msgid ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"// ANCLA: configuraci√≥n\n"
"Biblioteca de estructura {\n"
"    libros: Vec<Libro>,\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:42
#, fuzzy
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"
msgstr ""
"// Esto hace posible imprimir valores de libros con {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Resultado {\n"
"        escribe!(f, \"{} ({})\", auto.t√≠tulo, auto.a√±o)\n"
"    }\n"
"}\n"
"// ANCHOR_END: configuraci√≥n"

#: src/exercises/day-1/solutions-afternoon.md:50
#, fuzzy
msgid ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"
msgstr ""
"// ANCLA: Library_new\n"
"Biblioteca impl {\n"
"    fn nuevo() -> Biblioteca {\n"
"        // ANCHOR_END: Biblioteca_nueva\n"
"        Biblioteca { libros: Vec::nuevo() }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:57
#, fuzzy
msgid ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"
msgstr ""
"    // ANCLA: Library_len\n"
"    //fn len(self) -> usar {\n"
"    // sin implementar!()\n"
"    //\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usar {\n"
"        self.libros.len()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:66
#, fuzzy
msgid ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"
msgstr ""
"    // ANCLA: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    // sin implementar!()\n"
"    //\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn est√°_vac√≠o(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:75
#, fuzzy
msgid ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"
msgstr ""
"    // ANCLA: Library_add_book\n"
"    //fn add_book(self, libro: Libro) {\n"
"    // sin implementar!()\n"
"    //\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, libro: Libro) {\n"
"        self.books.push(libro)\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:84
#, fuzzy
msgid ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"
msgstr ""
"    // ANCLA: Library_print_books\n"
"    //fn imprimir_libros(self) {\n"
"    // sin implementar!()\n"
"    //\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn imprimir_libros(&self) {\n"
"        para libro en &self.books {\n"
"            println!(\"{}\", libro);\n"
"        }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:95
#, fuzzy
msgid ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"
msgstr ""
"    // ANCLA: Library_oldest_book\n"
"    //fn libro_antiguo(self) -> Opci√≥n<&Libro> {\n"
"    // sin implementar!()\n"
"    //\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn libro_antiguo(&self) -> Opci√≥n<&Libro> {\n"
"        self.libros.iter().min_by_key(|libro| libro.a√±o)\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:105
#, fuzzy
msgid ""
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// ANCLA: principal\n"
"// Esto muestra el comportamiento deseado. Descomente el c√≥digo a "
"continuaci√≥n y\n"
"// implementar los m√©todos faltantes. Deber√° actualizar el\n"
"// firmas de m√©todos, incluido el par√°metro \"self\"! Puedes\n"
"// tambi√©n es necesario actualizar los enlaces de variables dentro de main.\n"
"fn principal() {\n"
"    let biblioteca = Biblioteca::nuevo();"

#: src/exercises/day-1/solutions-afternoon.md:113
#, fuzzy
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"// ANCHOR_END: main"
msgstr ""
"    //println!(\"Nuestra biblioteca est√° vac√≠a: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"El Se√±or de los Anillos\", 1954));\n"
"    //library.add_book(Book::new(\"Las aventuras de Alicia en el pa√≠s de las "
"maravillas\", 1865));\n"
"    //\n"
"    //biblioteca.print_books();\n"
"    //\n"
"    //coincide biblioteca.libro_antiguo() {\n"
"    // Algunos(libro) => println!(\"Mi libro m√°s antiguo es {libro}\"),\n"
"    // Ninguno => println!(\"¬°Mi biblioteca est√° vac√≠a!\"),\n"
"    //\n"
"    //\n"
"    //println!(\"Nuestra biblioteca tiene {} libros\", biblioteca.len());\n"
"}\n"
"// ANCHOR_END: principal"

#: src/exercises/day-1/solutions-afternoon.md:129
#, fuzzy
msgid ""
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());"
msgstr ""
"#[prueba]\n"
"fn test_library_len() {\n"
"    let mut biblioteca = Biblioteca::nueva();\n"
"    afirmar_eq!(biblioteca.len(), 0);\n"
"    afirmar!(biblioteca.is_empty());"

#: src/exercises/day-1/solutions-afternoon.md:135
#, fuzzy
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""
"    biblioteca.add_book(Libro::nuevo(\"El Se√±or de los Anillos\", 1954));\n"
"    library.add_book(Book::new(\"Las aventuras de Alicia en el pa√≠s de las "
"maravillas\", 1865));\n"
"    afirmar_eq!(biblioteca.len(), 2);\n"
"    afirmar!(!library.is_empty());\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:141
#, fuzzy
msgid ""
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());"
msgstr ""
"#[prueba]\n"
"fn test_library_is_empty() {\n"
"    let mut biblioteca = Biblioteca::nueva();\n"
"    afirmar!(biblioteca.is_empty());"

#: src/exercises/day-1/solutions-afternoon.md:146
#, fuzzy
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""
"    biblioteca.add_book(Libro::nuevo(\"El Se√±or de los Anillos\", 1954));\n"
"    afirmar!(!library.is_empty());\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:150
#, fuzzy
msgid ""
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}"
msgstr ""
"#[prueba]\n"
"fn prueba_biblioteca_imprimir_libros() {\n"
"    let mut biblioteca = Biblioteca::nueva();\n"
"    biblioteca.add_book(Libro::nuevo(\"El Se√±or de los Anillos\", 1954));\n"
"    library.add_book(Book::new(\"Las aventuras de Alicia en el pa√≠s de las "
"maravillas\", 1865));\n"
"    // Podr√≠amos intentar capturar stdout, pero llamemos al\n"
"    // m√©todo para empezar.\n"
"    biblioteca.print_books();\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:160
#, fuzzy
msgid ""
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());"
msgstr ""
"#[prueba]\n"
"fn test_library_oldest_book() {\n"
"    let mut biblioteca = Biblioteca::nueva();\n"
"    afirmar!(biblioteca.libro_antiguo().is_none());"

#: src/exercises/day-1/solutions-afternoon.md:165
#, fuzzy
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );"
msgstr ""
"    biblioteca.add_book(Libro::nuevo(\"El Se√±or de los Anillos\", 1954));\n"
"    afirmar_eq!(\n"
"        biblioteca.libro_antiguo().map(|b| b.title.as_str()),\n"
"        Algunos (\"El se√±or de los anillos\")\n"
"    );"

#: src/exercises/day-1/solutions-afternoon.md:171
#, fuzzy
msgid ""
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""
"    library.add_book(Book::new(\"Las aventuras de Alicia en el pa√≠s de las "
"maravillas\", 1865));\n"
"    afirmar_eq!(\n"
"        biblioteca.libro_antiguo().map(|b| b.title.as_str()),\n"
"        Algunos (\"Las aventuras de Alicia en el pa√≠s de las maravillas\")\n"
"    );\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "# Day 2 Morning Exercises"
msgstr "# D√≠a 2 Ejercicios matutinos"

#: src/exercises/day-2/solutions-morning.md:3
#, fuzzy
msgid "## Points and Polygons"
msgstr "## Puntos y Pol√≠gonos"

#: src/exercises/day-2/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](points-polygons.md))"
msgstr "([volver al ejercicio](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:22
#, fuzzy
msgid ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"
msgstr ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCLA: Punto\n"
"pub punto de estructura {\n"
"    // ANCHOR_END: Punto\n"
"    x: i32,\n"
"    y: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:30
#, fuzzy
msgid ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"
msgstr ""
"// ANCLA: Punto-impl\n"
"punto impl {\n"
"    // ANCHOR_END: Punto-impl\n"
"    pub fn nuevo (x: i32, y: i32) -> Punto {\n"
"        Punto { x, y }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:37
#, fuzzy
msgid ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"
msgstr ""
"    pub fn magnitud(auto) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:41
#, fuzzy
msgid ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(self, otro: Punto) -> f64 {\n"
"        (yo - otro).magnitud()\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:49
#, fuzzy
msgid ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn add(self, otro: Self) -> Self::Output {\n"
"        Ser {\n"
"            x: uno mismo.x + otro.x,\n"
"            y: propio.y + otro.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:57
#, fuzzy
msgid "impl std::ops::Sub for Point {\n    type Output = Self;"
msgstr "impl std::ops::Sub para Punto {\n    escriba Salida = Auto;"

#: src/exercises/day-2/solutions-morning.md:60
#, fuzzy
msgid ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn sub(self, otro: Self) -> Self::Output {\n"
"        Ser {\n"
"            x: uno mismo.x - otro.x,\n"
"            y: propio.y - otro.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:68
#, fuzzy
msgid ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"
msgstr ""
"// ANCLA: Pol√≠gono\n"
"pub struct Pol√≠gono {\n"
"    // ANCHOR_END: Pol√≠gono\n"
"    puntos: Vec<Punto>,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:74
#, fuzzy
msgid ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"
msgstr ""
"// ANCLA: Polygon-impl\n"
"pol√≠gono impl {\n"
"    // ANCHOR_END: Pol√≠gono-impl\n"
"    pub fn new() -> Pol√≠gono {\n"
"        Pol√≠gono { puntos: Vec::new() }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:81
#, fuzzy
msgid ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"
msgstr ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(punto);\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:85
#, fuzzy
msgid ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"
msgstr ""
"    pub fn punto_m√°s_izquierda(&self) -> Opci√≥n<Punto> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:89
#, fuzzy
msgid ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"
msgstr ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.puntos.iter()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:93
#, fuzzy
msgid ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"
msgstr ""
"    longitud pub fn(&self) -> f64 {\n"
"        si self.points.is_empty() {\n"
"            devolver 0.0;\n"
"        }"

#: src/exercises/day-2/solutions-morning.md:98
#, fuzzy
msgid ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"
msgstr ""
"        dejar resultado mut = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        para punto en &self.points[1..] {\n"
"            resultado += ultimo_punto.dist(*punto);\n"
"            √∫ltimo_punto = *punto;\n"
"        }\n"
"        resultado += ultimo_punto.dist(self.puntos[0]);\n"
"        resultado\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:109
#, fuzzy
msgid ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"
msgstr ""
"// ANCLA: C√≠rculo\n"
"pub struct Circulo {\n"
"    // ANCHOR_END: C√≠rculo\n"
"    punto central,\n"
"    radio: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:116
#, fuzzy
msgid ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"
msgstr ""
"// ANCLA: C√≠rculo-impl\n"
"c√≠rculo impl {\n"
"    // ANCHOR_END: C√≠rculo-impl\n"
"    pub fn new(centro: Punto, radio: i32) -> Circulo {\n"
"        C√≠rculo { centro, radio }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:123
#, fuzzy
msgid ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"
msgstr ""
"    pub fn circunferencia(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:127
#, fuzzy
msgid ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(&self, otro: &Self) -> f64 {\n"
"        self.center.dist(otro.centro)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:132
#, fuzzy
msgid ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"
msgstr ""
"// ANCLA: Forma\n"
"pub enum Forma {\n"
"    Pol√≠gono(Pol√≠gono),\n"
"    C√≠rculo (C√≠rculo),\n"
"}\n"
"// ANCHOR_END: Forma"

#: src/exercises/day-2/solutions-morning.md:139
#, fuzzy
msgid ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"
msgstr ""
"impl Desde<Pol√≠gono> para Forma {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Forma::Pol√≠gono (poli)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:145
#, fuzzy
msgid ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"
msgstr ""
"impl Desde<C√≠rculo> para Forma {\n"
"    fn de (c√≠rculo: C√≠rculo) -> Self {\n"
"        Forma::C√≠rculo (c√≠rculo)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:151
#, fuzzy
msgid ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"Forma impl {\n"
"    pub fn perimetral(&self) -> f64 {\n"
"        coincidir con uno mismo {\n"
"            Forma::Pol√≠gono(poli) => poli.longitud(),\n"
"            Forma::C√≠rculo(c√≠rculo) => c√≠rculo.circunferencia(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:160
#, fuzzy
msgid ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"// ANCLA: pruebas unitarias\n"
"#[cfg(prueba)]\n"
"pruebas de modificaci√≥n {\n"
"    usar super::*;"

#: src/exercises/day-2/solutions-morning.md:213
#, fuzzy
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""
"    #[prueba]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poli = Pol√≠gono::nuevo();\n"
"        poly.add_point(Punto::nuevo(12, 13));\n"
"        poly.add_point(Punto::nuevo(17, 11));\n"
"        poly.add_point(Punto::nuevo(16, 16));\n"
"        let formas = vec![\n"
"            Forma::de (poli),\n"
"            Forma::desde(C√≠rculo::nuevo(Punto::nuevo(10, 20), 5)),\n"
"        ];\n"
"        sea per√≠metros = formas\n"
"            .iter()\n"
"            .map(Forma::per√≠metro)\n"
"            .mapa(ronda_dos_d√≠gitos)\n"
"            .recoger::<Vec<_>>();\n"
"        afirmar_eq!(per√≠metros, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: pruebas unitarias"

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 2 Afternoon Exercises"
msgstr "# D√≠a 2 Ejercicios por la tarde"

#: src/exercises/day-2/solutions-afternoon.md:3
#, fuzzy
msgid "## Luhn Algorithm"
msgstr "## Algoritmo de Luhn"

#: src/exercises/day-2/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](luhn.md))"
msgstr "([volver al ejercicio](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:22
#, fuzzy
msgid ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' "
"').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"
msgstr ""
"// ANCLA: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: Luhn\n"
"    let mut digits_seen = 0;\n"
"    sea mut suma = 0;\n"
"    for (i, ch) en cc_number.chars().rev().filter(|&ch| ch != ' "
"').enumerate() {\n"
"        hacer coincidir ch.to_digit(10) {\n"
"            Algunos (d) => {\n"
"                suma += si yo % 2 == 1 {\n"
"                    sea dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } m√°s {\n"
"                    d\n"
"                };\n"
"                d√≠gitos_vistos += 1;\n"
"            }\n"
"            Ninguno => devuelve falso,\n"
"        }\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:42
#, fuzzy
msgid ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"
msgstr ""
"    si d√≠gitos_vistos < 2 {\n"
"        falso retorno;\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:46
#, fuzzy
msgid "    sum % 10 == 0\n}"
msgstr "    suma % 10 == 0\n}"

#: src/exercises/day-2/solutions-afternoon.md:49
#, fuzzy
msgid ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}"
msgstr ""
"fn principal() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    imprimir!(\n"
"        \"¬øEs {} un n√∫mero de tarjeta de cr√©dito v√°lido? {}\",\n"
"        n√∫mero_cc,\n"
"        if luhn(cc_number) { \"s√≠\" } else { \"no\" }\n"
"    );\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:58
#, fuzzy
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""
"// ANCLA: pruebas unitarias\n"
"#[prueba]\n"
"fn test_non_digit_cc_number() {\n"
"    afirmar!(!luhn(\"foo\"));\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:89
#, fuzzy
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""
"#[prueba]\n"
"fn test_invalid_cc_number() {\n"
"    afirmar!(!luhn(\"4223 9826 4026 9299\"));\n"
"    afirmar!(!luhn(\"4539 3195 0343 6476\"));\n"
"    afirmar!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: pruebas unitarias\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:98
#, fuzzy
msgid "## Strings and Iterators"
msgstr "## Cadenas e iteradores"

#: src/exercises/day-2/solutions-afternoon.md:100
#, fuzzy
msgid "([back to exercise](strings-iterators.md))"
msgstr "([volver al ejercicio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:117
#, fuzzy
msgid ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"
msgstr ""
"// ANCLA: prefix_matches\n"
"pub fn prefix_matches(prefijo: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefijo_coincidencias\n"
"    let prefijos = prefijo.split('/');\n"
"    let request_paths = request_path\n"
"        .separar('/')\n"
"        .map(|p| Algunos(p))\n"
"        .chain(std::iter::once(Ninguno));"

#: src/exercises/day-2/solutions-afternoon.md:126
#, fuzzy
msgid ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"
msgstr ""
"    para (prefijo, ruta_solicitud) en prefijos.zip(ruta_solicitud) {\n"
"        coincide con request_path {\n"
"            Algunos (solicitud_ruta) => {\n"
"                if (prefijo != \"*\") && (prefijo != ruta_solicitud) {\n"
"                    falso retorno;\n"
"                }\n"
"            }\n"
"            Ninguno => devuelve falso,\n"
"        }\n"
"    }\n"
"    verdadero\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:139
#, fuzzy
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));"
msgstr ""
"// ANCLA: pruebas unitarias\n"
"#[prueba]\n"
"fn prueba_coincidencias_sin_comod√≠n() {\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores\"));\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores/abc-123\"));\n"
"    aseverar!(prefix_matches(\"/v1/editores\", \"/v1/editores/abc/libros\"));"

#: src/exercises/day-2/solutions-afternoon.md:166
#, fuzzy
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""
"    afirmar!(!prefix_matches(\"/v1/editores/*/libros\", \"/v1/editores\"));\n"
"    afirmar!(!prefix_matches(\n"
"        \"/v1/editores/*/libros\",\n"
"        \"/v1/editores/foo/librosPorAutor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: pruebas unitarias\n"
"```"

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "# Day 3 Morning Exercise"
msgstr "# D√≠a 3 Ejercicio matutino"

#: src/exercises/day-3/solutions-morning.md:3
#, fuzzy
msgid "## A Simple GUI Library"
msgstr "## Una biblioteca GUI simple"

#: src/exercises/day-3/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](simple-gui.md))"
msgstr "([volver al ejercicio](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:22
#, fuzzy
msgid ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"// ANCLA: configuraci√≥n\n"
"Widget de rasgo de pub {\n"
"    /// Ancho natural de `self`.\n"
"    ancho fn(&self) -> tama√±o de uso;"

#: src/exercises/day-3/solutions-morning.md:82
#, fuzzy
msgid "// ANCHOR_END: setup"
msgstr "// ANCHOR_END: configuraci√≥n"

#: src/exercises/day-3/solutions-morning.md:84
#, fuzzy
msgid ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"
msgstr ""
"// ANCLA: ancho de ventana\n"
"Widget impl para ventana {\n"
"    fn ancho(&self) -> usar {\n"
"        // ANCHOR_END: Ancho de ventana\n"
"        est√°ndar::cmp::m√°x(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:94
#, fuzzy
msgid ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"
msgstr ""
"    // ANCLA: Ventana-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Ventana-draw_into\n"
"        let mut interior = String::new();\n"
"        para widget en &self.widgets {\n"
"            widget.draw_into(&mut interior);\n"
"        }"

#: src/exercises/day-3/solutions-morning.md:102
#, fuzzy
msgid "        let window_width = self.width();"
msgstr "        let window_width = self.width();"

#: src/exercises/day-3/solutions-morning.md:104
#, fuzzy
msgid ""
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""
"        // TODO: despu√©s de aprender sobre el manejo de errores, puede "
"cambiar\n"
"        // draw_into para devolver Result<(), std::fmt::Error>. Entonces "
"usa\n"
"        // el operador ? aqu√≠ en lugar de .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        para l√≠nea en l√≠neas internas () {\n"
"            writeln!(b√∫fer, \"| {:window_width$} |\", l√≠nea).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:117
#, fuzzy
msgid ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"
msgstr ""
"// ANCLA: Ancho del bot√≥n\n"
"Widget impl para bot√≥n {\n"
"    fn ancho(&self) -> usar {\n"
"        // ANCHOR_END: Ancho del bot√≥n\n"
"        self.label.width() + 8 // agrega un poco de relleno\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:124
#, fuzzy
msgid ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"
msgstr ""
"    // ANCLA: Bot√≥n-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Bot√≥n-draw_into\n"
"        let ancho = self.ancho();\n"
"        let mut etiqueta = String::new();\n"
"        self.label.draw_into(&mut etiqueta);"

#: src/exercises/day-3/solutions-morning.md:131
#, fuzzy
msgid ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""
"        writeln!(buffer, \"+{:-<ancho$}+\", \"\").unwrap();\n"
"        para l√≠nea en etiqueta.l√≠neas() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<ancho$}+\", \"\").unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:139
#, fuzzy
msgid ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"
msgstr ""
"// ANCLA: Ancho de etiqueta\n"
"Widget impl para etiqueta {\n"
"    fn ancho(&self) -> usar {\n"
"        // ANCHOR_END: Ancho de la etiqueta\n"
"        auto.etiqueta\n"
"            .l√≠neas()\n"
"            .mapa(|l√≠nea| l√≠nea.caracteres().cuenta())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:150
#, fuzzy
msgid ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"
msgstr ""
"    // ANCLA: Etiqueta-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Etiqueta-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:157
#, fuzzy
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI "
"demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""
"// ANCLA: principal\n"
"fn principal() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Esta es una peque√±a demostraci√≥n "
"de GUI de texto.\")));\n"
"    ventana.add_widget(Cuadro::nuevo(Bot√≥n::nuevo(\n"
"        \"¬°Haz click en mi!\",\n"
"        Box::new(|| println!(\"¬°Hiciste clic en el bot√≥n!\")),\n"
"    )));\n"
"    ventana.dibujar();\n"
"}\n"
"// ANCHOR_END: principal\n"
"```"

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 3 Afternoon Exercises"
msgstr "# D√≠a 3 Ejercicios por la tarde"

#: src/exercises/day-3/solutions-afternoon.md:3
#, fuzzy
msgid "## Safe FFI Wrapper"
msgstr "## Envoltura FFI segura"

#: src/exercises/day-3/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([volver al ejercicio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:22
#, fuzzy
msgid ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""
"// ANCLA: ffi\n"
"mod fi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#: src/exercises/day-3/solutions-afternoon.md:53
#, fuzzy
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"
msgstr ""
"#[derivar(Depurar)]\n"
"struct DirectorioIterador {\n"
"    ruta: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: s√≠"

#: src/exercises/day-3/solutions-afternoon.md:60
#, fuzzy
msgid ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"// ANCLA: DirectorioIterador\n"
"impl DirectoryIterator {\n"
"    fn new(ruta: &str) -> Result<DirectoryIterator, String> {\n"
"        // Llame a opendir y devuelva un valor Ok si funcion√≥,\n"
"        // de lo contrario, devuelve Err con un mensaje.\n"
"        // ANCHOR_END: DirectorioIterador\n"
"        let ruta = CString::new(ruta).map_err(|err| formato!(\"Ruta "
"inv√°lida: {err}\"))?;\n"
"        // SEGURIDAD: path.as_ptr() no puede ser NULL.\n"
"        let dir = inseguro { ffi::opendir(ruta.as_ptr()) };\n"
"        si dir.is_null() {\n"
"            Err(formato!(\"No se pudo abrir {:?}\", ruta))\n"
"        } m√°s {\n"
"            Ok (DirectoryIterator {ruta, directorio})\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:77
#, fuzzy
msgid ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"
msgstr ""
"// ANCLA: Iterador\n"
"Iterador impl para DirectoryIterator {\n"
"    escriba Elemento = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Contin√∫e llamando a readdir hasta que obtengamos un puntero NULL "
"de vuelta.\n"
"        // ANCHOR_END: Iterador\n"
"        // SEGURIDAD: self.dir nunca es NULL.\n"
"        let dirent = inseguro { ffi::readdir(self.dir) };\n"
"        si directo.es_null() {\n"
"            // Hemos llegado al final del directorio.\n"
"            devuelve Ninguno;\n"
"        }\n"
"        // SEGURIDAD: dirent no es NULL y dirent.d_name es NUL\n"
"        // terminado.\n"
"        let d_name = inseguro { CStr::from_ptr((*dirent).d_name.as_ptr()) "
"};\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Algunos (os_str.a_propiedad())\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:97
#, fuzzy
msgid ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"// ANCLA: Soltar\n"
"impl Drop para DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Llame a closedir seg√∫n sea necesario.\n"
"        // ANCHOR_END: Soltar\n"
"        si !self.dir.is_null() {\n"
"            // SEGURIDAD: self.dir no es NULL.\n"
"            si no es seguro { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"No se pudo cerrar {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:111
#, fuzzy
msgid ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""
"// ANCLA: principal\n"
"fn principal() -> Resultado<(), Cadena> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"archivos: {:#?}\", iter.collect::<Vec<_>>());\n"
"    OK(())\n"
"}\n"
"// ANCHOR_END: principal\n"
"```"

#: src/exercises/day-4/solutions-morning.md:1
#, fuzzy
msgid "# Day 4 Morning Exercise"
msgstr "# D√≠a 4 Ejercicio matutino"

#: src/exercises/day-4/solutions-morning.md:3
#, fuzzy
msgid "## Dining Philosophers"
msgstr "## Fil√≥sofos gastron√≥micos"

#: src/exercises/day-4/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([volver al ejercicio](dining-philosophers.md))"

#: src/exercises/day-4/solutions-morning.md:22
#, fuzzy
msgid ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"// ANCLA: Fil√≥sofo\n"
"usar std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"usar est√°ndar::hilo;\n"
"use std::time::Duration;"

#: src/exercises/day-4/solutions-morning.md:30
#, fuzzy
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}"
msgstr ""
"Fil√≥sofo de la estructura {\n"
"    nombre: cadena,\n"
"    // ANCHOR_END: Fil√≥sofo\n"
"    bifurcaci√≥n_izquierda: Arc<Mutex<Fork>>,\n"
"    bifurcaci√≥n_derecha: Arc<Mutex<Fork>>,\n"
"    pensamientos: mpsc::SyncSender<String>,\n"
"}"

#: src/exercises/day-4/solutions-morning.md:38
#, fuzzy
msgid ""
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"
msgstr ""
"// ANCLA: Pensamiento filos√≥fico\n"
"Fil√≥sofo impl {\n"
"    fn piensa(&self) {\n"
"        pensamientos propios\n"
"            .send(format!(\"¬°Eureka! {} tiene una nueva idea!\", "
"&self.name))\n"
"            .desenvolver();\n"
"    }\n"
"    // ANCHOR_END: pensamiento filosofico"

#: src/exercises/day-4/solutions-morning.md:47
#, fuzzy
msgid ""
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"
msgstr ""
"    // ANCLA: Philosopher-eat\n"
"    fn comer(&yo) {\n"
"        // ANCHOR_END: Fil√≥sofo-comer\n"
"        println!(\"{} est√° tratando de comer\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"

#: src/exercises/day-4/solutions-morning.md:54
#, fuzzy
msgid ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""
"        // ANCLA: Fil√≥sofo-comer-fin\n"
"        println!(\"{} est√° comiendo...\", &self.name);\n"
"        thread::sleep(Duraci√≥n::from_millis(10));\n"
"    }\n"
"}"

#: src/exercises/day-4/solutions-morning.md:63
#, fuzzy
msgid ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"
msgstr ""
"fn principal() {\n"
"    // ANCHOR_END: Fil√≥sofo-come-fin\n"
"    let (tx, rx) = mpsc::sync_channel(10);"

#: src/exercises/day-4/solutions-morning.md:67
#, fuzzy
msgid ""
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();"
msgstr ""
"    let tenedores = (0..FIL√ìSOFOS.len())\n"
"        .map(|_| Arco::nuevo(Mutex::nuevo(Tenedor)))\n"
"        .recoger::<Vec<_>>();"

#: src/exercises/day-4/solutions-morning.md:71
#, fuzzy
msgid ""
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
msgstr ""
"    para i en 0..horquillas.len() {\n"
"        let tx = tx.clon();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"

#: src/exercises/day-4/solutions-morning.md:76
#, fuzzy
msgid ""
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"
msgstr ""
"        // Para evitar un interbloqueo, tenemos que romper la simetr√≠a\n"
"        // algun lado. Esto cambiar√° las horquillas sin desinicializar\n"
"        // cualquiera de ellos.\n"
"        if i == tenedores.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"

#: src/exercises/day-4/solutions-morning.md:83
#, fuzzy
msgid ""
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };"
msgstr ""
"        let fil√≥sofo = Fil√≥sofo {\n"
"            nombre: FIL√ìSOFOS[i].to_string(),\n"
"            pensamientos: tx,\n"
"            horquilla_izquierda,\n"
"            bifurcaci√≥n derecha,\n"
"        };"

#: src/exercises/day-4/solutions-morning.md:90
#, fuzzy
msgid ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }"
msgstr ""
"        hilo::spawn(mover || {\n"
"            para _ en 0..100 {\n"
"                filosofo.comer();\n"
"                filosofo.pensar();\n"
"            }\n"
"        });\n"
"    }"

#: src/exercises/day-4/solutions-morning.md:98
#, fuzzy
msgid ""
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{}\", thought);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    soltar (tx);\n"
"    para el pensamiento en rx {\n"
"        println!(\"{}\", pensamiento);\n"
"    }\n"
"}\n"
"```"
